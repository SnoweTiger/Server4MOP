
__d(function (global, _require, module, exports, _dependencyMap) {
    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _miot = _require(_dependencyMap[1]);

    var _reactNative = _require(_dependencyMap[2]);

    var _MapDataUtil = _require(_dependencyMap[3]);

    var _MapDataUtil2 = babelHelpers.interopRequireDefault(_MapDataUtil);

    var _main = _require(_dependencyMap[4]);

    var _main2 = babelHelpers.interopRequireDefault(_main);

    var _StatusUtil = _require(_dependencyMap[5]);

    var _StatusUtil2 = babelHelpers.interopRequireDefault(_StatusUtil);

    if (!_miot.Host.isDebug) {
        global.console = {
            info: function info() {},
            log: function log() {},
            warn: function warn() {},
            debug: function debug() {},
            error: function error() {}
        };
    }

    global.gData = {
        isTouch: false,
        isDebug: false,
        localTimeZone: _miot.Host.locale.timeZone,
        voiceUrl: "https://cnbj2.fds.api.xiaomi.com/productinfo/mi1c/voices/soundpackage.json"
    };
    global.Const = {
        fontFamily: "",
        loadingTimeOut: 20000,
        status: new _StatusUtil2.default(),
        onePixel: 1 / _reactNative.PixelRatio.get(),
        minTextSpacing: 5.5,
        MAP_EDIT_TYPE_NULL: 0,
        MAP_EDIT_TYPE_SPOT: 1,
        MAP_EDIT_TYPE_AREA: 2
    };
    _miot.Package.disableAutoCheckUpgrade = true;

    _miot.Service.getServerName().then(function (res) {
        console.log("countryinfo:", res);
        var countryCode = res.countryCode.toUpperCase();
        var licenseType = 0;

        switch (countryCode) {
            case "HK":
                global.Const.license = _require(_dependencyMap[6]);
                global.Const.policy = _require(_dependencyMap[7]);
                break;

            case "TW":
                global.Const.license = _require(_dependencyMap[8]);
                global.Const.policy = _require(_dependencyMap[9]);
                break;

            case "IL":
                global.Const.license = _require(_dependencyMap[10]);
                global.Const.policy = _require(_dependencyMap[11]);
                break;

            case "TR":
                global.Const.license = _require(_dependencyMap[12]);
                global.Const.policy = _require(_dependencyMap[13]);
                break;

            case "TH":
                global.Const.license = _require(_dependencyMap[14]);
                global.Const.policy = _require(_dependencyMap[15]);
                break;

            case "VN":
                global.Const.license = _require(_dependencyMap[16]);
                global.Const.policy = _require(_dependencyMap[17]);
                break;

            case "MM":
                global.Const.license = _require(_dependencyMap[18]);
                global.Const.policy = _require(_dependencyMap[19]);
                break;

            case "ID":
                global.Const.license = _require(_dependencyMap[20]);
                global.Const.policy = _require(_dependencyMap[21]);
                break;

            case "JP":
                global.Const.license = _require(_dependencyMap[22]);
                global.Const.policy = _require(_dependencyMap[23]);
                break;

            case "AE":
                global.Const.license = _require(_dependencyMap[24]);
                global.Const.policy = _require(_dependencyMap[25]);
                break;

            case "SA":
                global.Const.license = _require(_dependencyMap[26]);
                global.Const.policy = _require(_dependencyMap[27]);
                break;

            case "QA":
                global.Const.license = _require(_dependencyMap[26]);
                global.Const.policy = _require(_dependencyMap[27]);
                break;

            case "OM":
                global.Const.license = _require(_dependencyMap[26]);
                global.Const.policy = _require(_dependencyMap[27]);
                break;

            case "IQ":
                global.Const.license = _require(_dependencyMap[24]);
                global.Const.policy = _require(_dependencyMap[25]);
                break;

            case "SG":
                global.Const.license = _require(_dependencyMap[28]);
                global.Const.policy = _require(_dependencyMap[29]);
                break;

            case "PH":
                global.Const.license = _require(_dependencyMap[28]);
                global.Const.policy = _require(_dependencyMap[29]);
                break;

            case "NZ":
                global.Const.license = _require(_dependencyMap[28]);
                global.Const.policy = _require(_dependencyMap[29]);
                break;

            case "PK":
                global.Const.license = _require(_dependencyMap[28]);
                global.Const.policy = _require(_dependencyMap[29]);
                break;

            case "ES":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[30]);
                global.Const.policy = _require(_dependencyMap[31]);
                break;

            case "DE":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[32]);
                global.Const.policy = _require(_dependencyMap[33]);
                break;

            case "FR":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[34]);
                global.Const.policy = _require(_dependencyMap[35]);
                break;

            case "GB":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[36]);
                global.Const.policy = _require(_dependencyMap[37]);
                break;

            case "IT":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[38]);
                global.Const.policy = _require(_dependencyMap[39]);
                break;

            case "PL":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[40]);
                global.Const.policy = _require(_dependencyMap[41]);
                break;

            case "CZ":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[42]);
                global.Const.policy = _require(_dependencyMap[43]);
                break;

            case "CH":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[44]);
                global.Const.policy = _require(_dependencyMap[45]);
                break;

            case "UA":
                global.Const.license = _require(_dependencyMap[46]);
                global.Const.policy = _require(_dependencyMap[47]);
                break;

            case "PT":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[48]);
                global.Const.policy = _require(_dependencyMap[49]);
                break;

            case "AT":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[32]);
                global.Const.policy = _require(_dependencyMap[33]);
                break;

            case "RO":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[50]);
                global.Const.policy = _require(_dependencyMap[51]);
                break;

            case "SK":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[52]);
                global.Const.policy = _require(_dependencyMap[53]);
                break;

            case "GR":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[54]);
                global.Const.policy = _require(_dependencyMap[55]);
                break;

            case "BG":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[56]);
                global.Const.policy = _require(_dependencyMap[57]);
                break;

            case "SI":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[58]);
                global.Const.policy = _require(_dependencyMap[59]);
                break;

            case "HU":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[60]);
                global.Const.policy = _require(_dependencyMap[61]);
                break;

            case "LT":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[62]);
                global.Const.policy = _require(_dependencyMap[63]);
                break;

            case "EE":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[64]);
                global.Const.policy = _require(_dependencyMap[65]);
                break;

            case "LV":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[66]);
                global.Const.policy = _require(_dependencyMap[67]);
                break;

            case "FI":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[68]);
                global.Const.policy = _require(_dependencyMap[69]);
                break;

            case "DK":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[70]);
                global.Const.policy = _require(_dependencyMap[71]);
                break;

            case "SE":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[72]);
                global.Const.policy = _require(_dependencyMap[73]);
                break;

            case "NO":
                licenseType = 1;
                global.Const.license = _require(_dependencyMap[74]);
                global.Const.policy = _require(_dependencyMap[75]);
                break;

            case "BY":
                global.Const.license = _require(_dependencyMap[76]);
                global.Const.policy = _require(_dependencyMap[77]);
                break;

            case "RU":
                global.Const.license = _require(_dependencyMap[78]);
                global.Const.policy = _require(_dependencyMap[79]);
                break;

            case "BR":
                global.Const.license = _require(_dependencyMap[80]);
                global.Const.policy = _require(_dependencyMap[81]);
                break;

            case "PE":
                global.Const.license = _require(_dependencyMap[82]);
                global.Const.policy = _require(_dependencyMap[83]);
                break;

            case "CL":
                global.Const.license = _require(_dependencyMap[82]);
                global.Const.policy = _require(_dependencyMap[83]);
                break;

            case "MY":
                global.Const.license = _require(_dependencyMap[84]);
                global.Const.policy = _require(_dependencyMap[85]);
                break;

            case "CN":
                global.Const.license = _require(_dependencyMap[86]);
                global.Const.policy = _require(_dependencyMap[87]);
                break;

            case "KR":
                licenseType = 2;
                global.Const.license = _require(_dependencyMap[88]);
                global.Const.policy = _require(_dependencyMap[89]);
                break;

            default:
                global.Const.license = _require(_dependencyMap[28]);
                global.Const.policy = _require(_dependencyMap[29]);
                break;
        }

        if (res.serverCode != "cn") {
            if (_miot.Host.locale.language == "en") {
                if (licenseType == 0) {
                    global.Const.license = _require(_dependencyMap[28]);
                    global.Const.policy = _require(_dependencyMap[29]);
                } else if (licenseType == 1) {
                    global.Const.license = _require(_dependencyMap[36]);
                    global.Const.policy = _require(_dependencyMap[37]);
                } else if (licenseType == 2) {
                    global.Const.license = _require(_dependencyMap[90]);
                    global.Const.policy = _require(_dependencyMap[91]);
                }
            }
        } else {
            if (_miot.Host.locale.language == "en") {
                global.Const.license = _require(_dependencyMap[92]);
                global.Const.policy = _require(_dependencyMap[93]);
            }
        }

        if (res.serverCode == "cn") {
            global.gData.voiceUrl = "http:/xxx.xxx.xxx.xxx:4000/soundpackage.json";
        } else if (res.serverCode == "sg") {
            global.gData.voiceUrl = "http:/xxx.xxx.xxx.xxx:4000/soundpackage.json";
        } else if (res.serverCode == "de") {
            global.gData.voiceUrl = "http:/xxx.xxx.xxx.xxx:4000/soundpackage.json";
        } else if (res.serverCode == "ru") {
            global.gData.voiceUrl = "http:/xxx.xxx.xxx.xxx:4000/soundpackage.json";
        } else if (res.serverCode == "us") {
            global.gData.voiceUrl = "http:/xxx.xxx.xxx.xxx:4000/soundpackage.json";
        }
    }).catch(function (e) {});

    global.mapDataUtil = new _MapDataUtil2.default();

    switch (_miot.Package.entrance) {
        case _miot.Entrance.Main:
            _miot.Package.entry(_main2.default, function (_) {});

            break;

        default:
            break;
    }
},10001,[10297,10074,10033,10004,10115,10583,10586,10589,10592,10595,10598,10601,10604,10607,10610,10613,10616,10619,10622,10625,10628,10631,10634,10637,10640,10643,10646,10649,10652,10655,10658,10661,10664,10667,10670,10673,10676,10679,10682,10685,10688,10691,10694,10697,10700,10703,10706,10709,10712,10715,10718,10721,10724,10727,10730,10733,10736,10739,10742,10745,10748,10751,10754,10757,10760,10763,10766,10769,10772,10775,10778,10781,10784,10787,10790,10793,10796,10799,10802,10805,10808,10811,10814,10817,10820,10823,10826,10829,10832,10835,10838,10841,10844,10847],"projects/com.dreame.devices/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _buffer = _require(_dependencyMap[0]);

    var _rnPng = _require(_dependencyMap[1]);

    var _rnPng2 = babelHelpers.interopRequireDefault(_rnPng);

    var _pako = _require(_dependencyMap[2]);

    var _pako2 = babelHelpers.interopRequireDefault(_pako);

    var _base64Js = _require(_dependencyMap[3]);

    var _base64Js2 = babelHelpers.interopRequireDefault(_base64Js);

    var colors = [[0x83, 0xb2, 0xff, 0xff], [0xff, 0x9b, 0x65, 0xff], [0xf5, 0xc9, 0x42, 0xff], [0x67, 0xcf, 0xe5, 0xff], [0xb9, 0x86, 0xed, 0xff], [0xf5, 0x6b, 0x75, 0xff], [0x71, 0xd0, 0x6a, 0xff], [0xd3, 0xf1, 0x49, 0xff]];
    var selectColors = [[0x69, 0x8e, 0xcc, 0xff], [0xcc, 0x7c, 0x51, 0xff], [0xc4, 0xa1, 0x35, 0xff], [0x52, 0xa6, 0xb7, 0xff], [0x94, 0x6b, 0xbe, 0xff], [0xc4, 0x56, 0x5e, 0xff], [0x5a, 0xa6, 0x55, 0xff], [0xa9, 0xc1, 0x3a, 0xff]];
    var colorStrings = ["#83b2ff", "#ff9b65", "#f5c942", "#67cfe5", "#b986ed", "#f56b75", "#71d06a", "#d3f149"];

    var MapDataUtil = function () {
        function MapDataUtil() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            babelHelpers.classCallCheck(this, MapDataUtil);
            this.robotPos = {};
            this.chargerPos = {};
            this.gridWidth = 100;
            this.traces = [];
            this.mapData = {
                map: {}
            };
            this.tmpMap = {};
            this.isDecode = false;
        }

        babelHelpers.createClass(MapDataUtil, [{
            key: "setMapData",
            value: function setMapData(mapDataStr, isLog) {
                if (!mapDataStr) {
                    return;
                }

                mapDataStr = mapDataStr.replace(/-/g, "+");
                mapDataStr = mapDataStr.replace(/_/g, "/");

                var buffer = _buffer.Buffer.from(mapDataStr, 'base64');

                if (!buffer || buffer.length == 0) {
                    return;
                }

                try {
                    var unZipArrayBuffer = _pako2.default.inflate(buffer);

                    var unZipBuffer = _buffer.Buffer.from(unZipArrayBuffer);

                    var map_id = unZipBuffer.readInt16LE(0);

                    if (isLog == true) {
                        map_id = -1;
                    }

                    var frame_id = unZipBuffer.readInt16LE(2);
                    var frame_type = unZipBuffer.readInt8(4);
                    var robotPos = {};
                    robotPos.x = unZipBuffer.readInt16LE(5);
                    robotPos.y = unZipBuffer.readInt16LE(7);
                    robotPos.angle = unZipBuffer.readInt16LE(9);
                    this.chargerPos.x = unZipBuffer.readInt16LE(11);
                    this.chargerPos.y = unZipBuffer.readInt16LE(13);
                    this.chargerPos.angle = unZipBuffer.readInt16LE(15);
                    this.gridWidth = unZipBuffer.readInt16LE(17);
                    var iwidth = unZipBuffer.readInt16LE(19);
                    var iHeight = unZipBuffer.readInt16LE(21);

                    var _x = unZipBuffer.readInt16LE(23);

                    var _y = unZipBuffer.readInt16LE(25);

                    var timestamp = undefined;
                    console.log(Date.now(), map_id, frame_id, frame_type, robotPos, this.chargerPos, this.gridWidth, iwidth, iHeight, _x, _y, unZipBuffer.length);

                    if (this.OnMapInfoListener) {
                        this.OnMapInfoListener({
                            frame_id: frame_id,
                            frame_type: frame_type,
                            dataIntegrity: unZipBuffer.length >= 27 + iwidth * iHeight
                        });
                    }

                    if (unZipBuffer.length > 27 + iwidth * iHeight) {
                        var expandDatas = _buffer.Buffer.alloc(unZipBuffer.length - 27 - iwidth * iHeight, 0);

                        for (var i = 0; i < expandDatas.length; i++) {
                            expandDatas[i] = unZipBuffer[i + 27 + iwidth * iHeight];
                        }

                        try {
                            var expandData = new String(expandDatas).toString();
                            var expands = JSON.parse(expandData);
                            timestamp = expands.timestamp_ms;
                            console.log("expands:", expands);
                        } catch (e) {}
                    }

                    var isNew = false;

                    if (this.isDecode) {
                        console.log("----------isDecode:", frame_id);
                        this.tmpMap[frame_id] = mapDataStr;
                        return;
                    }

                    this.isDecode = true;

                    if (this.mapData) {
                        if (this.mapData.mapid != map_id) {
                            this.mapData = undefined;
                        }
                    }

                    if (this.mapData) {
                        if (frame_id <= this.mapData.lastFrameId) {
                            this.isDecode = false;
                            return;
                        }
                    }

                    if (frame_type == 80) {
                        if (!this.mapData) {
                            this.tmpMap[frame_id] = mapDataStr;
                            console.log("----------数据丢失，重新获取1-----------");

                            if (this.onErrListener) {
                                this.onErrListener(1);
                            }

                            this.isDecode = false;
                            return;
                        }

                        if (frame_id != this.mapData.lastFrameId + 1) {
                            this.tmpMap[frame_id] = mapDataStr;

                            var _keys = Object.keys(this.tmpMap);

                            for (var _i2 in _keys) {
                                var k = _keys[_i2];

                                if (parseInt(k) <= this.mapData.lastFrameId) {
                                    delete this.tmpMap[k];
                                }
                            }

                            _keys = Object.keys(this.tmpMap);

                            if (_keys.length > 0) {
                                console.log("----------数据丢失，重新获取2-----------", _keys, this.mapData.lastFrameId, JSON.stringify(this.tmpMap));

                                if (this.onErrListener) {
                                    if (frame_id - this.mapData.lastFrameId > 5) {
                                        this.onErrListener(1);
                                    } else {
                                        this.onErrListener(2, {
                                            mapid: this.mapData.mapid,
                                            frameid: this.mapData.lastFrameId + 1
                                        });
                                    }
                                }
                            }

                            this.isDecode = false;
                            return;
                        }
                    } else if (frame_type == 73) {
                        var _keys2 = Object.keys(this.tmpMap);

                        for (var _i3 in _keys2) {
                            var _k = _keys2[_i3];

                            if (parseInt(_k) <= frame_id) {
                                delete this.tmpMap[_k];
                            }
                        }
                    }

                    var hasPosChange = false;

                    if (this.robotPos.x !== robotPos.x || this.robotPos.y != robotPos.y || this.robotPos.angel != robotPos.angel) {
                        this.robotPos = robotPos;
                        hasPosChange = true;
                    }

                    if (iwidth == 0 || iHeight == 0) {
                        if (this.mapData && this.mapData.info) {
                            this.mapData.lastFrameId = frame_id;
                            this.traces.push({
                                x: this.robotPos.x,
                                y: this.robotPos.y
                            });
                        }

                        var _keys3 = Object.keys(this.tmpMap);

                        if (_keys3.length > 0) {
                            if (this.tmpMap[frame_id + 1]) {
                                var mapData = this.tmpMap[frame_id + 1];
                                delete this.tmpMap[frame_id + 1];
                                this.isDecode = false;
                                return this.setMapData(mapData);
                            }
                        }

                        if (this.onMapChangeListener && hasPosChange == true) {
                            this.onMapChangeListener();
                        }

                        this.isDecode = false;
                        return;
                    }

                    var mapInfo = _buffer.Buffer.alloc(iwidth * iHeight, 0);

                    if (unZipBuffer.length < 27 + iwidth * iHeight) {
                        console.log("map data is missing");
                        this.isDecode = false;
                        return;
                    }

                    for (var _i4 = 0; _i4 < mapInfo.length; _i4++) {
                        mapInfo[_i4] = unZipBuffer[_i4 + 27];
                    }

                    var cMinX = _x;
                    var cMinY = _y;
                    var cMaxX = _x + iwidth * this.gridWidth;
                    var cMaxY = _y + iHeight * this.gridWidth;

                    if (frame_type == 73) {
                        isNew = true;
                        this.mapData = {
                            mapid: map_id,
                            lastFrameId: frame_id,
                            info: {
                                minX: cMinX,
                                minY: cMinY,
                                maxX: cMaxX,
                                maxY: cMaxY
                            },
                            map: {},
                            cleanMap: {
                                x: _x,
                                y: _y,
                                width: iwidth,
                                height: iHeight,
                                mapInfo: mapInfo
                            }
                        };
                    } else {
                        var lastMap = this.mapData.cleanMap;

                        if (cMinX < this.mapData.info.minX) {
                            this.mapData.info.minX = cMinX;
                        }

                        if (cMinY < this.mapData.info.minY) {
                            this.mapData.info.minY = cMinY;
                        }

                        if (cMaxX > this.mapData.info.maxX) {
                            this.mapData.info.maxX = cMaxX;
                        }

                        if (cMaxY > this.mapData.info.maxY) {
                            this.mapData.info.maxY = cMaxY;
                        }

                        this.mapData.lastFrameId = frame_id;
                        var nWidth = (this.mapData.info.maxX - this.mapData.info.minX) / this.gridWidth;
                        var nHeight = (this.mapData.info.maxY - this.mapData.info.minY) / this.gridWidth;

                        var nMapInfo = _buffer.Buffer.alloc(nWidth * nHeight);

                        var sX = (lastMap.x - this.mapData.info.minX) / this.gridWidth;
                        var sY = (lastMap.y - this.mapData.info.minY) / this.gridWidth;

                        for (var j = 0; j < lastMap.height; j++) {
                            for (var _i5 = 0; _i5 < lastMap.width; _i5++) {
                                var index = j * lastMap.width + _i5;
                                var value = lastMap.mapInfo[index];
                                var nX = sX + _i5;
                                var nY = sY + j;
                                var nIndex = nY * nWidth + nX;
                                nMapInfo[nIndex] = value;
                            }
                        }

                        sX = (_x - this.mapData.info.minX) / this.gridWidth;
                        sY = (_y - this.mapData.info.minY) / this.gridWidth;

                        for (var _j2 = 0; _j2 < iHeight; _j2++) {
                            for (var _i6 = 0; _i6 < iwidth; _i6++) {
                                var _index = _j2 * iwidth + _i6;

                                var _value = mapInfo[_index];

                                var _nX = sX + _i6;

                                var _nY = sY + _j2;

                                var _nIndex = _nY * nWidth + _nX;

                                nMapInfo[_nIndex] = nMapInfo[_nIndex] + _value;
                            }
                        }

                        this.mapData.cleanMap = {
                            x: this.mapData.info.minX,
                            y: this.mapData.info.minY,
                            width: nWidth,
                            height: nHeight,
                            mapInfo: nMapInfo
                        };
                    }

                    if (timestamp) {
                        this.timestamp = timestamp;
                    }

                    this.traces.push({
                        x: this.robotPos.x,
                        y: this.robotPos.y
                    });
                    var keys = Object.keys(this.tmpMap);

                    if (keys.length > 0) {
                        if (this.tmpMap[frame_id + 1]) {
                            var _mapData = this.tmpMap[frame_id + 1];
                            delete this.tmpMap[frame_id + 1];
                            this.isDecode = false;
                            return this.setMapData(_mapData);
                        }
                    }

                    if (this.onMapChangeListener) {
                        this.onMapChangeListener(isNew);
                    }

                    this.isDecode = false;
                } catch (e) {
                    this.isDecode = false;
                    console.log("can't decode buffer", e, mapDataStr);
                }
            }
        }, {
            key: "setPMaps",
            value: function setPMaps(fristMap, otherMaps) {
                for (var key in otherMaps) {
                    this.tmpMap[key] = otherMaps[key];
                }

                this.setMapData(fristMap);
            }
        }, {
            key: "decodeMapData",
            value: function decodeMapData(mapDataStr) {
                if (!mapDataStr) {
                    return null;
                }

                mapDataStr = mapDataStr.replace(/-/g, "+");
                mapDataStr = mapDataStr.replace(/_/g, "/");

                var buffer = _buffer.Buffer.from(mapDataStr, 'base64');

                if (!buffer || buffer.length == 0) {
                    return null;
                }

                try {
                    var unZipArrayBuffer = _pako2.default.inflate(buffer);

                    var unZipBuffer = _buffer.Buffer.from(unZipArrayBuffer);

                    var map_id = unZipBuffer.readInt16LE(0);
                    var frame_id = unZipBuffer.readInt16LE(2);
                    var frame_type = unZipBuffer.readInt8(4);
                    return {
                        map_id: map_id,
                        frame_id: frame_id,
                        frame_type: frame_type
                    };
                } catch (e) {
                    return null;
                }
            }
        }, {
            key: "hasLastTimestamp",
            value: function hasLastTimestamp() {
                return this.timestamp != undefined;
            }
        }, {
            key: "getLastTimestamp",
            value: function getLastTimestamp() {
                if (this.mapData && this.mapData.mapid >= 0 && this.timestamp > 7200000) {
                    return {
                        map_id: this.mapData.mapid,
                        frame_id: this.mapData.lastFrameId,
                        timestamp: this.timestamp
                    };
                }

                return null;
            }
        }, {
            key: "getCleanMapInfo",
            value: function getCleanMapInfo() {
                if (!this.mapData || !this.mapData.cleanMap || !this.mapData.info) {
                    return null;
                }

                var map = this.mapData.cleanMap;
                var pngWidth = this.mapData.cleanMap.width;
                var pngHeight = this.mapData.cleanMap.height;
                var mapInfo = [];

                for (var i = 0; i < map.mapInfo.length; i++) {
                    mapInfo[i] = map.mapInfo[i];
                }

                return {
                    width: pngWidth,
                    height: pngHeight,
                    mapData: mapInfo,
                    robotPos: this.robotPos,
                    chargePos: this.chargerPos,
                    gridWidth: this.gridWidth,
                    mapInfo: this.mapData.info
                };
            }
        }, {
            key: "getCleanMap",
            value: function getCleanMap() {
                if (!this.mapData || !this.mapData.cleanMap || !this.mapData.info.maxX) {
                    return null;
                }

                var map = this.mapData.cleanMap;
                var pngWidth = this.mapData.cleanMap.width;
                var pngHeight = this.mapData.cleanMap.height;

                var mapInfo = _buffer.Buffer.alloc(map.mapInfo.length, 0);

                for (var i = 0; i < mapInfo.length; i++) {
                    mapInfo[i] = map.mapInfo[i];
                }

                var Optimize = _require(_dependencyMap[4]);

                var obj = new Optimize(mapInfo, pngWidth, pngHeight);

                if (!obj) {
                    return null;
                }

                pngHeight = obj.picH;
                pngWidth = obj.picW;
                mapInfo = obj.mapInfo;
                var Multiple = obj.Multiple;
                var png = new _rnPng2.default({
                    width: pngWidth,
                    height: pngHeight,
                    zlibLib: _pako2.default,
                    colorType: 6
                });

                for (var j = 0; j < pngHeight; j++) {
                    for (var _i7 = 0; _i7 < pngWidth; _i7++) {
                        var index = j * pngWidth + _i7;
                        var value = mapInfo[index];
                        var pngX = _i7;
                        var pngY = pngHeight - 1 - j;

                        if (value == 1) {
                            png.setPixelAt([pngX, pngY], [131, 178, 255, 255]);
                        } else if (value == 2) {
                            png.setPixelAt([pngX, pngY], [110, 110, 110, 255]);
                        } else if (value == 3) {
                            png.setPixelAt([pngX, pngY], [0xbe, 0xd4, 0xf5, 255]);
                        } else if (value == 0) {} else if (value == 6) {
                            png.setPixelAt([pngX, pngY], [110, 110, 110, 255]);
                        } else {
                            png.setPixelAt([pngX, pngY], [131, 178, 255, 255]);
                        }
                    }
                }

                var base64ImageData = _base64Js2.default.fromByteArray(png.getBuffer());

                return {
                    data: base64ImageData,
                    width: pngWidth,
                    height: pngHeight,
                    robotPos: this.robotPos,
                    chargePos: this.chargerPos,
                    gridWidth: this.gridWidth / Multiple,
                    mapInfo: this.mapData.info,
                    traces: this.traces
                };
            }
        }, {
            key: "clearSmallObstacle",
            value: function clearSmallObstacle(mapInfo, picW, picH, obstacleValue) {
                for (var i = 0; i < picW; i++) {
                    var startY = -1;

                    for (var j = 0; j < picH; j++) {
                        var index = j * picW + i;

                        if (mapInfo[index] == obstacleValue) {
                            if (startY < 0) {
                                startY = j;
                            }

                            continue;
                        }

                        if (startY != -1 && j - startY <= 3) {
                            for (var k = startY; k < j; k++) {
                                mapInfo[k * picW + i] = 1;
                            }
                        }

                        startY = -1;
                    }
                }

                for (var _j3 = 0; _j3 < picH; _j3++) {
                    var startX = -1;

                    for (var _i8 = 0; _i8 < picW; _i8++) {
                        var _index2 = _j3 * picW + _i8;

                        if (mapInfo[_index2] == obstacleValue) {
                            if (startX < 0) {
                                startX = _i8;
                            }

                            continue;
                        }

                        if (startX != -1 && _i8 - startX <= 3) {
                            for (var _k2 = startX; _k2 < _i8; _k2++) {
                                mapInfo[_j3 * picW + _k2] = 1;
                            }
                        }

                        startX = -1;
                    }
                }
            }
        }, {
            key: "updateBorderValue",
            value: function updateBorderValue(mapInfo, picW, picH, strokeValue) {
                for (var j = 0; j < picH; j++) {
                    for (var i = 0; i < picW; i++) {
                        var index = j * picW + i;

                        if (mapInfo[index] != 0) {
                            if (j == 0 || j == picH - 1 || i == 0 || i == picW - 1) {
                                mapInfo[index] = strokeValue;
                            }

                            var hasFind = false;

                            for (var _i = i - 1; _i <= i + 1; _i++) {
                                for (var _j = j - 1; _j <= j + 1; _j++) {
                                    var nIndex = _j * picW + _i;

                                    if (mapInfo[nIndex] == 0) {
                                        hasFind = true;
                                        break;
                                    }
                                }

                                if (hasFind) {
                                    break;
                                }
                            }

                            if (hasFind) {
                                mapInfo[index] = strokeValue;
                            }
                        }
                    }
                }
            }
        }, {
            key: "findOutLine",
            value: function findOutLine(mapInfo, picW, picH, strokeValue) {
                var horizontalLines = [];
                var verticalLines = [];

                for (var i = 0; i < picW; i++) {
                    var startY = -1;

                    for (var j = 0; j < picH; j++) {
                        var index = j * picW + i;
                        var lastY = j - 1;

                        if (mapInfo[index] == strokeValue && j != picH - 1) {
                            var isCross = false;

                            if (i != 0 && mapInfo[index - 1] == strokeValue || i != picW - 1 && mapInfo[index + 1] == strokeValue) {
                                isCross = true;
                            }

                            if (startY < 0 && isCross) {
                                startY = j;
                                continue;
                            }

                            if (!isCross) {
                                continue;
                            }

                            lastY = j;
                        }

                        if (startY >= 0) {
                            if (j == picH - 1 && mapInfo[index] == strokeValue) {
                                lastY = j;
                            }

                            if (lastY == startY) {
                                startY = -1;
                                continue;
                            }

                            var _isCross = false;
                            var lastIndex = lastY * picW + i;

                            if (mapInfo[lastIndex - 1] == strokeValue || mapInfo[lastIndex + 1] == strokeValue) {
                                _isCross = true;
                            }

                            if (_isCross) {
                                var line = {
                                    x: i,
                                    y: [startY, lastY],
                                    ishorizontal: false,
                                    length: lastY - startY
                                };
                                verticalLines.push(line);
                                startY = lastY;
                                continue;
                            }
                        }

                        startY = -1;
                    }
                }

                for (var _j4 = 0; _j4 < picH; _j4++) {
                    var startX = -1;

                    for (var _i9 = 0; _i9 < picW; _i9++) {
                        var _index3 = _j4 * picW + _i9;

                        var lastX = _i9 - 1;

                        if (mapInfo[_index3] == strokeValue && _i9 != picW - 1) {
                            var _isCross2 = false;

                            if (mapInfo[_index3 - picW] == strokeValue || mapInfo[_index3 + picW] == strokeValue) {
                                _isCross2 = true;
                            }

                            if (startX < 0 && _isCross2) {
                                startX = _i9;
                                continue;
                            }

                            if (!_isCross2) {
                                continue;
                            }

                            lastX = _i9;
                        }

                        if (startX >= 0) {
                            if (mapInfo[_index3] == strokeValue && _i9 == picW - 1) {
                                lastX = _i9;
                            }

                            if (lastX == startX) {
                                startX = -1;
                                continue;
                            }

                            var _isCross3 = false;

                            var _lastIndex = _j4 * picW + lastX;

                            if (mapInfo[_lastIndex - picW] == strokeValue || mapInfo[_lastIndex + picW] == strokeValue) {
                                _isCross3 = true;
                            }

                            if (_isCross3) {
                                var _line = {
                                    x: [startX, lastX],
                                    y: _j4,
                                    ishorizontal: true,
                                    length: lastX - startX
                                };
                                horizontalLines.push(_line);
                                startX = lastX;
                                continue;
                            }
                        }

                        startX = -1;
                    }
                }

                if (horizontalLines.length == 0) {
                    return false;
                }

                var startLine = horizontalLines[0];
                startLine.findEnd = true;
                var covertlines = [];
                var allLines = [];

                function addLine(line) {
                    var aLine = {
                        p0: {},
                        p1: {}
                    };

                    if (line.ishorizontal) {
                        aLine.p0.y = line.y;
                        aLine.p1.y = line.y;

                        if (line.findEnd) {
                            aLine.p0.x = line.x[0];
                            aLine.p1.x = line.x[1];
                        } else {
                            aLine.p0.x = line.x[1];
                            aLine.p1.x = line.x[0];
                        }

                        aLine.length = Math.abs(line.x[1] - line.x[0]);
                    } else {
                        aLine.p0.x = line.x;
                        aLine.p1.x = line.x;
                        aLine.length = Math.abs(line.y[1] - line.y[0]);

                        if (line.findEnd) {
                            aLine.p0.y = line.y[0];
                            aLine.p1.y = line.y[1];
                        } else {
                            aLine.p0.y = line.y[1];
                            aLine.p1.y = line.y[0];
                        }
                    }

                    covertlines.push(aLine);
                    allLines.push(line);
                }

                addLine(startLine);

                while (true) {
                    var lastLine = allLines[allLines.length - 1];

                    if (lastLine.ishorizontal) {
                        var hasFind = false;

                        for (var _i10 = 0; _i10 < verticalLines.length; _i10++) {
                            var vLine = verticalLines[_i10];

                            if (vLine == undefined) {
                                continue;
                            }

                            var x = lastLine.x[0];

                            if (lastLine.findEnd) {
                                x = lastLine.x[1];
                            }

                            if (x == vLine.x) {
                                if (lastLine.y == vLine.y[0]) {
                                    vLine.findEnd = true;
                                    addLine(vLine);
                                    delete verticalLines[_i10];
                                    hasFind = true;
                                    break;
                                } else if (lastLine.y == vLine.y[1]) {
                                    vLine.findEnd = false;
                                    addLine(vLine);
                                    delete verticalLines[_i10];
                                    hasFind = true;
                                    break;
                                } else if (lastLine.y > vLine.y[0] && lastLine.y < vLine.y[1]) {
                                    if (lastLine.findEnd) {
                                        if (mapInfo[(lastLine.y + 1) * picW + x - 1] == 0) {
                                            vLine.y[1] = lastLine.y;
                                            vLine.findEnd = false;
                                        } else {
                                            vLine.y[0] = lastLine.y;
                                            vLine.findEnd = true;
                                        }
                                    } else {
                                        if (mapInfo[(lastLine.y + 1) * picW + x + 1] == 0) {
                                            vLine.y[1] = lastLine.y;
                                            vLine.findEnd = false;
                                        } else {
                                            vLine.y[0] = lastLine.y;
                                            vLine.findEnd = true;
                                        }
                                    }

                                    addLine(vLine);
                                    delete verticalLines[_i10];
                                    hasFind = true;
                                    break;
                                }
                            }
                        }

                        if (!hasFind) {
                            break;
                        }
                    } else {
                        var _hasFind = false;
                        var _y = lastLine.y[0];

                        if (lastLine.findEnd) {
                            _y = lastLine.y[1];
                        }

                        if (_y == startLine.y && lastLine.x == startLine.x[0]) {
                            break;
                        }

                        for (var _i11 = 0; _i11 < horizontalLines.length; _i11++) {
                            var hLine = horizontalLines[_i11];

                            if (!hLine) {
                                continue;
                            }

                            var y = lastLine.y[0];

                            if (lastLine.findEnd) {
                                y = lastLine.y[1];
                            }

                            if (y == hLine.y) {
                                if (lastLine.x == hLine.x[0]) {
                                    hLine.findEnd = true;
                                    addLine(hLine);
                                    delete horizontalLines[_i11];
                                    _hasFind = true;
                                    break;
                                } else if (lastLine.x == hLine.x[1]) {
                                    hLine.findEnd = false;
                                    addLine(hLine);
                                    delete horizontalLines[_i11];
                                    _hasFind = true;
                                    break;
                                } else if (lastLine.x > hLine.x[0] && lastLine.x < hLine.x[1]) {
                                    if (lastLine.findEnd) {
                                        if (mapInfo[(y - 1) * picW + lastLine.x - 1] == 0) {
                                            hLine.x[0] = lastLine.x;
                                            hLine.findEnd = true;
                                        } else {
                                            hLine.x[1] = lastLine.x;
                                            hLine.findEnd = false;
                                        }
                                    } else {
                                        if (mapInfo[(y + 1) * picW + lastLine.x - 1] == 0) {
                                            hLine.x[0] = lastLine.x;
                                            hLine.findEnd = true;
                                        } else {
                                            hLine.x[1] = lastLine.x;
                                            hLine.findEnd = false;
                                        }
                                    }

                                    addLine(hLine);
                                    delete horizontalLines[_i11];
                                    _hasFind = true;
                                    break;
                                }
                            }
                        }

                        if (!_hasFind) {
                            break;
                        }
                    }
                }

                var bottom = 5;
                var right = 6;
                var top = 7;
                var left = 8;
                var dirnone = 0;
                var angel = {
                    lines: [],
                    horizontalDir: dirnone,
                    verticalDir: dirnone
                };

                function fillAngle(angel) {
                    var l1 = angel.lines[0];
                    var l2 = angel.lines[angel.lines.length - 1];

                    if (angel.lines.length == 2) {
                        var _nextAngle = {
                            lines: [],
                            horizontalDir: dirnone,
                            verticalDir: dirnone
                        };

                        _nextAngle.lines.push(l2);

                        if (l2.ishorizontal) {
                            _nextAngle.horizontalDir = l2.findEnd ? right : left;
                        } else {
                            _nextAngle.verticalDir = l2.findEnd ? top : bottom;
                        }

                        return _nextAngle;
                    }

                    var minx = void 0,
                        miny = void 0,
                        maxx = void 0,
                        maxy = void 0;

                    if (l1.ishorizontal) {
                        if (angel.horizontalDir == right) {
                            minx = l1.x[1];
                        } else {
                            maxx = l1.x[0];
                        }

                        if (angel.verticalDir == top) {
                            miny = l1.y;
                        } else {
                            maxy = l1.y;
                        }

                        if (l2.ishorizontal) {
                            if (angel.horizontalDir == right) {
                                maxx = l2.x[0];
                            } else {
                                minx = l2.x[1];
                            }

                            if (angel.verticalDir == top) {
                                maxy = l2.y;
                            } else {
                                miny = l2.y;
                            }
                        } else {
                            if (angel.horizontalDir == right) {
                                maxx = l2.x;
                            } else {
                                minx = l2.x;
                            }

                            if (angel.verticalDir == top) {
                                maxy = l2.y[0];
                            } else {
                                miny = l2.y[1];
                            }
                        }
                    } else {
                        if (angel.verticalDir == top) {
                            miny = l1.y[1];
                        } else {
                            maxy = l1.y[0];
                        }

                        if (angel.horizontalDir == right) {
                            minx = l1.x;
                        } else {
                            maxx = l1.x;
                        }

                        if (l2.ishorizontal) {
                            if (angel.horizontalDir == right) {
                                maxx = l2.x[0];
                            } else {
                                minx = l2.x[1];
                            }

                            if (angel.verticalDir == top) {
                                maxy = l2.y;
                            } else {
                                miny = l2.y;
                            }
                        } else {
                            if (angel.horizontalDir == right) {
                                maxx = l2.x;
                            } else {
                                minx = l2.x;
                            }

                            if (angel.verticalDir == top) {
                                maxy = l2.y[0];
                            } else {
                                miny = l2.y[1];
                            }
                        }
                    }

                    if (minx == undefined || miny == undefined || maxx == undefined || maxy == undefined) {
                        var _nextAngle2 = {
                            lines: [],
                            horizontalDir: dirnone,
                            verticalDir: dirnone
                        };

                        _nextAngle2.lines.push(l2);

                        if (l2.ishorizontal) {
                            _nextAngle2.horizontalDir = l2.findEnd ? right : left;
                        } else {
                            _nextAngle2.verticalDir = l2.findEnd ? top : bottom;
                        }

                        return _nextAngle2;
                    }

                    if (l1.ishorizontal && l2.ishorizontal && maxy - miny <= 3) {
                        if (angel.horizontalDir == right) {
                            minx = l1.x[0];
                            maxx = l2.x[1];
                        } else {
                            minx = l2.x[0];
                            maxx = l1.x[1];
                        }
                    } else if (!l1.ishorizontal && !l2.ishorizontal && maxx - minx <= 3) {
                        if (angel.verticalDir == top) {
                            miny = l1.y[0];
                            maxy = l2.y[1];
                        } else {
                            miny = l2.y[0];
                            maxy = l1.y[1];
                        }
                    }

                    var num = 0;

                    for (var _i12 = minx; _i12 <= maxx; _i12++) {
                        for (var _j5 = miny; _j5 <= maxy; _j5++) {
                            var _index4 = _j5 * picW + _i12;

                            if (mapInfo[_index4] == 0) {
                                num++;
                            }
                        }
                    }

                    if (num < (maxx - minx + 1) * (maxy - miny + 1) / 2) {
                        for (var _i13 = minx; _i13 <= maxx; _i13++) {
                            for (var _j6 = miny; _j6 <= maxy; _j6++) {
                                var _index5 = _j6 * picW + _i13;

                                if (mapInfo[_index5] == 0) {
                                    mapInfo[_index5] = strokeValue;
                                }
                            }
                        }
                    }

                    var nextAngle = {
                        lines: [],
                        horizontalDir: dirnone,
                        verticalDir: dirnone
                    };
                    nextAngle.lines.push(l2);

                    if (l2.ishorizontal) {
                        nextAngle.horizontalDir = l2.findEnd ? right : left;
                    } else {
                        nextAngle.verticalDir = l2.findEnd ? top : bottom;
                    }

                    return nextAngle;
                }

                for (var _i14 = 0; _i14 <= allLines.length; _i14++) {
                    var _line2 = allLines[_i14];

                    if (_i14 == allLines.length) {
                        _line2 = allLines[0];
                    }

                    if (_i14 == 0) {
                        angel.lines.push(_line2);
                        angel.type = bottom;
                        angel.horizontalDir = right;
                    } else {
                        if (_line2.ishorizontal) {
                            var horizontalDir = _line2.findEnd ? right : left;

                            if (angel.horizontalDir != dirnone && angel.horizontalDir != horizontalDir) {
                                angel = fillAngle(angel);
                            }

                            if (angel.horizontalDir == dirnone) {
                                angel.horizontalDir = horizontalDir;
                            }

                            angel.lines.push(_line2);
                        } else {
                            var verticalDir = _line2.findEnd ? top : bottom;

                            if (angel.verticalDir != dirnone && angel.verticalDir != verticalDir) {
                                angel = fillAngle(angel);
                            }

                            if (angel.verticalDir == dirnone) {
                                angel.verticalDir = verticalDir;
                            }

                            angel.lines.push(_line2);
                        }

                        if (_line2.length > 7 || _i14 == allLines.length) {
                            angel = fillAngle(angel);
                        }
                    }
                }

                return true;
            }
        }, {
            key: "createBorder",
            value: function createBorder(mapInfo, picW, picH) {
                for (var i = 0; i < picW; i++) {
                    for (var j = 0; j < picH; j++) {
                        var index = j * picW + i;

                        if ((i == 0 || i == picW - 1 || j == 0 || j == picH - 1) && mapInfo[index] != 0) {
                            mapInfo[index] = 5;
                            continue;
                        }

                        if (mapInfo[index] != 0 && mapInfo[index] != 5) {
                            for (var ii = i - 1; ii < i + 2; ii++) {
                                for (var jj = j - 1; jj < j + 2; jj++) {
                                    if (ii == i && jj == j) {
                                        continue;
                                    }

                                    var nIndex = jj * picW + ii;

                                    if (mapInfo[nIndex] == 0) {
                                        mapInfo[nIndex] = 5;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }, {
            key: "clearBorder",
            value: function clearBorder(mapInfo) {
                for (var i = 0; i < mapInfo.length; i++) {
                    if (mapInfo[i] == 2) {
                        mapInfo[i] = 0;
                    }
                }
            }
        }, {
            key: "denoise",
            value: function denoise(mapInfo, picW, picH) {
                var tmpMapInfo = _buffer.Buffer.alloc(mapInfo.length, 0);

                for (var i = 0; i < mapInfo.length; i++) {
                    tmpMapInfo[i] = mapInfo[i];
                }

                var len = 20;

                for (var _i15 = 0; _i15 < picW; _i15++) {
                    var startY = -1;

                    for (var j = 0; j < picH; j++) {
                        var index = j * picW + _i15;

                        if (mapInfo[index] != 0) {
                            if (startY < 0) {
                                startY = j;
                            }

                            continue;
                        }

                        if (startY != -1 && j - startY <= len) {
                            var isBorder = false;

                            if (_i15 == 0 || _i15 == picW - 1 || j - startY <= 5) {
                                isBorder = true;
                            }

                            if (!isBorder) {
                                var _i = _i15 - 1;

                                isBorder = true;

                                for (var k = startY; k < j; k++) {
                                    if (tmpMapInfo[k * picW + _i] == 1) {
                                        isBorder = false;
                                        break;
                                    }
                                }
                            }

                            if (!isBorder) {
                                var _i16 = _i15 + 1;

                                isBorder = true;

                                for (var _k3 = startY; _k3 < j; _k3++) {
                                    if (tmpMapInfo[_k3 * picW + _i16] == 1) {
                                        isBorder = false;
                                        break;
                                    }
                                }
                            }

                            if (isBorder) {
                                for (var _k4 = startY; _k4 < j; _k4++) {
                                    mapInfo[_k4 * picW + _i15] = 0;
                                }
                            }
                        }

                        startY = -1;
                    }
                }

                for (var _j7 = 0; _j7 < picH; _j7++) {
                    var startX = -1;

                    for (var _i17 = 0; _i17 < picW; _i17++) {
                        var _index6 = _j7 * picW + _i17;

                        if (mapInfo[_index6] != 0) {
                            if (startX < 0) {
                                startX = _i17;
                            }

                            continue;
                        }

                        if (startX != -1 && _i17 - startX <= len) {
                            var _isBorder = false;

                            if (_j7 == 0 || _j7 == picH - 1 || _i17 - startX <= 5) {
                                _isBorder = true;
                            }

                            if (!_isBorder) {
                                var _j = _j7 - 1;

                                _isBorder = true;

                                for (var _k5 = startX; _k5 < _i17; _k5++) {
                                    if (tmpMapInfo[_j * picW + _k5] == 1) {
                                        _isBorder = false;
                                        break;
                                    }

                                    ;
                                }
                            }

                            if (!_isBorder) {
                                var _j8 = _j7 + 1;

                                _isBorder = true;

                                for (var _k6 = startX; _k6 < _i17; _k6++) {
                                    if (tmpMapInfo[_j8 * picW + _k6] == 1) {
                                        _isBorder = false;
                                        break;
                                    }

                                    ;
                                }
                            }

                            if (_isBorder) {
                                for (var _k7 = startX; _k7 < _i17; _k7++) {
                                    mapInfo[_j7 * picW + _k7] = 0;
                                }
                            }
                        }

                        startX = -1;
                    }
                }
            }
        }, {
            key: "fillMapData",
            value: function fillMapData(mapInfo, picW, picH, times, len, fillValue) {
                var fristPoint = null;

                for (var j = 0; j < picH; j++) {
                    for (var i = 0; i < picW; i++) {
                        if (mapInfo[j * picW + i] == 0) {
                            if (!fristPoint) {
                                fristPoint = {
                                    x: i,
                                    y: j
                                };
                            }
                        }

                        if (fristPoint) {
                            break;
                        }
                    }

                    if (fristPoint) {
                        break;
                    }
                }

                if (!fristPoint) {
                    return;
                }

                var fillData = 255;
                mapInfo[fristPoint.x + fristPoint.y * picW] = fillData;
                var needFindPoints = [];
                needFindPoints.push(fristPoint);

                function findZeroPoint(p) {
                    var finds = [];
                    var i = p.x;
                    var j = p.y;

                    for (var _j = j - 1; _j <= j + 1; _j++) {
                        for (var _i = i - 1; _i <= i + 1; _i++) {
                            if (_j == j || _i == i) {
                                if (mapInfo[_j * picW + _i] == 0) {
                                    mapInfo[_j * picW + _i] = 255;
                                    finds.push({
                                        x: _i,
                                        y: _j
                                    });
                                }
                            }
                        }
                    }

                    return finds;
                }

                while (needFindPoints.length > 0) {
                    var p = needFindPoints.shift();
                    var ps = findZeroPoint(p);
                    needFindPoints = needFindPoints.concat(ps);
                }

                for (var _j9 = 0; _j9 < picH; _j9++) {
                    for (var _i18 = 0; _i18 < picW; _i18++) {
                        var index = _j9 * picW + _i18;

                        if (mapInfo[index] == 0) {
                            mapInfo[index] = 3;
                        }
                    }
                }

                for (var _j10 = 0; _j10 < picH; _j10++) {
                    for (var _i19 = 0; _i19 < picW; _i19++) {
                        var _index7 = _j10 * picW + _i19;

                        if (mapInfo[_index7] == fillData) {
                            mapInfo[_index7] = 0;
                        }
                    }
                }

                if (!len || len > 6 || len < 1) {
                    len = 4;
                }

                if (!times || times > 3) {
                    times = 1;
                }

                for (var t = 0; t < times; t++) {
                    for (var _i20 = 0; _i20 < picW; _i20++) {
                        var startY = -1;
                        var isEmpty = false;

                        for (var _j11 = 0; _j11 < picH; _j11++) {
                            var _index8 = _j11 * picW + _i20;

                            if (mapInfo[_index8] != 0) {
                                if (isEmpty == true && startY >= 0) {
                                    if (_j11 - startY - 1 <= len) {
                                        for (var _j = startY + 1; _j < _j11; _j++) {
                                            var num = 0;

                                            if (_i20 > 0 && _j > 0) {
                                                for (var __i = _i20 - 1; __i <= _i20 + 1; __i++) {
                                                    for (var __j = _j - 1; __j <= _j + 1; __j++) {
                                                        if (__i != _i20 && __j != _j) {
                                                            if (__i == _i20 || __j == _j) {
                                                                if (mapInfo[__j * picW + __i] != 0 && mapInfo[__j * picW + __i] != undefined) {
                                                                    num++;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                num = 5;
                                            }

                                            if (num >= 3) {
                                                mapInfo[_j * picW + _i20] = fillValue;
                                            }
                                        }
                                    }

                                    isEmpty = false;
                                }

                                startY = _j11;
                            } else {
                                if (startY >= 0) {
                                    isEmpty = true;
                                }
                            }
                        }
                    }

                    for (var _j12 = 0; _j12 < picH; _j12++) {
                        var startX = -1;
                        var _isEmpty = false;

                        for (var _i21 = 0; _i21 < picW; _i21++) {
                            var _index9 = _j12 * picW + _i21;

                            if (mapInfo[_index9] != 0) {
                                if (_isEmpty == true && startX >= 0) {
                                    if (_i21 - startX - 1 <= len) {
                                        for (var _i = startX + 1; _i < _i21; _i++) {
                                            var _num = 0;

                                            if (_i > 0 && _j12 > 0) {
                                                for (var _i22 = _i - 1; _i22 <= _i + 1; _i22++) {
                                                    for (var _j13 = _j12 - 1; _j13 <= _j12 + 1; _j13++) {
                                                        if (_i22 != _i && _j13 != _j12) {
                                                            if (_i22 == _i || _j13 == _j12) {
                                                                if (mapInfo[_j13 * picW + _i22] != 0 && mapInfo[_j13 * picW + _i22] != undefined) {
                                                                    _num++;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                _num = 5;
                                            }

                                            if (_num >= 3) {
                                                mapInfo[_j12 * picW + _i] = fillValue;
                                            }
                                        }
                                    }

                                    _isEmpty = false;
                                }

                                startX = _i21;
                            } else {
                                if (startX >= 0) {
                                    _isEmpty = true;
                                }
                            }
                        }
                    }
                }
            }
        }, {
            key: "getCleanMap2",
            value: function getCleanMap2(selectAreas) {
                if (!this.mapData || !this.mapData.cleanMap || !this.mapData.info.maxX) {
                    return null;
                }

                var pngWidth = this.mapData.cleanMap.width;
                var pngHeight = this.mapData.cleanMap.height;
                var png = new _rnPng2.default({
                    width: pngWidth,
                    height: pngHeight,
                    zlibLib: _pako2.default,
                    colorType: 6
                });
                var map = this.mapData.cleanMap;

                for (var j = 0; j < map.height; j++) {
                    for (var i = 0; i < map.width; i++) {
                        var index = j * map.width + i;
                        var value = map.mapInfo[index];
                        var pngX = i;
                        var pngY = pngHeight - 1 - j;

                        if (value == 1) {
                            png.setPixelAt([pngX, pngY], [131, 178, 255, 255]);

                            if (this.areaInfo) {
                                var _x = (this.areaInfo.minX - map.x) / this.gridWidth;

                                var _y = (this.areaInfo.minY - map.y) / this.gridWidth;

                                if (j >= _y && i >= _x && j < _y + this.areaInfo.h && i < _x + this.areaInfo.w) {
                                    var _j = j - _y;

                                    var _i = i - _x;

                                    var indexArea = _j * this.areaInfo.w + _i;
                                    var valueArea = this.areaInfo.info[indexArea];

                                    if (selectAreas && selectAreas[valueArea] === true) {
                                        png.setPixelAt([pngX, pngY], selectColors[valueArea % 8]);
                                    } else {
                                        png.setPixelAt([pngX, pngY], colors[valueArea % 8]);
                                    }
                                }
                            }
                        } else if (value == 2) {
                            png.setPixelAt([pngX, pngY], [110, 110, 110, 255]);
                        }
                    }
                }

                var base64ImageData = _base64Js2.default.fromByteArray(png.getBuffer());

                var areaInfo = {};

                if (this.areaInfo) {
                    var _x3 = (this.areaInfo.minX - map.x) / this.gridWidth;

                    var _y2 = (this.areaInfo.minY - map.y) / this.gridWidth;

                    for (var area in this.areaInfo.areas) {
                        var boundInfo = this.areaInfo.areas[area];
                        areaInfo[area] = {
                            x: _x3 + boundInfo.minX,
                            y: _y2 + boundInfo.minY,
                            w: boundInfo.maxX - boundInfo.minX,
                            h: boundInfo.maxY - boundInfo.minY,
                            color: colorStrings[parseInt(area)]
                        };
                    }
                }

                return {
                    data: base64ImageData,
                    width: pngWidth,
                    height: pngHeight,
                    robotPos: this.robotPos,
                    chargePos: this.chargerPos,
                    gridWidth: this.gridWidth,
                    mapInfo: this.mapData.info,
                    areaInfo: areaInfo,
                    traces: this.traces
                };
            }
        }, {
            key: "hasArea",
            value: function hasArea() {
                if (this.areaInfo) {
                    return true;
                }

                return false;
            }
        }, {
            key: "getMapDeviation",
            value: function getMapDeviation() {
                return {
                    x: this.mapData.info.minX / this.gridWidth,
                    y: this.mapData.info.minY / this.gridWidth
                };
            }
        }, {
            key: "getAreaSplitLine",
            value: function getAreaSplitLine(area) {
                if (this.areaInfo) {
                    var areaInfo = this.areaInfo.areas[area];
                    var y = (areaInfo.maxY + areaInfo.minY) / 2 * this.gridWidth + this.areaInfo.minY;
                    return [{
                        x: (areaInfo.minX - 10) * this.gridWidth + this.areaInfo.minX,
                        y: y
                    }, {
                        x: (areaInfo.maxX + 10) * this.gridWidth + this.areaInfo.minX,
                        y: y
                    }];
                }

                return null;
            }
        }, {
            key: "checkAreasNear",
            value: function checkAreasNear(selects) {
                if (selects.length != 2) {
                    return false;
                }

                if (this.doors) {
                    for (var i = 0; i < this.doors.length; i++) {
                        var door = this.doors[i];
                        console.log("---", door, selects);

                        if (door.aids.indexOf(parseInt(selects[0])) >= 0 && door.aids.indexOf(parseInt(selects[1])) >= 0) {
                            return true;
                        }
                    }
                }

                return false;
            }
        }, {
            key: "getTraceImage",
            value: function getTraceImage() {
                var traceImage = null;

                if (this.traces.length > 1) {
                    var traceWidth = (this.mapData.info.maxX - this.mapData.info.minX) / 10;
                    var traceHeight = (this.mapData.info.maxY - this.mapData.info.minY) / 10;
                    var tracepng = new _rnPng2.default({
                        width: traceWidth,
                        height: traceHeight,
                        zlibLib: _pako2.default,
                        colorType: 6
                    });

                    for (var i = 1; i < this.traces.length; i++) {
                        var start = this.traces[i - 1];
                        var end = this.traces[i];
                        tracepng.drawLine_aa({
                            start: {
                                x: (start.x - this.mapData.info.minX) / 10,
                                y: traceHeight - (start.y - this.mapData.info.minY) / 10
                            },
                            end: {
                                x: (end.x - this.mapData.info.minX) / 10,
                                y: traceHeight - (end.y - this.mapData.info.minY) / 10
                            }
                        });
                    }

                    traceImage = _base64Js2.default.fromByteArray(tracepng.getBuffer());
                }

                return traceImage;
            }
        }, {
            key: "calculateSpotPos",
            value: function calculateSpotPos(x, y) {
                if (!this.mapData || !this.mapData.cleanMap || !this.mapData.info.maxX) {
                    return null;
                }

                var pngWidth = this.mapData.cleanMap.width;
                var map = this.mapData.cleanMap;
                var value = map.mapInfo[x + y * pngWidth];

                var _x = x + map.x / this.gridWidth;

                var _y = y + map.y / this.gridWidth;

                return {
                    spotPos: [_x, _y],
                    value: value
                };
            }
        }, {
            key: "convertSpotPosToMap",
            value: function convertSpotPosToMap(pos) {
                if (!this.mapData || !this.mapData.cleanMap || !this.mapData.info.maxX) {
                    return [0, 0];
                }

                var x = pos[0];
                var y = pos[1];
                var map = this.mapData.cleanMap;
                var pngWidth = map.width;
                var pngHeight = map.height;
                return [(x - map.x / this.gridWidth + 0.5) / pngWidth, (y - map.y / this.gridWidth + 0.5) / pngHeight];
            }
        }, {
            key: "getMapInfoByPos",
            value: function getMapInfoByPos(x, y) {
                return 0;
            }
        }, {
            key: "getAreaInfo",
            value: function getAreaInfo(area) {
                var map = this.mapData.cleanMap;

                if (this.areaInfo) {
                    var _x = (this.areaInfo.minX - map.x) / this.gridWidth;

                    var _y = (this.areaInfo.minY - map.y) / this.gridWidth;

                    var boundInfo = this.areaInfo.areas[area];
                    return {
                        x: _x + boundInfo.minX,
                        y: _y + boundInfo.minY,
                        w: boundInfo.maxX - boundInfo.minX,
                        h: boundInfo.maxY - boundInfo.minY,
                        color: colorStrings[parseInt(area)]
                    };
                }

                return null;
            }
        }, {
            key: "getAreaSelect",
            value: function getAreaSelect(i, j) {
                var map = this.mapData.cleanMap;

                if (this.areaInfo) {
                    var _x = (this.areaInfo.minX - map.x) / this.gridWidth;

                    var _y = (this.areaInfo.minY - map.y) / this.gridWidth;

                    if (j >= _y && i >= _x && j < _y + this.areaInfo.h && i < _x + this.areaInfo.w) {
                        var _j = j - _y;

                        var _i = i - _x;

                        var indexArea = _j * this.areaInfo.w + _i;
                        var valueArea = this.areaInfo.info[indexArea];
                        return valueArea;
                    }
                }

                return 0;
            }
        }, {
            key: "getAreaInfoAround",
            value: function getAreaInfoAround(i, j) {
                var map = this.mapData.cleanMap;

                if (this.areaInfo) {
                    var _x = (this.areaInfo.minX - map.x) / this.gridWidth;

                    var _y = (this.areaInfo.minY - map.y) / this.gridWidth;

                    if (j >= _y && i >= _x && j < _y + this.areaInfo.h && i < _x + this.areaInfo.w) {
                        var _j = j - _y;

                        var _i = i - _x;

                        var indexArea = _j * this.areaInfo.w + _i;
                        var valueArea = this.areaInfo.info[indexArea];
                        var leftIndex = indexArea - 1;
                        var rightIndex = indexArea + 1;
                        var topIndex = indexArea + this.areaInfo.w;
                        var bottomIndex = indexArea - this.areaInfo.w;
                        var left = 0,
                            right = 0,
                            top = 0,
                            bottom = 0;
                        var bLength = this.areaInfo.info.length;

                        if (leftIndex >= 0 && leftIndex < bLength) {
                            left = this.areaInfo.info[leftIndex];
                        }

                        if (rightIndex >= 0 && rightIndex < bLength) {
                            right = this.areaInfo.info[rightIndex];
                        }

                        if (topIndex >= 0 && topIndex < bLength) {
                            top = this.areaInfo.info[topIndex];
                        }

                        if (bottomIndex >= 0 && bottomIndex < bLength) {
                            bottom = this.areaInfo.info[bottomIndex];
                        }

                        var areaAround = {
                            left: left,
                            center: valueArea,
                            right: right,
                            top: top,
                            bottom: bottom
                        };
                        return areaAround;
                    }
                }

                return {
                    left: 0,
                    center: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
            }
        }, {
            key: "setMapChangeListener",
            value: function setMapChangeListener(lisetner) {
                this.onMapChangeListener = lisetner;
            }
        }, {
            key: "setOnErrListener",
            value: function setOnErrListener(listener) {
                this.onErrListener = listener;
            }
        }, {
            key: "setOnMapInfoListener",
            value: function setOnMapInfoListener(listener) {
                this.OnMapInfoListener = listener;
            }
        }]);
        return MapDataUtil;
    }();

    exports.default = MapDataUtil;

    function getFrameIdStr(frame_id) {
        if (frame_id < 10) {
            return "0000" + frame_id;
        } else if (frame_id < 100) {
            return "000" + frame_id;
        } else if (frame_id < 1000) {
            return "00" + frame_id;
        } else if (frame_id < 10000) {
            return "0" + frame_id;
        } else {
            return "" + frame_id;
        }
    }
},10004,[10007,10016,10064,10010,10112],"projects/com.dreame.devices/main/DreameUtil/MapDataUtil.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */'use strict';

  var base64 = _require(_dependencyMap[0]);

  var ieee754 = _require(_dependencyMap[1]);

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }

  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = {
        __proto__: Uint8Array.prototype,
        foo: function foo() {
          return 42;
        }
      };
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.byteOffset;
    }
  });

  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }

    var buf = new Uint8Array(length);
    buf.__proto__ = Buffer.prototype;
    return buf;
  }

  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }

      return allocUnsafe(arg);
    }

    return from(arg, encodingOrOffset, length);
  }

  if (typeof Symbol !== 'undefined' && (typeof Symbol === "function" ? Symbol.species : "@@species") != null && Buffer[typeof Symbol === "function" ? Symbol.species : "@@species"] === Buffer) {
    Object.defineProperty(Buffer, typeof Symbol === "function" ? Symbol.species : "@@species", {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    });
  }

  Buffer.poolSize = 8192;

  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset);
    }

    if (ArrayBuffer.isView(value)) {
      return fromArrayLike(value);
    }

    if (value == null) {
      throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }

    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }

    var valueOf = value.valueOf && value.valueOf();

    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }

    var b = fromObject(value);
    if (b) return b;

    if (typeof Symbol !== 'undefined' && (typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive") != null && typeof value[typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive"] === 'function') {
      return Buffer.from(value[typeof Symbol === "function" ? Symbol.toPrimitive : "@@toPrimitive"]('string'), encodingOrOffset, length);
    }

    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }

  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };

  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }

  function alloc(size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(size);
    }

    if (fill !== undefined) {
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }

    return createBuffer(size);
  }

  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
  };

  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }

  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
  };

  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
  };

  function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);

    if (actual !== length) {
      buf = buf.slice(0, actual);
    }

    return buf;
  }

  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);

    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }

    return buf;
  }

  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }

    var buf;

    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }

    buf.__proto__ = Buffer.prototype;
    return buf;
  }

  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);

      if (buf.length === 0) {
        return buf;
      }

      obj.copy(buf, 0, 0, len);
      return buf;
    }

    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }

      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    }

    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }

    return Buffer.alloc(+length);
  }

  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
  };

  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (isInstance(buf, Uint8Array)) {
        buf = Buffer.from(buf);
      }

      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }

    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    }

    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    if (start === undefined || start < 0) {
      start = 0;
    }

    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    }

    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }

    if (!Buffer.isBuffer(target)) {
      throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset;

    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }

    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    }

    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF;

      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    }

    var strLen = string.length;

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;

      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }

    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
    return newBuf;
  };

  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }

    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }

    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      this.copyWithin(targetStart, start, end);
    } else if (this === target && start < targetStart && targetStart < end) {
      for (var i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }

    return len;
  };

  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len = bytes.length;

      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  };

  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  function base64clean(str) {
    str = str.split('=')[0];
    str = str.trim().replace(INVALID_BASE64_RE, '');
    if (str.length < 2) return '';

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          leadSurrogate = codePoint;
          continue;
        }

        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }

  function numberIsNaN(obj) {
    return obj !== obj;
  }
},10007,[10010,10013],"projects/com.dreame.devices/node_modules/buffer/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

    for (var i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }
},10010,[],"projects/com.dreame.devices/node_modules/base64-js/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };
},10013,[],"projects/com.dreame.devices/node_modules/ieee754/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _constants = _require(_dependencyMap[0]);

  var _chunk = _require(_dependencyMap[1]);

  var _typedArray = _require(_dependencyMap[2]);

  var _pngPixels = _require(_dependencyMap[3]);

  var _prefix = _require(_dependencyMap[4]);

  var _prefix2 = babelHelpers.interopRequireDefault(_prefix);

  var _ihdr = _require(_dependencyMap[5]);

  var _ihdr2 = babelHelpers.interopRequireDefault(_ihdr);

  var _trns = _require(_dependencyMap[6]);

  var _trns2 = babelHelpers.interopRequireDefault(_trns);

  var _plte = _require(_dependencyMap[7]);

  var _plte2 = babelHelpers.interopRequireDefault(_plte);

  var _bkgd = _require(_dependencyMap[8]);

  var _bkgd2 = babelHelpers.interopRequireDefault(_bkgd);

  var _idat = _require(_dependencyMap[9]);

  var _idat2 = babelHelpers.interopRequireDefault(_idat);

  var _iend = _require(_dependencyMap[10]);

  var _iend2 = babelHelpers.interopRequireDefault(_iend);

  var uint32 = _require(_dependencyMap[11]);

  var _chunks = new WeakMap();

  var _buffer = new WeakMap();

  var _width = new WeakMap();

  var _height = new WeakMap();

  var _depth = new WeakMap();

  var _colorType = new WeakMap();

  var _compression = new WeakMap();

  var _filter = new WeakMap();

  var _interlace = new WeakMap();

  var _zlibLib = new WeakMap();

  var _applyMetaData = function _applyMetaData(ctxt, metaData) {
    var validBitDepths = Object.values(_constants.BitDepths);

    if (!validBitDepths.includes(metaData.depth)) {
      throw new Error('Invalid bit depth');
    }

    if (metaData.depth > _constants.BitDepths.EIGHT) {
      throw new Error('Invalid bit depth');
    }

    var validColorTypes = Object.values(_constants.ColorTypes);

    if (!validColorTypes.includes(metaData.colorType)) {
      throw new Error('Invalid color type');
    }

    _width.set(ctxt, metaData.width);

    _height.set(ctxt, metaData.height);

    _depth.set(ctxt, metaData.depth);

    _colorType.set(ctxt, metaData.colorType);

    _compression.set(ctxt, metaData.compression);

    _filter.set(ctxt, metaData.filter);

    _interlace.set(ctxt, metaData.interlace);
  };

  var _initializeChunks = function _initializeChunks(ctxt, metaData) {
    var width = metaData.width,
        height = metaData.height,
        depth = metaData.depth,
        colorType = metaData.colorType,
        compression = metaData.compression,
        filter = metaData.filter,
        interlace = metaData.interlace;

    var zlibLib = _zlibLib.get(ctxt);

    var numberOfPixels = (0, _pngPixels.computeNumberOfPixels)(width, height);
    var maxNumberOfColors = (0, _pngPixels.computeMaxNumberOfColors)(depth);
    var chunks = {
      prefix: new _prefix2.default(),
      IHDR: new _ihdr2.default({
        width: width,
        height: height,
        depth: depth,
        colorType: colorType,
        compression: compression,
        filter: filter,
        interlace: interlace
      }),
      IDAT: new _idat2.default({
        width: width,
        height: height,
        depth: depth,
        colorType: colorType,
        numberOfPixels: numberOfPixels,
        maxNumberOfColors: maxNumberOfColors,
        zlibLib: zlibLib
      }),
      IEND: new _iend2.default()
    };

    if ((0, _pngPixels.isIndexed)(colorType)) {
      chunks.PLTE = new _plte2.default({
        maxNumberOfColors: maxNumberOfColors
      });
    }

    _chunks.set(ctxt, chunks);
  };

  var _updateChunks = function _updateChunks(ctxt) {
    var chunks = _chunks.get(ctxt);

    chunks.prefix.update();
    var existingChunkTypes = Object.keys(chunks);

    _constants.SupportedChunks.forEach(function (chunkType) {
      if (-1 === existingChunkTypes.indexOf(chunkType)) {
        return;
      }

      chunks[chunkType].update();
    });

    _chunks.set(ctxt, chunks);
  };

  var _buildBuffer = function _buildBuffer(ctxt) {
    var chunks = _chunks.get(ctxt);

    var chunkTypes = Object.keys(chunks);
    var chunkSizes = chunkTypes.reduce(function (acc, chunkType) {
      acc[chunkType] = chunks[chunkType].getBufferLength();
      return acc;
    }, {});
    var totalSize = Object.values(chunkSizes).reduce(function (acc, size) {
      return acc + size;
    }, 0);
    var bufView = new Uint8Array(new ArrayBuffer(totalSize));
    var offset = 0;
    chunks.prefix.copyInto(bufView, offset);
    offset += chunkSizes.prefix;
    var existingChunkTypes = Object.keys(chunks);

    _constants.SupportedChunks.forEach(function (chunkType) {
      if (-1 === existingChunkTypes.indexOf(chunkType)) {
        return;
      }

      chunks[chunkType].copyInto(bufView, offset);
      offset += chunkSizes[chunkType];
    });

    _buffer.set(ctxt, bufView);
  };

  var _loadChunk = function _loadChunk(ctxt, chunkHeader, bufView) {
    var chunks = void 0;
    var chunk = void 0;

    switch (chunkHeader) {
      case 'IHDR':
        chunk = _chunks.get(ctxt)[chunkHeader];
        chunk.load(bufView);

        _applyMetaData(ctxt, chunk.getMetaData());

        break;

      case 'tRNS':
        chunks = _chunks.get(ctxt);
        chunks.tRNS = new _trns2.default({
          colorType: _colorType.get(ctxt),
          numberOfPixels: (0, _pngPixels.computeNumberOfPixels)(_width.get(ctxt), _height.get(ctxt)),
          maxNumberOfColors: (0, _pngPixels.computeMaxNumberOfColors)(_depth.get(ctxt))
        });

        _chunks.set(ctxt, chunks);

        chunk = _chunks.get(ctxt)[chunkHeader];
        chunk.load(bufView);
        break;

      case 'PLTE':
        chunks = _chunks.get(ctxt);
        chunks.PLTE = new _plte2.default({
          maxNumberOfColors: (0, _pngPixels.computeMaxNumberOfColors)(_depth.get(ctxt))
        });

        _chunks.set(ctxt, chunks);

        chunk = _chunks.get(ctxt)[chunkHeader];
        chunk.load(bufView);
        break;

      case 'bKGD':
        chunks = _chunks.get(ctxt);
        chunks.bKGD = new _bkgd2.default({
          colorType: _colorType.get(ctxt)
        });

        _chunks.set(ctxt, chunks);

        chunk = _chunks.get(ctxt)[chunkHeader];
        chunk.load(bufView);
        break;

      case 'IDAT':
        chunk = _chunks.get(ctxt)[chunkHeader];
        chunk.applyLayoutInformation({
          width: _width.get(ctxt),
          height: _height.get(ctxt),
          depth: _depth.get(ctxt),
          colorType: _colorType.get(ctxt),
          numberOfPixels: (0, _pngPixels.computeNumberOfPixels)(_width.get(ctxt), _height.get(ctxt))
        });
        chunk.load(bufView);
        break;

      default:}
  };

  var _doesContainChunk = function _doesContainChunk(ctxt, chunkHeader) {
    return 'undefined' !== typeof _chunks.get(ctxt)[chunkHeader];
  };

  var _translateXyToIndex = function _translateXyToIndex(ctxt, x, y) {
    var width = _width.get(ctxt);

    var colorType = _colorType.get(ctxt);

    var pixelColorSize = (0, _pngPixels.determinePixelColorSize)(colorType);
    var fullPixelSize = pixelColorSize + ((0, _pngPixels.hasAlphaSample)(colorType) ? 1 : 0);
    return y * (width * fullPixelSize) + x * fullPixelSize;
  };

  var RnPng = function () {
    babelHelpers.createClass(RnPng, null, [{
      key: "PixelLayout",
      get: function get() {
        return _constants.PixelLayouts;
      }
    }]);

    function RnPng() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      babelHelpers.classCallCheck(this, RnPng);
      var width = options.width || 0;
      var height = options.height || 0;
      var depth = options.depth || _constants.BitDepths.EIGHT;
      var colorType = options.colorType || _constants.ColorTypes.INDEXED;
      var compression = _constants.DEFAULT_COMPRESSION;
      var filter = _constants.DEFAULT_FILTER;
      var interlace = _constants.DEFAULT_INTERLACE;
      var zlibLib = options.zlibLib || null;

      _applyMetaData(this, {
        width: width,
        height: height,
        depth: depth,
        colorType: colorType,
        compression: compression,
        filter: filter,
        interlace: interlace
      });

      _buffer.set(this, null);

      _initializeChunks(this, this.getMetaData());

      zlibLib && this.applyZlibLib(zlibLib);
    }

    babelHelpers.createClass(RnPng, [{
      key: "getMetaData",
      value: function getMetaData() {
        var width = _width.get(this);

        var height = _height.get(this);

        var depth = _depth.get(this);

        var colorType = _colorType.get(this);

        var compression = _compression.get(this);

        var filter = _filter.get(this);

        var interlace = _interlace.get(this);

        return {
          width: width,
          height: height,
          depth: depth,
          colorType: colorType,
          compression: compression,
          filter: filter,
          interlace: interlace
        };
      }
    }, {
      key: "getBuffer",
      value: function getBuffer() {
        _updateChunks(this);

        _buildBuffer(this);

        return _buffer.get(this);
      }
    }, {
      key: "from",
      value: function from(bufView) {
        var _this = this;

        if (!(bufView instanceof Uint8Array) && !(bufView instanceof Uint8ClampedArray)) {
          throw new Error('A Uint8Array or Uint8ClampledArray is required for loading PNG data');
        }

        if (!_chunks.get(this).prefix.verify(bufView) || !_chunks.get(this).IHDR.verify(bufView) || !_chunks.get(this).IDAT.verify(bufView) || !_chunks.get(this).IEND.verify(bufView)) {
          throw new Error('Attempting to load data that is not a PNG');
        }

        var chunks = _chunks.get(this);

        if (chunks.PLTE) {
          delete chunks.PLTE;
        }

        _chunks.set(this, chunks);

        var chunkHeaderIndex = 0;
        var startIndex = 0;

        _constants.SupportedChunks.forEach(function (chunkHeader) {
          if (chunkHeader === 'IEND') {
            return;
          }

          var tmpHeaderIndex = (0, _typedArray.indexOfSequence)(bufView, _constants.ChunkHeaderSequences[chunkHeader], startIndex);

          if (-1 === tmpHeaderIndex) {
            return;
          }

          chunkHeaderIndex = tmpHeaderIndex;
          startIndex = chunkHeaderIndex + 4;

          _loadChunk(_this, chunkHeader, bufView.subarray(chunkHeaderIndex - _chunk.CHUNK_LENGTH_SIZE));
        });

        return this;
      }
    }, {
      key: "getChunksUsed",
      value: function getChunksUsed() {
        return Object.keys(_chunks.get(this)).filter(function (chunkHeader) {
          return chunkHeader !== 'prefix';
        });
      }
    }, {
      key: "getData",
      value: function getData() {
        var pixelLayout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RnPng.PixelLayout.VALUE;

        var rawPixelData = _chunks.get(this).IDAT.pixelData;

        var pixelData = this.isIndexed() ? _chunks.get(this).PLTE.convertToPixels(rawPixelData) : rawPixelData;
        var trnsData = _doesContainChunk(this, 'tRNS') ? _chunks.get(this).tRNS.getTransparencies() : [];
        return _chunks.get(this).IDAT.getData(pixelLayout, pixelData, trnsData);
      }
    }, {
      key: "getPalette",
      value: function getPalette() {
        if (!_doesContainChunk(this, 'PLTE')) {
          throw new Error('Attempting to get palette indices when no palette exists');
        }

        return _chunks.get(this).PLTE.getPalette();
      }
    }, {
      key: "getPaletteIndexAt",
      value: function getPaletteIndexAt(pos) {
        if (!_doesContainChunk(this, 'PLTE')) {
          throw new Error('Attempting to get palette index when no palette exists');
        }

        var index = void 0;

        if (Array.isArray(pos) && pos.length === 2) {
          index = _translateXyToIndex.apply(undefined, [this].concat(babelHelpers.toConsumableArray(pos)));
        } else {
          index = pos;
        }

        var paletteIndex = _chunks.get(this).IDAT.getValueAt(index);

        if (paletteIndex >= this.getPalette().length) {
          throw new Error('Palette index found that exceeds palette size');
        }

        return paletteIndex;
      }
    }, {
      key: "getPaletteColorAt",
      value: function getPaletteColorAt(pos) {
        if (!_doesContainChunk(this, 'PLTE')) {
          throw new Error('Attempting to get palette color when no palette exists');
        }

        var paletteIndex = this.getPaletteIndexAt(pos);
        return _chunks.get(this).PLTE.getColorOf(paletteIndex);
      }
    }, {
      key: "getOpacities",
      value: function getOpacities() {
        if (this.isGrayscaleWithAlpha() || this.isTruecolorWithAlpha()) {
          var data = this.getData();
          var numberOfSamples = (0, _pngPixels.determinePixelColorSize)(_colorType.get(this)) + 1;
          return data.reduce(function (acc, curr, ind) {
            return (ind + 1) % numberOfSamples === 0 ? acc.concat(curr) : acc;
          }, []);
        }

        var opacities = new Uint8ClampedArray((0, _pngPixels.computeNumberOfPixels)(_width.get(this), _height.get(this)));
        return opacities.fill(255);
      }
    }, {
      key: "getTransparencies",
      value: function getTransparencies() {
        if (_doesContainChunk(this, 'tRNS')) {
          return _chunks.get(this).tRNS.getTransparencies();
        }

        return [];
      }
    }, {
      key: "doesColorExistInTransparencies",
      value: function doesColorExistInTransparencies(colorData) {
        if (_doesContainChunk(this, 'tRNS')) {
          return _chunks.get(this).tRNS.isTransparencySet(colorData);
        }

        return false;
      }
    }, {
      key: "getBackground",
      value: function getBackground() {
        if (_doesContainChunk(this, 'bKGD')) {
          return _chunks.get(this).bKGD.getBackgroundColor();
        }

        return undefined;
      }
    }, {
      key: "getPixelAt",
      value: function getPixelAt(pos) {
        var index = void 0;

        if (Array.isArray(pos) && pos.length === 2) {
          index = _translateXyToIndex.apply(undefined, [this].concat(babelHelpers.toConsumableArray(pos)));
        } else {
          index = pos;
        }

        if (this.hasAlphaChannel()) {
          return _chunks.get(this).IDAT.getPixelOf(index);
        }

        var pixel = _chunks.get(this).IDAT.getPixelOf(index);

        if (this.isIndexed()) {
          var pixelIndex = pixel;
          pixel = _chunks.get(this).PLTE.getColorOf(pixelIndex);

          if (_doesContainChunk(this, 'tRNS')) {
            var opacity = _chunks.get(this).tRNS.getValueOf(pixelIndex);

            pixel = pixel.concat('undefined' === typeof opacity ? 255 : opacity);
          }
        }

        return pixel;
      }
    }, {
      key: "setPixelAt",
      value: function setPixelAt(pos, data) {
        var index = void 0;

        if (Array.isArray(pos) && pos.length === 2) {
          index = _translateXyToIndex.apply(undefined, [this].concat(babelHelpers.toConsumableArray(pos)));
        } else {
          index = pos;
        }

        if (!Array.isArray(data)) {
          data = [data];
        }

        var fullPixelSize = this.isIndexed() ? 3 : (0, _pngPixels.determineFullPixelSize)(_colorType.get(this));

        if (data.length < fullPixelSize) {
          throw new Error("Not enough samples supplied for pixel; expected " + fullPixelSize);
        }

        if (this.hasAlphaChannel()) {
          data = data.slice(0, fullPixelSize);

          _chunks.get(this).IDAT.setPixelOf(index, data);

          return this;
        }

        data = data.slice(0, fullPixelSize + 1);
        var colorData = data.slice(0, fullPixelSize);
        var opacityData = data.length > fullPixelSize ? data[data.length - 1] : undefined;

        if (this.isIndexed()) {
          var paletteIndex = _chunks.get(this).PLTE.isColorInPalette(colorData) ? _chunks.get(this).PLTE.getPaletteIndex(colorData) : _chunks.get(this).PLTE.addColor(colorData);

          _chunks.get(this).IDAT.setPixelOf(index, paletteIndex);

          if ('undefined' !== typeof opacityData) {
            this.setTransparency(opacityData, paletteIndex);
          }

          return this;
        }

        _chunks.get(this).IDAT.setPixelOf(index, colorData);

        if ('undefined' !== typeof opacityData) {
          if (255 === opacityData && this.doesColorExistInTransparencies(colorData)) {
            this.removeTransparency(colorData);
          } else {
            this.setTransparency(colorData);
          }
        }

        return this;
      }
    }, {
      key: "setPaletteColorOf",
      value: function setPaletteColorOf(index, colorData) {
        if (!_doesContainChunk(this, 'PLTE')) {
          throw new Error('Attempting to set a palette color when no palette exists');
        }

        _chunks.get(this).PLTE.setColorOf(index, colorData);

        return this;
      }
    }, {
      key: "replacePaletteColor",
      value: function replacePaletteColor(targetColor, newColor) {
        if (!_doesContainChunk(this, 'PLTE')) {
          throw new Error('Attempting to swap palette when no palette exists');
        }

        _chunks.get(this).PLTE.replaceColor(targetColor, newColor);

        return this;
      }
    }, {
      key: "setOpacityAt",
      value: function setOpacityAt(pos, value) {
        var index = void 0;

        if (Array.isArray(pos) && pos.length === 2) {
          index = _translateXyToIndex.apply(undefined, [this].concat(babelHelpers.toConsumableArray(pos)));
        } else {
          index = pos;
        }

        if (!this.hasAlphaChannel() && !this.isIndexed()) {
          throw new Error('Attempting to set an opacity value on a PNG type that doesn\'t support it.');
        }

        if (this.hasAlphaChannel()) {
          _chunks.get(this).IDAT.setAlpha(value, index);

          return this;
        }

        if (!_doesContainChunk(this, 'PLTE')) {
          throw new Error('Attempting to set the opacity of a palette entry when no palette exists');
        }

        var paletteIndex = _chunks.get(this).IDAT.getValueAt(index);

        if (paletteIndex >= this.getPalette().length) {
          throw new Error('Cannot set the transparency of an item not in palette');
        }

        this.setTransparency(value, paletteIndex);
        return this;
      }
    }, {
      key: "composite",
      value: function composite(i, j, old_pixel, new_pixel) {
        var old_rgba = uint32.getBytesBigEndian(old_pixel);
        var new_rgba = uint32.getBytesBigEndian(new_pixel);
        var A = new_rgba.map(function (b) {
          return b / 255;
        });
        var B = old_rgba.map(function (b) {
          return b / 255;
        });
        A[3] = A[3];

        function compit(ca, cb, aa, ab) {
          return (ca * aa + cb * ab * (1 - aa)) / (aa + ab * (1 - aa));
        }

        var C = A.map(function (comp, i) {
          return compit(A[i], B[i], A[3], B[3]);
        });
        var Cf = C.map(function (c) {
          return c * 255;
        });
        return uint32.fromBytesBigEndian(Cf[0], Cf[1], Cf[2], Cf[3]);
      }
    }, {
      key: "fillPixelWithColor",
      value: function fillPixelWithColor(x0, y0, color) {
        var new_pixel = color;
        var old_pixel = 0xffffff00;
        var final_pixel = this.composite(x0, y0, old_pixel, new_pixel);
        var bytes = uint32.getBytesBigEndian(final_pixel);
        this.setPixelAt([x0, y0], bytes);
      }
    }, {
      key: "drawLine_aa",
      value: function drawLine_aa(line) {
        var width = 2;
        var strokeColor = 0xffffffff;
        var x0 = Math.floor(line.start.x);
        var y0 = Math.floor(line.start.y);
        var x1 = Math.floor(line.end.x);
        var y1 = Math.floor(line.end.y);
        var dx = Math.abs(x1 - x0),
            sx = x0 < x1 ? 1 : -1;
        var dy = Math.abs(y1 - y0),
            sy = y0 < y1 ? 1 : -1;
        var err = dx - dy,
            e2 = void 0,
            x2 = void 0,
            y2 = void 0;
        var ed = dx + dy === 0 ? 1 : Math.sqrt(dx * dx + dy * dy);
        var rgb = uint32.and(strokeColor, 0xFFFFFF00);
        var a1 = uint32.and(strokeColor, 0x000000FF);

        for (width = (width + 1) / 2;;) {
          var alpha = ~~Math.max(0, 255 * (Math.abs(err - dx + dy) / ed - width + 1));
          var a2 = 255 - alpha;
          var color = uint32.or(rgb, a1 * a2 / 255);
          this.fillPixelWithColor(x0, y0, color);
          e2 = err;
          x2 = x0;

          if (2 * e2 >= -dx) {
            for (e2 += dy, y2 = y0; e2 < ed * width && (y1 !== y2 || dx > dy); e2 += dx) {
              var _alpha = ~~Math.max(0, 255 * (Math.abs(e2) / ed - width + 1));

              var _a = 255 - _alpha;

              var _color = uint32.or(rgb, a1 * _a / 255);

              this.fillPixelWithColor(x0, y2 += sy, _color);
            }

            if (x0 === x1) break;
            e2 = err;
            err -= dy;
            x0 += sx;
          }

          if (2 * e2 <= dy) {
            for (e2 = dx - e2; e2 < ed * width && (x1 !== x2 || dx < dy); e2 += dy) {
              var _alpha2 = ~~Math.max(0, 255 * (Math.abs(e2) / ed - width + 1));

              var _a2 = 255 - _alpha2;

              var _color2 = uint32.or(rgb, a1 * _a2 / 255);

              this.fillPixelWithColor(x2 += sx, y0, _color2);
            }

            if (y0 === y1) break;
            err += dx;
            y0 += sy;
          }
        }
      }
    }, {
      key: "setTransparency",
      value: function setTransparency(value) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

        if (!_doesContainChunk(this, 'tRNS')) {
          _chunks.get(this).tRNS = new _trns2.default({
            colorType: _colorType.get(this),
            numberOfPixels: (0, _pngPixels.computeNumberOfPixels)(_width.get(this), _height.get(this)),
            maxNumberOfColors: (0, _pngPixels.computeMaxNumberOfColors)(_depth.get(this))
          });
        }

        _chunks.get(this).tRNS.setTransparency(value, index);

        return this;
      }
    }, {
      key: "removeTransparency",
      value: function removeTransparency(colorData) {
        if (!_doesContainChunk(this, 'tRNS')) {
          throw new Error('Attempting to remove a transparency when no transparency exists');
        }

        if (this.isIndexed()) {
          var paletteIndex = _chunks.get(this).PLTE.getPaletteIndexOf(colorData);

          _chunks.get(this).tRNS.removeTransparencyOf(paletteIndex);

          return this;
        }

        _chunks.get(this).tRNS.removeTransparency(colorData);

        return this;
      }
    }, {
      key: "setBackground",
      value: function setBackground(colorData) {
        if (_doesContainChunk(this, 'PLTE') && !_doesContainChunk(this, 'bKGD')) {
          _chunks.get(this).PLTE.setColorOf(0, colorData);

          return this;
        }

        if (!_doesContainChunk(this, 'bKGD')) {
          _chunks.get(this).bKGD = new _bkgd2.default({
            colorType: _colorType.get(this)
          });
        }

        _chunks.get(this).bKGD.setBackgroundColor(colorData);

        return this;
      }
    }, {
      key: "removeTransparencies",
      value: function removeTransparencies() {
        delete _chunks.get(this).tRNS;
        return this;
      }
    }, {
      key: "removeBackground",
      value: function removeBackground() {
        delete _chunks.get(this).bKGD;
        return this;
      }
    }, {
      key: "applyZlibLib",
      value: function applyZlibLib(lib) {
        if (typeof lib.inflate !== 'function' || typeof lib.deflate !== 'function') {
          throw new Error('zlib library is missing required methods');
        }

        _zlibLib.set(this, lib);

        _chunks.get(this).IDAT.applyZlibLib(lib);

        return this;
      }
    }, {
      key: "isIndexed",
      value: function isIndexed() {
        return (0, _pngPixels.isIndexed)(_colorType.get(this));
      }
    }, {
      key: "isGrayscale",
      value: function isGrayscale() {
        return (0, _pngPixels.isGrayscale)(_colorType.get(this));
      }
    }, {
      key: "isTruecolor",
      value: function isTruecolor() {
        return (0, _pngPixels.isTruecolor)(_colorType.get(this));
      }
    }, {
      key: "isGrayscaleWithAlpha",
      value: function isGrayscaleWithAlpha() {
        return (0, _pngPixels.isGrayscaleWithAlpha)(_colorType.get(this));
      }
    }, {
      key: "isTruecolorWithAlpha",
      value: function isTruecolorWithAlpha() {
        return (0, _pngPixels.isTruecolorWithAlpha)(_colorType.get(this));
      }
    }, {
      key: "hasAlphaChannel",
      value: function hasAlphaChannel() {
        return (0, _pngPixels.hasAlphaSample)(_colorType.get(this));
      }
    }, {
      key: "width",
      get: function get() {
        return _width.get(this);
      }
    }, {
      key: "height",
      get: function get() {
        return _height.get(this);
      }
    }, {
      key: "depth",
      get: function get() {
        return _depth.get(this);
      }
    }]);
    return RnPng;
  }();

  exports.default = RnPng;
},10016,[10019,10022,10028,10034,10037,10040,10043,10046,10049,10052,10058,10061],"projects/com.dreame.devices/main/DreameUtil/pngjs/rn-png.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var DEFAULT_TRANSPARENCY = exports.DEFAULT_TRANSPARENCY = 255;
  var DEFAULT_COMPRESSION = exports.DEFAULT_COMPRESSION = 0;
  var DEFAULT_FILTER = exports.DEFAULT_FILTER = 0;
  var DEFAULT_INTERLACE = exports.DEFAULT_INTERLACE = 0;
  var SupportedChunks = exports.SupportedChunks = ['IHDR', 'PLTE', 'tRNS', 'bKGD', 'IDAT', 'IEND'];
  var ChunkHeaderSequences = exports.ChunkHeaderSequences = {
    IHDR: [73, 72, 68, 82],
    PLTE: [80, 76, 84, 69],
    tRNS: [116, 82, 78, 83],
    bKGD: [98, 75, 71, 68],
    IDAT: [73, 68, 65, 84],
    IEND: [73, 69, 78, 68]
  };
  var BitDepths = exports.BitDepths = {
    ONE: 1,
    TWO: 2,
    FOUR: 4,
    EIGHT: 8,
    SIXTEEN: 16
  };
  var ColorTypes = exports.ColorTypes = {
    GRAYSCALE: 0,
    TRUECOLOR: 2,
    INDEXED: 3,
    GRAYSCALE_AND_ALPHA: 4,
    TRUECOLOR_AND_ALPHA: 6
  };
  var PixelLayouts = exports.PixelLayouts = {
    VALUE: 0,
    INDEX_VALUE: 1,
    RGB: 3,
    RGBA: 4
  };
  var ScanlineFilterTypes = exports.ScanlineFilterTypes = {
    NONE: 0,
    SUB: 1,
    UP: 2,
    AVERAGE: 3,
    PAETH: 4
  };
},10019,[],"projects/com.dreame.devices/main/DreameUtil/pngjs/util/constants.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CHUNK_CRC32_SIZE = exports.CHUNK_HEADER_SIZE = exports.CHUNK_LENGTH_SIZE = undefined;

  var _arrayBufferWrapper = _require(_dependencyMap[0]);

  var _arrayBufferWrapper2 = babelHelpers.interopRequireDefault(_arrayBufferWrapper);

  var _crc = _require(_dependencyMap[1]);

  var CHUNK_LENGTH_SIZE = exports.CHUNK_LENGTH_SIZE = 4;
  var CHUNK_HEADER_SIZE = exports.CHUNK_HEADER_SIZE = 4;
  var CHUNK_CRC32_SIZE = exports.CHUNK_CRC32_SIZE = 4;

  var Chunk = function () {
    function Chunk(header) {
      babelHelpers.classCallCheck(this, Chunk);
      this._abw = null;
      this._header = header;
    }

    babelHelpers.createClass(Chunk, [{
      key: "initialize",
      value: function initialize(size) {
        this._abw = new _arrayBufferWrapper2.default(size);
      }
    }, {
      key: "copyInto",
      value: function copyInto(buffer, offset) {
        buffer.set(this._abw.bufferView, offset);
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(src, offset) {
        this._abw.copyFrom(src, offset);
      }
    }, {
      key: "calculateDataOffset",
      value: function calculateDataOffset() {
        return CHUNK_LENGTH_SIZE + CHUNK_HEADER_SIZE;
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        return CHUNK_LENGTH_SIZE + CHUNK_HEADER_SIZE + CHUNK_CRC32_SIZE;
      }
    }, {
      key: "getBufferLength",
      value: function getBufferLength() {
        return this._abw.bufferView.length;
      }
    }, {
      key: "calculateCrc32",
      value: function calculateCrc32() {
        var chunkLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
        chunkLength = chunkLength !== -1 ? chunkLength : this.calculateChunkLength();
        var size = chunkLength - CHUNK_LENGTH_SIZE - CHUNK_CRC32_SIZE;
        return (0, _crc.calculateCrc32)(this.buffer, CHUNK_LENGTH_SIZE, size);
      }
    }, {
      key: "isRequired",
      value: function isRequired() {
        return false;
      }
    }, {
      key: "buffer",
      get: function get() {
        return this._abw;
      }
    }, {
      key: "header",
      get: function get() {
        return this._header;
      }
    }]);
    return Chunk;
  }();

  exports.default = Chunk;
},10022,[10025,10031],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/chunk.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typedArray = _require(_dependencyMap[0]);

  var ArrayBufferWrapper = function () {
    function ArrayBufferWrapper(size) {
      var startingOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      babelHelpers.classCallCheck(this, ArrayBufferWrapper);
      this._bufferView = new Uint8Array(new ArrayBuffer(size));
      this._offset = startingOffset;
    }

    babelHelpers.createClass(ArrayBufferWrapper, [{
      key: "readUint8At",
      value: function readUint8At(offset) {
        return (0, _typedArray.readUint8At)(this._bufferView, offset);
      }
    }, {
      key: "readUint16At",
      value: function readUint16At(offset) {
        var lsb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return (0, _typedArray.readUint16At)(this._bufferView, offset, lsb);
      }
    }, {
      key: "readUint32At",
      value: function readUint32At(offset) {
        var lsb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return (0, _typedArray.readUint32At)(this._bufferView, offset, lsb);
      }
    }, {
      key: "writeUint8",
      value: function writeUint8(value) {
        this._offset = (0, _typedArray.writeUint8At)(this._bufferView, this._offset, value);
        return this._offset;
      }
    }, {
      key: "writeUint8At",
      value: function writeUint8At(offset, value) {
        return (0, _typedArray.writeUint8At)(this._bufferView, offset, value);
      }
    }, {
      key: "writeString8",
      value: function writeString8(value, lsb) {
        this._offset = this.writeString8At(this._offset, value, lsb);
        return this._offset;
      }
    }, {
      key: "writeString8At",
      value: function writeString8At(offset, value) {
        var lsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (lsb) {
          value = value.split('').reverse().join('');
        }

        for (var i = 0, n = value.length; i < n; i++) {
          offset = (0, _typedArray.writeUint8At)(this._bufferView, offset, value.charCodeAt(i));
        }

        return offset;
      }
    }, {
      key: "writeUint16",
      value: function writeUint16(value, lsb) {
        this._offset = (0, _typedArray.writeUint16At)(this._bufferView, this._offset, value, lsb);
        return this._offset;
      }
    }, {
      key: "writeUint16At",
      value: function writeUint16At(offset, value) {
        var lsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return (0, _typedArray.writeUint16At)(this._bufferView, offset, value, lsb);
      }
    }, {
      key: "writeUint32",
      value: function writeUint32(value, lsb) {
        this._offset = (0, _typedArray.writeUint32At)(this._bufferView, this._offset, value, lsb);
        return this._offset;
      }
    }, {
      key: "writeUint32At",
      value: function writeUint32At(offset, value) {
        var lsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return (0, _typedArray.writeUint32At)(this._bufferView, offset, value, lsb);
      }
    }, {
      key: "copyInto",
      value: function copyInto(abuf) {
        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        var sourceLength = length < 0 ? abuf.length : length;
        var i = void 0;

        for (i = 0; i < sourceLength; i++) {
          this._bufferView[i] = abuf[i] & 255;
        }
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(src, offset) {
        if (typeof offset === 'undefined') {
          offset = this._offset;
        }

        this._bufferView.set(src, offset);
      }
    }, {
      key: "get",
      value: function get(index) {
        return this._bufferView[index];
      }
    }, {
      key: "stepOffset",
      value: function stepOffset(step) {
        this._offset = this._offset + step;
        return this._offset;
      }
    }, {
      key: "offset",
      get: function get() {
        return this._offset;
      },
      set: function set(value) {
        this._offset = value;
      }
    }, {
      key: "bufferView",
      get: function get() {
        return this._bufferView;
      }
    }]);
    return ArrayBufferWrapper;
  }();

  exports.default = ArrayBufferWrapper;
},10025,[10028],"projects/com.dreame.devices/main/DreameUtil/pngjs/util/array-buffer-wrapper.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.packByteData = exports.unpackByteData = exports.readUint32At = exports.writeUint32At = exports.readUint16At = exports.writeUint16At = exports.readUint8At = exports.writeUint8At = exports.indexOfSequence = undefined;

  var _constants = _require(_dependencyMap[0]);

  var indexOfSequence = exports.indexOfSequence = function indexOfSequence(bv, seq) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    var searchIndices = void 0;
    var limit = end !== -1 ? end : bv.byteLength;
    var seqLength = seq.length;

    for (var i = start; i < limit; i++) {
      var searchIndex = bv.indexOf(seq[0], i);

      if (searchIndex === -1) {
        continue;
      }

      searchIndices = [searchIndex];

      for (var j = 1; j < seqLength; j++) {
        if (bv[searchIndex + j] !== seq[j]) {
          break;
        }

        searchIndices.push(searchIndex + j);
      }

      if (searchIndices.length === seqLength) {
        return searchIndices[0];
      }
    }

    return -1;
  };

  var writeUint8At = exports.writeUint8At = function writeUint8At(buffer, offset, value) {
    buffer[offset++] = value & 255;
    return offset;
  };

  var readUint8At = exports.readUint8At = function readUint8At(buffer, offset) {
    var newOffset = offset;
    var value = buffer[newOffset++] & 255;
    return value;
  };

  var writeUint16At = exports.writeUint16At = function writeUint16At(buffer, offset, value) {
    var lsb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (lsb) {
      buffer[offset++] = value & 255;
      buffer[offset++] = value >> 8 & 255;
    } else {
      buffer[offset++] = value >> 8 & 255;
      buffer[offset++] = value & 255;
    }

    return offset;
  };

  var readUint16At = exports.readUint16At = function readUint16At(buffer, offset) {
    var lsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var value = void 0;
    var newOffset = offset;

    if (lsb) {
      value = buffer[newOffset++] & 255;
      value += buffer[newOffset++] << 8;
    } else {
      value = buffer[newOffset++] << 8;
      value += buffer[newOffset++] & 255;
    }

    return value;
  };

  var writeUint32At = exports.writeUint32At = function writeUint32At(buffer, offset, value) {
    var lsb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (lsb) {
      buffer[offset++] = value & 255;
      buffer[offset++] = value >> 8 & 255;
      buffer[offset++] = value >> 16 & 255;
      buffer[offset++] = value >> 24 & 255;
    } else {
      buffer[offset++] = value >> 24 & 255;
      buffer[offset++] = value >> 16 & 255;
      buffer[offset++] = value >> 8 & 255;
      buffer[offset++] = value & 255;
    }

    return offset;
  };

  var readUint32At = exports.readUint32At = function readUint32At(buffer, offset) {
    var lsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var value = void 0;
    var newOffset = offset;

    if (lsb) {
      value = buffer[newOffset++] & 255;
      value += buffer[newOffset++] << 8;
      value += buffer[newOffset++] << 16;
      value += buffer[newOffset++] << 24;
    } else {
      value = buffer[newOffset++] << 24;
      value += buffer[newOffset++] << 16;
      value += buffer[newOffset++] << 8;
      value += buffer[newOffset++] & 255;
    }

    return value;
  };

  var unpackDepth1Data = function unpackDepth1Data(packedData, translateValues) {
    var values = [0, 255];
    var unpackedData = new Uint8ClampedArray(packedData.length * 8);
    var n = 0;
    packedData.forEach(function (byte) {
      var pixel1 = byte >> 7 & 1;
      var pixel2 = byte >> 6 & 1;
      var pixel3 = byte >> 5 & 1;
      var pixel4 = byte >> 4 & 1;
      var pixel5 = byte >> 3 & 1;
      var pixel6 = byte >> 2 & 1;
      var pixel7 = byte >> 1 & 1;
      var pixel8 = byte & 1;

      if (translateValues) {
        unpackedData[n++] = values[pixel1];
        unpackedData[n++] = values[pixel2];
        unpackedData[n++] = values[pixel3];
        unpackedData[n++] = values[pixel4];
        unpackedData[n++] = values[pixel5];
        unpackedData[n++] = values[pixel6];
        unpackedData[n++] = values[pixel7];
        unpackedData[n++] = values[pixel8];
      } else {
        unpackedData[n++] = pixel1;
        unpackedData[n++] = pixel2;
        unpackedData[n++] = pixel3;
        unpackedData[n++] = pixel4;
        unpackedData[n++] = pixel5;
        unpackedData[n++] = pixel6;
        unpackedData[n++] = pixel7;
        unpackedData[n++] = pixel8;
      }
    });
    return unpackedData;
  };

  var unpackDepth2Data = function unpackDepth2Data(packedData, translateValues) {
    var values = [0, 85, 170, 255];
    var unpackedData = new Uint8ClampedArray(packedData.length * 4);
    var n = 0;
    packedData.forEach(function (byte) {
      var pixel1 = 0;
      var pixel2 = 0;
      var pixel3 = 0;
      var pixel4 = 0;
      pixel1 += (byte >> 6 & 1) === 1 ? 1 : 0;
      pixel1 += (byte >> 7 & 1) === 1 ? 2 : 0;
      pixel2 += (byte >> 4 & 1) === 1 ? 1 : 0;
      pixel2 += (byte >> 5 & 1) === 1 ? 2 : 0;
      pixel3 += (byte >> 2 & 1) === 1 ? 1 : 0;
      pixel3 += (byte >> 3 & 1) === 1 ? 2 : 0;
      pixel4 += (byte & 1) === 1 ? 1 : 0;
      pixel4 += (byte >> 1 & 1) === 1 ? 2 : 0;

      if (translateValues) {
        unpackedData[n++] = values[pixel1];
        unpackedData[n++] = values[pixel2];
        unpackedData[n++] = values[pixel3];
        unpackedData[n++] = values[pixel4];
      } else {
        unpackedData[n++] = pixel1;
        unpackedData[n++] = pixel2;
        unpackedData[n++] = pixel3;
        unpackedData[n++] = pixel4;
      }
    });
    return unpackedData;
  };

  var unpackDepth4Data = function unpackDepth4Data(packedData, translateValues) {
    var values = [0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255];
    var unpackedData = new Uint8ClampedArray(packedData.length * 2);
    var n = 0;
    packedData.forEach(function (byte) {
      var pixel1 = 0;
      var pixel2 = 0;
      pixel1 += (byte >> 4 & 1) === 1 ? 1 : 0;
      pixel1 += (byte >> 5 & 1) === 1 ? 2 : 0;
      pixel1 += (byte >> 6 & 1) === 1 ? 4 : 0;
      pixel1 += (byte >> 7 & 1) === 1 ? 8 : 0;
      pixel2 += (byte & 1) === 1 ? 1 : 0;
      pixel2 += (byte >> 1 & 1) === 1 ? 2 : 0;
      pixel2 += (byte >> 2 & 1) === 1 ? 4 : 0;
      pixel2 += (byte >> 3 & 1) === 1 ? 8 : 0;

      if (translateValues) {
        unpackedData[n++] = values[pixel1];
        unpackedData[n++] = values[pixel2];
      } else {
        unpackedData[n++] = pixel1;
        unpackedData[n++] = pixel2;
      }
    });
    return unpackedData;
  };

  var packDepth1Data = function packDepth1Data(unpackedData) {
    var packedData = new Uint8ClampedArray(unpackedData.length / 8);
    var i = 0;
    var n = 0;

    while (i < unpackedData.length) {
      var byte = (unpackedData[i++] > 0 ? 1 : 0) << 7;
      byte |= (unpackedData[i++] > 0 ? 1 : 0) << 6;
      byte |= (unpackedData[i++] > 0 ? 1 : 0) << 5;
      byte |= (unpackedData[i++] > 0 ? 1 : 0) << 4;
      byte |= (unpackedData[i++] > 0 ? 1 : 0) << 3;
      byte |= (unpackedData[i++] > 0 ? 1 : 0) << 2;
      byte |= (unpackedData[i++] > 0 ? 1 : 0) << 1;
      byte |= unpackedData[i++] > 0 ? 1 : 0;
      packedData[n++] = byte;
    }

    return packedData;
  };

  var packDepth2Data = function packDepth2Data(unpackedData, translateValues) {
    var values = {
      0: 0,
      85: 1,
      170: 2,
      255: 3
    };
    var packedData = new Uint8ClampedArray(unpackedData.length / 4);
    var i = 0;
    var n = 0;

    while (i < unpackedData.length) {
      var pixel1 = unpackedData[i++];
      var pixel2 = unpackedData[i++];
      var pixel3 = unpackedData[i++];
      var pixel4 = unpackedData[i++];
      var byte = void 0;

      if (translateValues) {
        byte = values[pixel1] << 6;
        byte |= values[pixel2] << 4;
        byte |= values[pixel3] << 2;
        byte |= values[pixel4];
      } else {
        byte = pixel1 << 6;
        byte |= pixel2 << 4;
        byte |= pixel3 << 2;
        byte |= pixel4;
      }

      packedData[n++] = byte;
    }

    return packedData;
  };

  var packDepth4Data = function packDepth4Data(unpackedData, translateValues) {
    var values = {
      0: 0,
      17: 1,
      34: 2,
      51: 3,
      68: 4,
      85: 5,
      102: 6,
      119: 7,
      136: 8,
      153: 9,
      170: 10,
      187: 11,
      204: 12,
      221: 13,
      238: 14,
      255: 15
    };
    var packedData = new Uint8ClampedArray(unpackedData.length / 2);
    var i = 0;
    var n = 0;

    while (i < unpackedData.length) {
      var pixel1 = unpackedData[i++];
      var pixel2 = unpackedData[i++];
      var byte = void 0;

      if (translateValues) {
        byte = values[pixel1] << 4;
        byte |= values[pixel2];
      } else {
        byte = pixel1 << 4;
        byte |= pixel2;
      }

      packedData[n++] = byte;
    }

    return packedData;
  };

  var unpackByteData = exports.unpackByteData = function unpackByteData(packedData, depth) {
    var translateValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (_constants.BitDepths.ONE === depth) {
      return unpackDepth1Data(packedData, translateValues);
    }

    if (_constants.BitDepths.TWO === depth) {
      return unpackDepth2Data(packedData, translateValues);
    }

    if (_constants.BitDepths.FOUR === depth) {
      return unpackDepth4Data(packedData, translateValues);
    }

    return packedData;
  };

  var packByteData = exports.packByteData = function packByteData(unpackedData, depth) {
    var translateValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (_constants.BitDepths.ONE === depth) {
      return packDepth1Data(unpackedData);
    }

    if (_constants.BitDepths.TWO === depth) {
      return packDepth2Data(unpackedData, translateValues);
    }

    if (_constants.BitDepths.FOUR === depth) {
      return packDepth4Data(unpackedData, translateValues);
    }

    return unpackedData;
  };
},10028,[10019],"projects/com.dreame.devices/main/DreameUtil/pngjs/util/typed-array.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _TABLE = new Int32Array([0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d]);

  var calculateCrc32 = exports.calculateCrc32 = function calculateCrc32(buffer, start, end) {
    var crc = -1;

    for (var i = 0; i < end; i++) {
      var byte = buffer.get(start + i);
      crc = _TABLE[(crc ^ byte) & 0xff] ^ crc >> 8 & 0x00ffffff;
    }

    return crc ^ -1;
  };
},10031,[],"projects/com.dreame.devices/main/DreameUtil/pngjs/util/crc.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.formatPixels = exports.determineBackgroundSamplesPerEntry = exports.determineTransparencySpacePerSample = exports.determineTransparencySamplesPerEntry = exports.determineDataRowLength = exports.determineBytesPerPixel = exports.determineFullPixelSize = exports.determinePixelColorSize = exports.hasAlphaSample = exports.isTruecolorWithAlpha = exports.isGrayscaleWithAlpha = exports.isIndexed = exports.isTruecolor = exports.isGrayscale = exports.computeMaxNumberOfColors = exports.computeNumberOfPixels = exports.unhashPixelIndexKey = exports.hashPixelIndexKey = exports.hashPixelData = undefined;

  var _constants = _require(_dependencyMap[0]);

  var hashPixelData = exports.hashPixelData = function hashPixelData(colorData) {
    return colorData.join(',');
  };

  var hashPixelIndexKey = exports.hashPixelIndexKey = function hashPixelIndexKey(index) {
    return String(index);
  };

  var unhashPixelIndexKey = exports.unhashPixelIndexKey = function unhashPixelIndexKey(index) {
    return Number(index);
  };

  var computeNumberOfPixels = exports.computeNumberOfPixels = function computeNumberOfPixels(width, height) {
    return width * height;
  };

  var computeMaxNumberOfColors = exports.computeMaxNumberOfColors = function computeMaxNumberOfColors(depth) {
    return Math.pow(2, depth);
  };

  var isGrayscale = exports.isGrayscale = function isGrayscale(colorType) {
    return colorType === _constants.ColorTypes.GRAYSCALE;
  };

  var isTruecolor = exports.isTruecolor = function isTruecolor(colorType) {
    return colorType === _constants.ColorTypes.TRUECOLOR;
  };

  var isIndexed = exports.isIndexed = function isIndexed(colorType) {
    return colorType === _constants.ColorTypes.INDEXED;
  };

  var isGrayscaleWithAlpha = exports.isGrayscaleWithAlpha = function isGrayscaleWithAlpha(colorType) {
    return colorType === _constants.ColorTypes.GRAYSCALE_AND_ALPHA;
  };

  var isTruecolorWithAlpha = exports.isTruecolorWithAlpha = function isTruecolorWithAlpha(colorType) {
    return colorType === _constants.ColorTypes.TRUECOLOR_AND_ALPHA;
  };

  var hasAlphaSample = exports.hasAlphaSample = function hasAlphaSample(colorType) {
    return isGrayscaleWithAlpha(colorType) || isTruecolorWithAlpha(colorType);
  };

  var determinePixelColorSize = exports.determinePixelColorSize = function determinePixelColorSize(colorType) {
    return isGrayscale(colorType) || isGrayscaleWithAlpha(colorType) || isIndexed(colorType) ? 1 : 3;
  };

  var determineFullPixelSize = exports.determineFullPixelSize = function determineFullPixelSize(colorType) {
    return determinePixelColorSize(colorType) + (hasAlphaSample(colorType) ? 1 : 0);
  };

  var determineBytesPerPixel = exports.determineBytesPerPixel = function determineBytesPerPixel(depth, colorType) {
    if (_constants.BitDepths.ONE === depth) {
      return 0.125;
    }

    if (_constants.BitDepths.TWO === depth) {
      return 0.25;
    }

    if (_constants.BitDepths.FOUR === depth) {
      return 0.5;
    }

    return determineFullPixelSize(colorType);
  };

  var determineDataRowLength = exports.determineDataRowLength = function determineDataRowLength(depth, colorType, width) {
    return Math.ceil(determineBytesPerPixel(depth, colorType) * width);
  };

  var determineTransparencySamplesPerEntry = exports.determineTransparencySamplesPerEntry = function determineTransparencySamplesPerEntry(colorType) {
    return isTruecolor(colorType) ? 3 : 1;
  };

  var determineTransparencySpacePerSample = exports.determineTransparencySpacePerSample = function determineTransparencySpacePerSample(colorType) {
    return isGrayscale(colorType) || isTruecolor(colorType) ? 2 : 1;
  };

  var determineBackgroundSamplesPerEntry = exports.determineBackgroundSamplesPerEntry = function determineBackgroundSamplesPerEntry(colorType) {
    if (_constants.ColorTypes.INDEXED === colorType || _constants.ColorTypes.GRAYSCALE === colorType || _constants.ColorTypes.GRAYSCALE_AND_ALPHA == colorType) {
      return 1;
    }

    return 3;
  };

  var formatPixelsForColorType0 = function formatPixelsForColorType0(pixelData, trnsData, numberOfValuesInLayout) {
    var formattedData = new Uint8ClampedArray(pixelData.length * numberOfValuesInLayout);
    var i = 0;
    var n = 0;

    while (i < pixelData.length) {
      var value = pixelData[i++];
      formattedData[n++] = value;
      formattedData[n++] = value;
      formattedData[n++] = value;

      if (numberOfValuesInLayout === 4) {
        formattedData[n++] = trnsData.includes(value) ? 0 : 255;
      }
    }

    return formattedData;
  };

  var formatPixelsForColorType2 = function formatPixelsForColorType2(pixelData, trnsData, numberOfValuesInLayout, width, height) {
    if (3 === numberOfValuesInLayout) {
      return pixelData;
    }

    var numberOfPixels = computeNumberOfPixels(width, height);
    var formattedData = new Uint8ClampedArray(pixelData.length + numberOfPixels);
    var hashedTrnsData = trnsData.map(function (element) {
      return hashPixelData(element);
    });
    var i = 0;
    var n = 0;

    while (i < pixelData.length) {
      var r = pixelData[i++];
      var g = pixelData[i++];
      var b = pixelData[i++];
      var hashedPixel = hashPixelData([r, g, b]);
      formattedData[n++] = r;
      formattedData[n++] = g;
      formattedData[n++] = b;
      formattedData[n++] = hashedTrnsData.includes(hashedPixel) ? 0 : 255;
    }

    return formattedData;
  };

  var formatPixelsForColorType3 = function formatPixelsForColorType3(pixelData, trnsData, numberOfValuesInLayout, width, height) {
    if (3 === numberOfValuesInLayout) {
      return pixelData;
    }

    var numberOfPixels = computeNumberOfPixels(width, height);
    var formattedData = new Uint8ClampedArray(pixelData.length + numberOfPixels);
    var i = 0;
    var n = 0;
    var pixelIndex = 0;

    while (i < pixelData.length) {
      formattedData[n++] = pixelData[i++];
      formattedData[n++] = pixelData[i++];
      formattedData[n++] = pixelData[i++];
      formattedData[n++] = 'undefined' !== typeof trnsData[pixelIndex] ? trnsData[pixelIndex] : 255;
      pixelIndex++;
    }

    return formattedData;
  };

  var formatPixelsForColorType4 = function formatPixelsForColorType4(pixelData, numberOfValuesInLayout, width, height) {
    var formattedData = void 0;

    if (3 === numberOfValuesInLayout) {
      var numberOfPixels = computeNumberOfPixels(width, height);
      formattedData = new Uint8ClampedArray(numberOfPixels * 3);
      var i = 0;
      var n = 0;

      while (i < pixelData.length) {
        var luminousity = pixelData[i++];
        formattedData[n++] = luminousity;
        formattedData[n++] = luminousity;
        formattedData[n++] = luminousity;
        i++;
      }
    } else {
      formattedData = new Uint8ClampedArray(pixelData.length * 2);
      var _i = 0;
      var _n = 0;

      while (_i < pixelData.length) {
        var _luminousity = pixelData[_i++];
        formattedData[_n++] = _luminousity;
        formattedData[_n++] = _luminousity;
        formattedData[_n++] = _luminousity;
        formattedData[_n++] = pixelData[_i++];
      }
    }

    return formattedData;
  };

  var formatPixelsForColorType6 = function formatPixelsForColorType6(pixelData, numberOfValuesInLayout, width, height) {
    if (4 === numberOfValuesInLayout) {
      return pixelData;
    }

    var numberOfPixels = computeNumberOfPixels(width, height);
    var formattedData = new Uint8ClampedArray(pixelData.length - numberOfPixels);
    var i = 0;
    var n = 0;

    while (i < pixelData.length) {
      formattedData[n++] = pixelData[i++];
      formattedData[n++] = pixelData[i++];
      formattedData[n++] = pixelData[i++];
      i++;
    }

    return formattedData;
  };

  var formatPixels = exports.formatPixels = function formatPixels(colorType, width, height, pixelLayout, pixelData, trnsData) {
    var numberOfValuesInLayout = _constants.PixelLayouts.RGB === pixelLayout ? 3 : 4;

    if (_constants.ColorTypes.GRAYSCALE === colorType) {
      return formatPixelsForColorType0(pixelData, trnsData, numberOfValuesInLayout);
    }

    if (_constants.ColorTypes.TRUECOLOR === colorType) {
      return formatPixelsForColorType2(pixelData, trnsData, numberOfValuesInLayout, width, height);
    }

    if (_constants.ColorTypes.INDEXED === colorType) {
      return formatPixelsForColorType3(pixelData, trnsData, numberOfValuesInLayout, width, height);
    }

    if (_constants.ColorTypes.GRAYSCALE_AND_ALPHA === colorType) {
      return formatPixelsForColorType4(pixelData, numberOfValuesInLayout, width, height);
    }

    if (_constants.ColorTypes.TRUECOLOR_AND_ALPHA === colorType) {
      return formatPixelsForColorType6(pixelData, numberOfValuesInLayout, width, height);
    }
  };
},10034,[10019],"projects/com.dreame.devices/main/DreameUtil/pngjs/util/png-pixels.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _typedArray = _require(_dependencyMap[1]);

  var PREFIX = '\x89PNG\r\n\x1A\n';
  var VERIFY_SEQUENCE = [137, 80, 78, 71];

  var Prefix = function (_Chunk) {
    babelHelpers.inherits(Prefix, _Chunk);

    function Prefix() {
      babelHelpers.classCallCheck(this, Prefix);

      var _this = babelHelpers.possibleConstructorReturn(this, (Prefix.__proto__ || Object.getPrototypeOf(Prefix)).call(this));

      var chunkLength = _this.calculateChunkLength();

      _this.initialize(chunkLength);

      return _this;
    }

    babelHelpers.createClass(Prefix, [{
      key: "update",
      value: function update() {
        this.buffer.writeString8(PREFIX);
      }
    }, {
      key: "verify",
      value: function verify(bufView) {
        return (0, _typedArray.indexOfSequence)(bufView, VERIFY_SEQUENCE, 0, this.calculateChunkLength()) !== -1;
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        return PREFIX.length;
      }
    }]);
    return Prefix;
  }(_chunk2.default);

  exports.default = Prefix;
},10037,[10022,10028],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/prefix.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _constants = _require(_dependencyMap[1]);

  var _typedArray = _require(_dependencyMap[2]);

  var HEADER = 'IHDR';
  var PAYLOAD_SIZE = 13;

  var IDHR = function (_Chunk) {
    babelHelpers.inherits(IDHR, _Chunk);

    function IDHR(options) {
      babelHelpers.classCallCheck(this, IDHR);

      var _this = babelHelpers.possibleConstructorReturn(this, (IDHR.__proto__ || Object.getPrototypeOf(IDHR)).call(this, HEADER));

      _this._width = options.width;
      _this._height = options.height;
      _this._depth = options.depth;
      _this._colorType = options.colorType;
      _this._compression = options.compression;
      _this._filter = options.filter;
      _this._interlace = options.interlace;

      var chunkLength = _this.calculateChunkLength();

      _this.initialize(chunkLength);

      return _this;
    }

    babelHelpers.createClass(IDHR, [{
      key: "update",
      value: function update() {
        this.buffer.writeUint32(PAYLOAD_SIZE);
        this.buffer.writeString8(HEADER);
        this.buffer.writeUint32(this._width);
        this.buffer.writeUint32(this._height);
        this.buffer.writeUint8(this._depth);
        this.buffer.writeUint8(this._colorType);
        this.buffer.writeUint8(this._compression);
        this.buffer.writeUint8(this._filter);
        this.buffer.writeUint8(this._interlace);
        this.buffer.writeUint32(this.calculateCrc32());
      }
    }, {
      key: "load",
      value: function load(abuf) {
        var chunkLength = this.calculateChunkLength();
        this.initialize(chunkLength);

        this._extractMetaData(abuf);
      }
    }, {
      key: "verify",
      value: function verify(bufView) {
        return (0, _typedArray.indexOfSequence)(bufView, _constants.ChunkHeaderSequences[HEADER]) !== -1;
      }
    }, {
      key: "_extractMetaData",
      value: function _extractMetaData(abuf) {
        var offset = _chunk.CHUNK_LENGTH_SIZE + _chunk.CHUNK_HEADER_SIZE;
        var width = (0, _typedArray.readUint32At)(abuf, offset);
        offset += 4;
        var height = (0, _typedArray.readUint32At)(abuf, offset);
        offset += 4;
        var depth = (0, _typedArray.readUint8At)(abuf, offset);
        offset += 1;
        var colorType = (0, _typedArray.readUint8At)(abuf, offset);
        offset += 1;
        var compression = (0, _typedArray.readUint8At)(abuf, offset);
        offset += 1;
        var filter = (0, _typedArray.readUint8At)(abuf, offset);
        offset += 1;
        var interlace = (0, _typedArray.readUint8At)(abuf, offset);
        this._width = width;
        this._height = height;
        this._depth = depth;
        this._colorType = colorType;
        this._compression = compression;
        this._filter = filter;
        this._interlace = interlace;
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        return babelHelpers.get(IDHR.prototype.__proto__ || Object.getPrototypeOf(IDHR.prototype), "calculateChunkLength", this).call(this) + PAYLOAD_SIZE;
      }
    }, {
      key: "getMetaData",
      value: function getMetaData() {
        return {
          width: this._width,
          height: this._height,
          depth: this._depth,
          colorType: this._colorType,
          compression: this._compression,
          filter: this._filter,
          interlace: this._interlace
        };
      }
    }]);
    return IDHR;
  }(_chunk2.default);

  exports.default = IDHR;
},10040,[10022,10019,10028],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/ihdr.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _typedArray = _require(_dependencyMap[1]);

  var _pngPixels = _require(_dependencyMap[2]);

  var HEADER = 'tRNS';

  var tRNS = function (_Chunk) {
    babelHelpers.inherits(tRNS, _Chunk);

    function tRNS(options) {
      babelHelpers.classCallCheck(this, tRNS);

      var _this = babelHelpers.possibleConstructorReturn(this, (tRNS.__proto__ || Object.getPrototypeOf(tRNS)).call(this, HEADER));

      _this._colorType = options.colorType;
      _this._numberOfPixels = options.numberOfPixels;
      _this._maxNumberOfColors = options.maxNumberOfColors;
      _this._transparencies = [];
      _this._hold;

      var chunkLength = _this.calculateChunkLength();

      _this.initialize(chunkLength);

      return _this;
    }

    babelHelpers.createClass(tRNS, [{
      key: "update",
      value: function update() {
        var _this2 = this;

        var chunkLength = this.calculateChunkLength();
        var payloadSize = this.calculatePayloadSize();
        this.initialize(chunkLength);
        this.buffer.writeUint32(payloadSize);
        this.buffer.writeString8(HEADER);

        if ((0, _pngPixels.isIndexed)(this._colorType)) {
          for (var i = 0; i < this._transparencies.length; i++) {
            this.buffer.writeUint8('undefined' === typeof this._transparencies[i] ? 255 : this._transparencies[i][0]);
          }
        } else {
          this._transparencies.forEach(function (transparency) {
            transparency.forEach(function (transparencySampleValue) {
              _this2.buffer.writeUint16(transparencySampleValue);
            });
          });
        }

        var crc = this.calculateCrc32();
        this.buffer.writeUint32(crc);
      }
    }, {
      key: "load",
      value: function load(abuf) {
        var suppliedLimit = (0, _typedArray.readUint32At)(abuf, 0);
        var transparencyInfo = abuf.subarray(this.calculateDataOffset(), this.calculateDataOffset() + suppliedLimit);
        var samplesPerEntry = (0, _pngPixels.determineTransparencySamplesPerEntry)(this._colorType);

        if ((0, _pngPixels.isTruecolor)(this._colorType)) {
          for (var i = 0; i < suppliedLimit;) {
            var r = (0, _typedArray.readUint16At)(transparencyInfo, i);
            i += 2;
            var g = (0, _typedArray.readUint16At)(transparencyInfo, i);
            i += 2;
            var b = (0, _typedArray.readUint16At)(transparencyInfo, i);
            i += 2;
            this.setTransparency([r, g, b]);
          }
        } else if ((0, _pngPixels.isGrayscale)(this._colorType)) {
          for (var _i = 0, n = 0; _i < suppliedLimit; _i += samplesPerEntry, n += 1) {
            this.setTransparency([(0, _typedArray.readUint16At)(transparencyInfo, _i)]);
          }
        } else {
          for (var _i2 = 0; _i2 < suppliedLimit; _i2 += samplesPerEntry) {
            this.setTransparency([(0, _typedArray.readUint8At)(transparencyInfo, _i2)]);
          }
        }
      }
    }, {
      key: "getTransparencies",
      value: function getTransparencies() {
        if ((0, _pngPixels.isGrayscale)(this._colorType) || (0, _pngPixels.isIndexed)(this._colorType)) {
          return this._transparencies.reduce(function (acc, curr) {
            return acc.concat.apply(acc, babelHelpers.toConsumableArray(curr));
          }, []);
        }

        return this._transparencies;
      }
    }, {
      key: "getIndexOf",
      value: function getIndexOf(colorData) {
        var hashedTestData = (0, _pngPixels.hashPixelData)(colorData);

        for (var i = 0; i < this._transparencies.length; i++) {
          if (hashedTestData === (0, _pngPixels.hashPixelData)(this._transparencies[i])) {
            return i;
          }
        }

        return -1;
      }
    }, {
      key: "getValueOf",
      value: function getValueOf(index) {
        if (index >= this._numberOfPixels) {
          throw new Error('Attempting to get a transparency out of range of pixels');
        }

        return this._transparencies[index];
      }
    }, {
      key: "isTransparencySet",
      value: function isTransparencySet(colorData) {
        return this.getIndexOf(colorData) !== -1;
      }
    }, {
      key: "setTransparency",
      value: function setTransparency(colorData) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

        if (!Array.isArray(colorData)) {
          colorData = [colorData];
        }

        if ((0, _pngPixels.isIndexed)(this._colorType) && index > this._transparencies.length) {
          for (var i = this._transparencies.length; i < index; i++) {
            this._transparencies[i] = [255];
          }
        } else {
          if (index >= this._numberOfPixels) {
            throw new Error('Attempting to set a transparency out of range of pixels');
          }
        }

        if (-1 !== index) {
          this._transparencies[index] = colorData;
          return index;
        }

        this._transparencies.push(colorData);

        return this._transparencies.length - 1;
      }
    }, {
      key: "removeTransparency",
      value: function removeTransparency(colorData) {
        var index = this.getIndexOf(colorData);

        if (index !== -1) {
          this._transparencies.splice(index, 1);
        }
      }
    }, {
      key: "removeTransparencyOf",
      value: function removeTransparencyOf(index) {
        if ('undefined' === typeof this._transparencies[index]) {
          throw new Error('Attempting to remove the transparency of an element that does not exist');
        }

        this._transparencies[index] = [255];
      }
    }, {
      key: "calculatePayloadSize",
      value: function calculatePayloadSize() {
        var samplesPerEntry = (0, _pngPixels.determineTransparencySamplesPerEntry)(this._colorType);
        var spacePerSample = (0, _pngPixels.determineTransparencySpacePerSample)(this._colorType);
        return this._transparencies.length * samplesPerEntry * spacePerSample;
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        return babelHelpers.get(tRNS.prototype.__proto__ || Object.getPrototypeOf(tRNS.prototype), "calculateChunkLength", this).call(this) + this.calculatePayloadSize();
      }
    }, {
      key: "colorType",
      set: function set(value) {
        this._colorType = value;
      }
    }, {
      key: "numberOfPixels",
      set: function set(value) {
        this._numberOfPixels = value;
      }
    }, {
      key: "maxNumberOfColors",
      set: function set(value) {
        this._maxNumberOfColors = value;
      }
    }]);
    return tRNS;
  }(_chunk2.default);

  exports.default = tRNS;
},10043,[10022,10028,10034],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/trns.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _pngPixels = _require(_dependencyMap[1]);

  var _typedArray = _require(_dependencyMap[2]);

  var HEADER = 'PLTE';
  var SAMPLES_PER_ENTRY = 3;

  var PLTE = function (_Chunk) {
    babelHelpers.inherits(PLTE, _Chunk);

    function PLTE(options) {
      babelHelpers.classCallCheck(this, PLTE);

      var _this = babelHelpers.possibleConstructorReturn(this, (PLTE.__proto__ || Object.getPrototypeOf(PLTE)).call(this, HEADER));

      _this._maxNumberOfColors = options.maxNumberOfColors;
      _this._palette = {};
      return _this;
    }

    babelHelpers.createClass(PLTE, [{
      key: "update",
      value: function update() {
        var chunkLength = this.calculateChunkLength();
        var payloadSize = this.calculatePayloadSize();
        this.initialize(chunkLength);
        this.buffer.writeUint32(payloadSize);
        this.buffer.writeString8(HEADER);
        var sorted = Object.entries(this._palette).sort(function (a, b) {
          return (0, _pngPixels.unhashPixelIndexKey)(a[0]) - (0, _pngPixels.unhashPixelIndexKey)(b[0]);
        });

        for (var i = 0; i < sorted.length; i++) {
          var rgb = sorted[i][1];
          this.buffer.writeUint8(rgb[0]);
          this.buffer.writeUint8(rgb[1]);
          this.buffer.writeUint8(rgb[2]);
        }

        var crc = this.calculateCrc32();
        this.buffer.writeUint32(crc);
      }
    }, {
      key: "load",
      value: function load(abuf) {
        var colorInfo = abuf.subarray(this.calculateDataOffset(), abuf.byteLength);
        var paletteSize = (0, _typedArray.readUint32At)(abuf, 0);

        if (0 !== paletteSize % SAMPLES_PER_ENTRY) {
          throw new Error('Invalid palette size supplied for PLTE chunk');
        }

        for (var i = 0; i < paletteSize; i += SAMPLES_PER_ENTRY) {
          this.addColor([colorInfo[i], colorInfo[i + 1], colorInfo[i + 2]]);
        }

        var chunkLength = this.calculateChunkLength();
        this.initialize(chunkLength);
      }
    }, {
      key: "getPalette",
      value: function getPalette() {
        return Object.entries(this._palette).map(function (entry) {
          return [(0, _pngPixels.unhashPixelIndexKey)(entry[0]), entry[1]];
        });
      }
    }, {
      key: "isColorInPalette",
      value: function isColorInPalette(colorData) {
        return this.getPaletteIndex(colorData) !== -1;
      }
    }, {
      key: "isIndexInPalette",
      value: function isIndexInPalette(index) {
        return 'undefined' !== typeof this._palette[(0, _pngPixels.hashPixelIndexKey)(index)];
      }
    }, {
      key: "getCurrentNumberOfColors",
      value: function getCurrentNumberOfColors() {
        return Object.keys(this._palette).length;
      }
    }, {
      key: "getPaletteIndex",
      value: function getPaletteIndex(colorData) {
        var testColorKey = (0, _pngPixels.hashPixelData)(colorData);
        var paletteEntries = Object.entries(this._palette);

        for (var j = 0; j < paletteEntries.length; j++) {
          if (testColorKey === (0, _pngPixels.hashPixelData)(paletteEntries[j][1])) {
            return (0, _pngPixels.unhashPixelIndexKey)(paletteEntries[j][0]);
          }
        }

        return -1;
      }
    }, {
      key: "getColorOf",
      value: function getColorOf(index) {
        return this._palette[(0, _pngPixels.hashPixelIndexKey)(index)];
      }
    }, {
      key: "getPixelPaletteIndices",
      value: function getPixelPaletteIndices() {
        return Object.keys(this._palette).map(function (v) {
          return Number(v);
        }).sort(function (a, b) {
          return a - b;
        });
      }
    }, {
      key: "convertToPixels",
      value: function convertToPixels(paletteIndices) {
        var pixelData = new Uint8ClampedArray(paletteIndices.length * 3);
        var n = 0;

        for (var i = 0; i < paletteIndices.length; i++) {
          var paletteIndex = paletteIndices[i];
          var pixel = this.getColorOf(paletteIndex);

          if ('undefined' === typeof pixel || !Array.isArray(pixel) || 3 !== pixel.length) {
            throw new Error("Problem retrieving pixel data for palette index " + paletteIndex);
          }

          pixelData[n++] = pixel[0];
          pixelData[n++] = pixel[1];
          pixelData[n++] = pixel[2];
        }

        return pixelData;
      }
    }, {
      key: "setColorOf",
      value: function setColorOf(index, colorData) {
        var hashedIndex = (0, _pngPixels.hashPixelIndexKey)(index);

        if ('undefined' === typeof this._palette[hashedIndex] && this.getCurrentNumberOfColors() >= this._maxNumberOfColors) {
          throw new Error('Maximum number of colors reached');
        }

        this._palette[hashedIndex] = colorData;
        return index;
      }
    }, {
      key: "addColor",
      value: function addColor(colorData) {
        if (this.getCurrentNumberOfColors() >= this._maxNumberOfColors) {
          throw new Error('Maximum number of colors reached');
        }

        var index = Object.keys(this._palette).length;
        return this.setColorOf(index, colorData);
      }
    }, {
      key: "replaceColor",
      value: function replaceColor(oldColor, newColor) {
        if (!this.isColorInPalette(oldColor)) {
          throw new Error('Color to be replaced is not in palette');
        }

        var oldColorPaletteIndex = this.getPaletteIndex(oldColor);
        this._palette[(0, _pngPixels.hashPixelIndexKey)(oldColorPaletteIndex)] = newColor;
      }
    }, {
      key: "calculatePayloadSize",
      value: function calculatePayloadSize() {
        return Object.keys(this._palette).length * SAMPLES_PER_ENTRY;
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        return babelHelpers.get(PLTE.prototype.__proto__ || Object.getPrototypeOf(PLTE.prototype), "calculateChunkLength", this).call(this) + this.calculatePayloadSize();
      }
    }, {
      key: "maxNumberOfColors",
      set: function set(value) {
        this._maxNumberOfColors = value;
      }
    }]);
    return PLTE;
  }(_chunk2.default);

  exports.default = PLTE;
},10046,[10022,10034,10028],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/plte.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _typedArray = _require(_dependencyMap[1]);

  var _pngPixels = _require(_dependencyMap[2]);

  var HEADER = 'bKGD';

  var bKGD = function (_Chunk) {
    babelHelpers.inherits(bKGD, _Chunk);

    function bKGD(options) {
      babelHelpers.classCallCheck(this, bKGD);

      var _this = babelHelpers.possibleConstructorReturn(this, (bKGD.__proto__ || Object.getPrototypeOf(bKGD)).call(this, HEADER));

      _this._colorType = options.colorType;
      _this._backgroundColor = new Uint8ClampedArray((0, _pngPixels.determineBackgroundSamplesPerEntry)(_this._colorType));

      var chunkLength = _this.calculateChunkLength();

      _this.initialize(chunkLength);

      return _this;
    }

    babelHelpers.createClass(bKGD, [{
      key: "update",
      value: function update() {
        var payloadSize = this.calculatePayloadSize();
        this.buffer.writeUint32(payloadSize);
        this.buffer.writeString8(HEADER);

        if ((0, _pngPixels.isIndexed)(this._colorType)) {
          this.buffer.writeUint8(this._backgroundColor[0]);
        } else {
          for (var i = 0; i < this._backgroundColor.length; i++) {
            this.buffer.writeUint16(this._backgroundColor[i], true);
          }
        }

        var crc = this.calculateCrc32();
        this.buffer.writeUint32(crc);
      }
    }, {
      key: "load",
      value: function load(abuf) {
        var chunkLength = this.calculateChunkLength();
        this.initialize(chunkLength);
        var backgroundInfo = abuf.subarray(this.calculateDataOffset(), this.calculateDataOffset() + this.calculatePayloadSize());
        var dataOffset = this.calculateDataOffset();
        var color = [];

        if ((0, _pngPixels.isIndexed)(this._colorType)) {
          color.push((0, _typedArray.readUint8At)(backgroundInfo, dataOffset));
        } else {
          var numberOfSamples = (0, _pngPixels.determineBackgroundSamplesPerEntry)(this._colorType);

          for (var i = 0, offset = dataOffset; i < numberOfSamples; i++, offset += 2) {
            color.push((0, _typedArray.readUint16At)(backgroundInfo, dataOffset, true));
          }
        }

        this.setBackgroundColor(color);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color) {
        var requiredSamples = (0, _pngPixels.determineBackgroundSamplesPerEntry)(this._colorType);

        if (color.length !== requiredSamples) {
          throw new Error("Incorrect number of samples supplied for background (" + requiredSamples + " expected)");
        }

        for (var i = 0; i < color.length; i++) {
          this._backgroundColor[i] = color[i];
        }
      }
    }, {
      key: "getBackgroundColor",
      value: function getBackgroundColor() {
        return this._backgroundColor;
      }
    }, {
      key: "calculatePayloadSize",
      value: function calculatePayloadSize() {
        if ((0, _pngPixels.isIndexed)(this._colorType)) {
          return 1;
        } else {
          return (0, _pngPixels.determineBackgroundSamplesPerEntry)(this._colorType) * 2;
        }
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        return babelHelpers.get(bKGD.prototype.__proto__ || Object.getPrototypeOf(bKGD.prototype), "calculateChunkLength", this).call(this) + this.calculatePayloadSize();
      }
    }, {
      key: "colorType",
      set: function set(value) {
        this._colorType = value;
      }
    }]);
    return bKGD;
  }(_chunk2.default);

  exports.default = bKGD;
},10049,[10022,10028,10034],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/bkgd.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _constants = _require(_dependencyMap[1]);

  var _pngPixels = _require(_dependencyMap[2]);

  var _typedArray = _require(_dependencyMap[3]);

  var _compressDecompress = _require(_dependencyMap[4]);

  var HEADER = 'IDAT';
  var DEFLATE_BLOCKS_SIZE = 2;
  var ZLIB_HEADER_SIZE = 5;
  var ADLER_CHECKSUM_SIZE = 4;

  var IDAT = function (_Chunk) {
    babelHelpers.inherits(IDAT, _Chunk);

    function IDAT(options) {
      babelHelpers.classCallCheck(this, IDAT);

      var _this = babelHelpers.possibleConstructorReturn(this, (IDAT.__proto__ || Object.getPrototypeOf(IDAT)).call(this, HEADER));

      _this.applyLayoutInformation({
        width: options.width,
        height: options.height,
        depth: options.depth,
        colorType: options.colorType,
        numberOfPixels: options.numberOfPixels
      });

      _this._zlibLib = null;

      _this._initializePixelData();

      _this._should;
      _this._hold;
      return _this;
    }

    babelHelpers.createClass(IDAT, [{
      key: "getData",
      value: function getData(pixelLayout, pixelData, trnsData) {
        if (_constants.PixelLayouts.INDEX_VALUE === pixelLayout) {
          if ((0, _pngPixels.isIndexed)(this._colorType)) {
            throw new Error('Attempt to get palette indices from a non-indexed image');
          } else {
            return pixelData;
          }
        }

        if (_constants.PixelLayouts.RGB === pixelLayout || _constants.PixelLayouts.RGBA === pixelLayout) {
          return (0, _pngPixels.formatPixels)(this._colorType, this._width, this._height, pixelLayout, pixelData, trnsData);
        }

        return pixelData;
      }
    }, {
      key: "applyLayoutInformation",
      value: function applyLayoutInformation(info) {
        this._width = info.width;
        this._height = info.height;
        this._depth = info.depth;
        this._colorType = info.colorType;
        this._numberOfPixels = info.numberOfPixels;
        this._pixelColorSize = (0, _pngPixels.determinePixelColorSize)(this._colorType);
        this._hasAlphaSample = (0, _pngPixels.hasAlphaSample)(this._colorType);
      }
    }, {
      key: "update",
      value: function update() {
        var packedPixelData = (0, _typedArray.packByteData)(this._pixelData, this._depth, !(0, _pngPixels.isIndexed)(this._colorType));
        var dataRowLength = (0, _pngPixels.determineDataRowLength)(this._depth, this._colorType, this._width);
        var pixelAndFilterData = (0, _compressDecompress.addFilterFields)(packedPixelData, dataRowLength, this._height);

        var compressedPixelAndFilterData = this._zlibLib.deflate(pixelAndFilterData);

        var chunkLength = this.calculateChunkLength(compressedPixelAndFilterData.length);
        var payloadSize = compressedPixelAndFilterData.length;
        this.initialize(chunkLength);
        this.buffer.writeUint32(payloadSize);
        this.buffer.writeString8(HEADER);
        this.buffer.copyFrom(compressedPixelAndFilterData);
        var crc = this.calculateCrc32(chunkLength);
        this.buffer.writeUint32At(chunkLength - _chunk.CHUNK_CRC32_SIZE, crc);
      }
    }, {
      key: "load",
      value: function load(abuf) {
        var chunkLength = this.calculateChunkLength();
        this.initialize(chunkLength);
        var payloadSize = (0, _typedArray.readUint32At)(abuf, 0);
        var dataOffset = this.calculateDataOffset();
        var compressedZlibData = abuf.subarray(dataOffset, dataOffset + payloadSize);

        var uncompressedData = this._zlibLib.inflate(compressedZlibData);

        var dataRowLength = (0, _pngPixels.determineDataRowLength)(this._depth, this._colorType, this._width);
        var bytesPerPixel = (0, _pngPixels.determineBytesPerPixel)(this._depth, this._colorType);
        (0, _compressDecompress.defilter)(uncompressedData, dataRowLength, bytesPerPixel);
        var pixelOnlyData = (0, _compressDecompress.removeFilterFields)(uncompressedData, dataRowLength, this._height);
        this._pixelData = (0, _typedArray.unpackByteData)(pixelOnlyData, this._depth, !(0, _pngPixels.isIndexed)(this._colorType));
      }
    }, {
      key: "setPixelOf",
      value: function setPixelOf(index, pixel) {
        if (Array.isArray(pixel)) {
          this._setSamples(index, pixel);

          return this;
        }

        this._setSingleValuePixel(index, pixel);
      }
    }, {
      key: "setAlpha",
      value: function setAlpha(index, value) {
        if (!(0, _pngPixels.isGrayscaleWithAlpha)(this._colorType) && !(0, _pngPixels.isTruecolorWithAlpha)(this._colorType)) {
          return;
        }

        this._setAlpha(index, value);
      }
    }, {
      key: "verify",
      value: function verify(bufView) {
        return (0, _typedArray.indexOfSequence)(bufView, _constants.ChunkHeaderSequences[HEADER]) !== -1;
      }
    }, {
      key: "applyZlibLib",
      value: function applyZlibLib(lib) {
        this._zlibLib = lib;
      }
    }, {
      key: "getValueOf",
      value: function getValueOf(index) {
        return this._pixelData[index];
      }
    }, {
      key: "getPixelOf",
      value: function getPixelOf(index) {
        if ((0, _pngPixels.isGrayscale)(this._colorType) || (0, _pngPixels.isIndexed)(this._colorType)) {
          return [this.getValueOf(index)];
        }

        var fullPixelSize = (0, _pngPixels.determineFullPixelSize)(this._colorType);

        if (index + fullPixelSize >= this._pixelData.length) {
          throw new Error('Trying to get a value beyond the range of pixel data');
        }

        var pixelData = [];

        for (var i = 0; i < fullPixelSize; i++) {
          pixelData.push(this.getValueOf(index + i));
        }

        return pixelData;
      }
    }, {
      key: "calculateDataSize",
      value: function calculateDataSize() {
        var fullPixelSize = (0, _pngPixels.determineFullPixelSize)(this._colorType);
        return this._width * fullPixelSize * this._height;
      }
    }, {
      key: "calculatePixelAndFilterSize",
      value: function calculatePixelAndFilterSize() {
        return this.calculateDataSize() + this._height;
      }
    }, {
      key: "calculatePayloadSize",
      value: function calculatePayloadSize() {
        var pixelAndFilterSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

        if (pixelAndFilterSize === -1) {
          pixelAndFilterSize = this.calculatePixelAndFilterSize();
        }

        return DEFLATE_BLOCKS_SIZE + pixelAndFilterSize + ZLIB_HEADER_SIZE * Math.floor((0xfffe + pixelAndFilterSize) / 0xffff) + ADLER_CHECKSUM_SIZE;
      }
    }, {
      key: "calculateChunkLength",
      value: function calculateChunkLength() {
        var payloadSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

        if (payloadSize === -1) {
          payloadSize = this.calculatePayloadSize();
        }

        return babelHelpers.get(IDAT.prototype.__proto__ || Object.getPrototypeOf(IDAT.prototype), "calculateChunkLength", this).call(this) + payloadSize;
      }
    }, {
      key: "_initializePixelData",
      value: function _initializePixelData() {
        this._pixelData = new Uint8ClampedArray(this.calculateDataSize());
      }
    }, {
      key: "_setSingleValuePixel",
      value: function _setSingleValuePixel(index, value) {
        this._pixelData[index] = value;
      }
    }, {
      key: "_setAlpha",
      value: function _setAlpha(index, value) {
        this._pixelData[index + 3] = value;
      }
    }, {
      key: "_setSamples",
      value: function _setSamples(startIndex, value) {
        var _this2 = this;

        value.forEach(function (sample, sampleIndex) {
          _this2._pixelData[startIndex + sampleIndex] = sample;
        });
      }
    }, {
      key: "pixelData",
      get: function get() {
        return this._pixelData;
      }
    }, {
      key: "width",
      set: function set(value) {
        this._width = value;
      }
    }, {
      key: "height",
      set: function set(value) {
        this._height = value;
      }
    }, {
      key: "colorType",
      set: function set(value) {
        this._colorType = value;
      }
    }, {
      key: "numberOfPixels",
      set: function set(value) {
        this._numberOfPixels = value;
      }
    }]);
    return IDAT;
  }(_chunk2.default);

  exports.default = IDAT;
},10052,[10022,10019,10034,10028,10055],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/idat.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var defilterSub = function defilterSub(rowData, bytesPerPixel) {
    bytesPerPixel = bytesPerPixel < 1 ? 1 : bytesPerPixel;
    var rowSize = rowData.byteLength;

    for (var i = bytesPerPixel; i < rowSize; i++) {
      rowData[i] = rowData[i] + rowData[i - bytesPerPixel] & 255;
    }
  };

  var defilterUp = function defilterUp(rowData, previousRowData) {
    var rowSize = rowData.byteLength;

    for (var i = 0; i < rowSize; i++) {
      rowData[i] = rowData[i] + previousRowData[i] & 255;
    }
  };

  var defilterAverage = function defilterAverage(rowData, bytesPerPixel, previousRowData) {
    bytesPerPixel = bytesPerPixel < 1 ? 1 : bytesPerPixel;
    var rowSize = rowData.byteLength;

    for (var i = bytesPerPixel; i < rowSize; i++) {
      rowData[i] = Math.floor((rowData[i - bytesPerPixel] + previousRowData[i]) / 2) & 255;
    }
  };

  var computePaeth = function computePaeth(left, above, aboveLeft) {
    var initial = left + above - aboveLeft;
    var deltaLeft = Math.abs(initial - left);
    var deltaAbove = Math.abs(initial - above);
    var deltaAboveLeft = Math.abs(initial - aboveLeft);

    if (deltaLeft <= deltaAbove && deltaLeft <= deltaAboveLeft) {
      return left;
    }

    if (deltaAbove <= deltaAboveLeft) {
      return above;
    }

    return aboveLeft;
  };

  var defilterPaeth = function defilterPaeth(rowData, bytesPerPixel, previousRowData) {
    bytesPerPixel = bytesPerPixel < 1 ? 1 : bytesPerPixel;
    var rowSize = rowData.byteLength;
    var previousPixelIndex = void 0;
    var left = void 0;
    var above = void 0;
    var aboveLeft = void 0;

    for (var i = 0; i < rowSize; i++) {
      previousPixelIndex = i - bytesPerPixel;

      if (previousPixelIndex < 0) {
        left = 0;
        aboveLeft = 0;
      } else {
        left = rowData[previousPixelIndex];
        aboveLeft = typeof previousRowData === 'undefined' ? 0 : previousRowData[previousPixelIndex];
      }

      above = typeof previousRowData === 'undefined' ? 0 : previousRowData[i];
      rowData[i] = rowData[i] + computePaeth(left, above, aboveLeft) & 255;
    }
  };

  var defilter = exports.defilter = function defilter(imageAndFilterData, dataRowLength, bytesPerPixel) {
    var rowSize = dataRowLength + 1;
    var filter = void 0;
    var scanLine = void 0;
    var previousRow = void 0;
    var firstDataByteIndex = void 0;

    for (var i = 0, n = imageAndFilterData.byteLength; i < n; i += rowSize) {
      filter = imageAndFilterData[i];
      firstDataByteIndex = i + 1;
      scanLine = imageAndFilterData.subarray(firstDataByteIndex, firstDataByteIndex + rowSize - 1);

      if (filter === 1) {
        defilterSub(scanLine, bytesPerPixel);
      }

      if (filter === 2) {
        defilterUp(scanLine, previousRow, i);
      }

      if (filter === 3) {
        defilterAverage(scanLine, bytesPerPixel, previousRow);
      }

      if (filter === 4) {
        defilterPaeth(scanLine, bytesPerPixel, previousRow);
      }

      imageAndFilterData[i] = 0;
      previousRow = scanLine.slice(0);
    }
  };

  var removeFilterFields = exports.removeFilterFields = function removeFilterFields(pixelAndFilterData, dataRowSize, height) {
    var scanlineStep = dataRowSize + 1;
    var pixelOnlyData = new Uint8ClampedArray(pixelAndFilterData.length - height);

    for (var i = 0, n = 0; i < pixelAndFilterData.length; i += scanlineStep, n += dataRowSize) {
      var currentIndex = i + 1;
      var s = pixelAndFilterData.subarray(currentIndex, currentIndex + dataRowSize);
      pixelOnlyData.set(s, n);
    }

    return pixelOnlyData;
  };

  var addFilterFields = exports.addFilterFields = function addFilterFields(pixelOnlyData, dataRowSize, height) {
    var scanlineStep = dataRowSize + 1;
    var pixelAndFilterData = new Uint8ClampedArray(pixelOnlyData.length + height);

    for (var i = 0, n = 0, x = 0; x < height; i += dataRowSize, n += scanlineStep, x++) {
      var t = pixelOnlyData.subarray(i, i + dataRowSize);
      var s = [0].concat(babelHelpers.toConsumableArray(t));
      pixelAndFilterData.set(s, n);
    }

    return pixelAndFilterData;
  };
},10055,[],"projects/com.dreame.devices/main/DreameUtil/pngjs/util/compress-decompress.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _chunk = _require(_dependencyMap[0]);

  var _chunk2 = babelHelpers.interopRequireDefault(_chunk);

  var _constants = _require(_dependencyMap[1]);

  var _typedArray = _require(_dependencyMap[2]);

  var HEADER = 'IEND';
  var PAYLOAD_SIZE = 0;

  var IEND = function (_Chunk) {
    babelHelpers.inherits(IEND, _Chunk);

    function IEND() {
      babelHelpers.classCallCheck(this, IEND);

      var _this = babelHelpers.possibleConstructorReturn(this, (IEND.__proto__ || Object.getPrototypeOf(IEND)).call(this, HEADER));

      var chunkLength = _this.calculateChunkLength();

      _this.initialize(chunkLength);

      return _this;
    }

    babelHelpers.createClass(IEND, [{
      key: "update",
      value: function update() {
        this.buffer.writeUint32(PAYLOAD_SIZE);
        this.buffer.writeString8(HEADER);
        this.buffer.writeUint32(this.calculateCrc32());
      }
    }, {
      key: "verify",
      value: function verify(bufView) {
        return (0, _typedArray.indexOfSequence)(bufView, _constants.ChunkHeaderSequences[HEADER], bufView.byteLength - this.calculateChunkLength() + _chunk.CHUNK_LENGTH_SIZE) !== -1;
      }
    }]);
    return IEND;
  }(_chunk2.default);

  exports.default = IEND;
},10058,[10022,10019,10028],"projects/com.dreame.devices/main/DreameUtil/pngjs/chunks/iend.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    /**
     * @license (c) Franz X Antesberger 2013
     */(function (exporter) {
        'use strict';

        var POW_2_32 = 0x0100000000;
        var POW_2_52 = 0x10000000000000;

        exporter.fromBytesBigEndian = function (highByte, secondHighByte, thirdHighByte, lowByte) {
            return (highByte << 24 | secondHighByte << 16 | thirdHighByte << 8 | lowByte) >>> 0;
        };

        exporter.getByteBigEndian = function (uint32value, byteNo) {
            return uint32value >>> 8 * (3 - byteNo) & 0xff;
        };

        exporter.getBytesBigEndian = function (uint32value) {
            return [exporter.getByteBigEndian(uint32value, 0), exporter.getByteBigEndian(uint32value, 1), exporter.getByteBigEndian(uint32value, 2), exporter.getByteBigEndian(uint32value, 3)];
        };

        exporter.toHex = function (uint32value, optionalMinLength) {
            optionalMinLength = optionalMinLength || 8;
            var result = uint32value.toString(16);

            if (result.length < optionalMinLength) {
                result = new Array(optionalMinLength - result.length + 1).join('0') + result;
            }

            return result;
        };

        exporter.toUint32 = function (number) {
            return number >>> 0;
        };

        exporter.highPart = function (number) {
            return exporter.toUint32(number / POW_2_32);
        };

        exporter.or = function (uint32val0, argv) {
            var result = uint32val0;

            for (var index = 1; index < arguments.length; index += 1) {
                result = result | arguments[index];
            }

            return result >>> 0;
        };

        exporter.and = function (uint32val0, argv) {
            var result = uint32val0;

            for (var index = 1; index < arguments.length; index += 1) {
                result = result & arguments[index];
            }

            return result >>> 0;
        };

        exporter.xor = function (uint32val0, argv) {
            var result = uint32val0;

            for (var index = 1; index < arguments.length; index += 1) {
                result = result ^ arguments[index];
            }

            return result >>> 0;
        };

        exporter.not = function (uint32val) {
            return ~uint32val >>> 0;
        };

        exporter.shiftLeft = function (uint32val, numBits) {
            return uint32val << numBits >>> 0;
        };

        exporter.shiftRight = function (uint32val, numBits) {
            return uint32val >>> numBits;
        };

        exporter.rotateLeft = function (uint32val, numBits) {
            return (uint32val << numBits >>> 0 | uint32val >>> 32 - numBits) >>> 0;
        };

        exporter.rotateRight = function (uint32val, numBits) {
            return (uint32val >>> numBits | uint32val << 32 - numBits >>> 0) >>> 0;
        };

        exporter.choose = function (x, y, z) {
            return (x & (y ^ z) ^ z) >>> 0;
        };

        exporter.majority = function (x, y, z) {
            return (x & (y | z) | y & z) >>> 0;
        };

        exporter.addMod32 = function (uint32val0) {
            var result = uint32val0;

            for (var index = 1; index < arguments.length; index += 1) {
                result += arguments[index];
            }

            return result >>> 0;
        };

        exporter.log2 = function (uint32val) {
            return Math.floor(Math.log(uint32val) / Math.LN2);
        };

        exporter.mult = function (factor1, factor2, resultUint32Array2) {
            var high16 = ((factor1 & 0xffff0000) >>> 0) * factor2;
            var low16 = (factor1 & 0x0000ffff) * factor2;
            var carry = exporter.toUint32(high16) + exporter.toUint32(low16) >= POW_2_32 ? 1 : 0;
            resultUint32Array2[0] = exporter.highPart(high16) + exporter.highPart(low16) + carry >>> 0;
            resultUint32Array2[1] = (high16 >>> 0) + (low16 >>> 0);
        };
    })(typeof module !== 'undefined' ? module.exports = {} : window.uint32 = {});
},10061,[],"projects/com.dreame.devices/main/DreameUtil/pngjs/uint32.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var assign = _require(_dependencyMap[0]).assign;

  var deflate = _require(_dependencyMap[1]);

  var inflate = _require(_dependencyMap[2]);

  var constants = _require(_dependencyMap[3]);

  var pako = {};
  assign(pako, deflate, inflate, constants);
  module.exports = pako;
},10064,[10067,10070,10094,10106],"projects/com.dreame.devices/node_modules/pako/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  exports.assign = function (obj) {
    var sources = Array.prototype.slice.call(arguments, 1);

    while (sources.length) {
      var source = sources.shift();

      if (!source) {
        continue;
      }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  };

  exports.shrinkBuf = function (buf, size) {
    if (buf.length === size) {
      return buf;
    }

    if (buf.subarray) {
      return buf.subarray(0, size);
    }

    buf.length = size;
    return buf;
  };

  var fnTyped = {
    arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }

      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function flattenChunks(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;

      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }

      result = new Uint8Array(len);
      pos = 0;

      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }

      return result;
    }
  };
  var fnUntyped = {
    arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function flattenChunks(chunks) {
      return [].concat.apply([], chunks);
    }
  };

  exports.setTyped = function (on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };

  exports.setTyped(TYPED_OK);
},10067,[],"projects/com.dreame.devices/node_modules/pako/lib/utils/common.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var zlib_deflate = _require(_dependencyMap[0]);

  var utils = _require(_dependencyMap[1]);

  var strings = _require(_dependencyMap[2]);

  var msg = _require(_dependencyMap[3]);

  var ZStream = _require(_dependencyMap[4]);

  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;

  function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ''
    }, options || {});
    var opt = this.options;

    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }

    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }

    if (opt.dictionary) {
      var dict;

      if (typeof opt.dictionary === 'string') {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }

      status = zlib_deflate.deflateSetDictionary(this.strm, dict);

      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }

      this._dict_set = true;
    }
  }

  Deflate.prototype.push = function (data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;

    var status, _mode;

    if (this.ended) {
      return false;
    }

    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;

    if (typeof data === 'string') {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      status = zlib_deflate.deflate(strm, _mode);

      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }

      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === 'string') {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }

    return true;
  };

  Deflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };

  Deflate.prototype.onEnd = function (status) {
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }

    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };

  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);

    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }

    return deflator.result;
  }

  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }

  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }

  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
},10070,[10073,10067,10088,10085,10091],"projects/com.dreame.devices/node_modules/pako/lib/deflate.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var utils = _require(_dependencyMap[0]);

  var trees = _require(_dependencyMap[1]);

  var adler32 = _require(_dependencyMap[2]);

  var crc32 = _require(_dependencyMap[3]);

  var msg = _require(_dependencyMap[4]);

  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 0x20;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 0x03;

  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }

  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }

  function zero(buf) {
    var len = buf.length;

    while (--len >= 0) {
      buf[len] = 0;
    }
  }

  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;

    if (len > strm.avail_out) {
      len = strm.avail_out;
    }

    if (len === 0) {
      return;
    }

    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;

    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }

  function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

    s.block_start = s.strstart;
    flush_pending(s.strm);
  }

  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }

  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 0xff;
    s.pending_buf[s.pending++] = b & 0xff;
  }

  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;

    if (len > size) {
      len = size;
    }

    if (len === 0) {
      return 0;
    }

    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);

    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }

    strm.next_in += len;
    strm.total_in += len;
    return len;
  }

  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];

    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }

    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }

    do {
      match = cur_match;

      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }

      scan += 2;
      match++;

      do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;

      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;

        if (len >= nice_match) {
          break;
        }

        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

    if (best_len <= s.lookahead) {
      return best_len;
    }

    return s.lookahead;
  }

  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;

    do {
      more = s.window_size - s.lookahead - s.strstart;

      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;

        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);

        n = _w_size;
        p = n;

        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);

        more += _w_size;
      }

      if (s.strm.avail_in === 0) {
        break;
      }

      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;

      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;

        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;

          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }

  function deflate_stored(s, flush) {
    var max_block_size = 0xffff;

    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }

    for (;;) {
      if (s.lookahead <= 1) {
        fill_window(s);

        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
      }

      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;

      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }

      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }

    s.insert = 0;

    if (flush === Z_FINISH) {
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }

      return BS_FINISH_DONE;
    }

    if (s.strstart > s.block_start) {
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }

    return BS_NEED_MORE;
  }

  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;

    for (;;) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);

        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
      }

      hash_head = 0;

      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }

      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }

      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;

        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;

          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);

          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }

      if (bflush) {
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }

    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

    if (flush === Z_FINISH) {
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }

      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }

    return BS_BLOCK_DONE;
  }

  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;

    for (;;) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);

        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
      }

      hash_head = 0;

      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }

      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;

      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);

          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }

      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;

        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);

        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;

        if (bflush) {
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

        if (bflush) {
          flush_block_only(s, false);
        }

        s.strstart++;
        s.lookahead--;

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }

    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }

    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

    if (flush === Z_FINISH) {
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }

      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }

    return BS_BLOCK_DONE;
  }

  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;

    for (;;) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);

        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        if (s.lookahead === 0) {
          break;
        }
      }

      s.match_length = 0;

      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];

        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;

          do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

          s.match_length = MAX_MATCH - (strend - scan);

          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }

      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }

      if (bflush) {
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }

    s.insert = 0;

    if (flush === Z_FINISH) {
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }

      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }

    return BS_BLOCK_DONE;
  }

  function deflate_huff(s, flush) {
    var bflush;

    for (;;) {
      if (s.lookahead === 0) {
        fill_window(s);

        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }

          break;
        }
      }

      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;

      if (bflush) {
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }

    s.insert = 0;

    if (flush === Z_FINISH) {
      flush_block_only(s, true);

      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }

      return BS_FINISH_DONE;
    }

    if (s.last_lit) {
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }

    return BS_BLOCK_DONE;
  }

  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }

  var configuration_table;
  configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];

  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }

  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }

  function deflateResetKeep(strm) {
    var s;

    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }

    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;

    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }

    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;

    trees._tr_init(s);

    return Z_OK;
  }

  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);

    if (ret === Z_OK) {
      lm_init(strm.state);
    }

    return ret;
  }

  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }

    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }

    strm.state.gzhead = head;
    return Z_OK;
  }

  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }

    var wrap = 1;

    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }

    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }

    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }

    if (windowBits === 8) {
      windowBits = 9;
    }

    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = 3 * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }

  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }

  function deflate(strm, flush) {
    var old_flush, s;
    var beg, val;

    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }

    s = strm.state;

    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }

    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;

    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);

        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 0xff);
          put_byte(s, s.gzhead.time >> 8 & 0xff);
          put_byte(s, s.gzhead.time >> 16 & 0xff);
          put_byte(s, s.gzhead.time >> 24 & 0xff);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 0xff);

          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 0xff);
            put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
          }

          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }

          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;

          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }

          header |= level_flags << 6;

          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }

          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);

          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }

          strm.adler = 1;
        }
    }

    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
          beg = s.pending;

          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }

              flush_pending(strm);
              beg = s.pending;

              if (s.pending === s.pending_buf_size) {
                break;
              }
            }

            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }

          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
        s.status = NAME_STATE;
      }
    }

    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
          beg = s.pending;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }

              flush_pending(strm);
              beg = s.pending;

              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }

            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }

            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }

          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
        s.status = COMMENT_STATE;
      }
    }

    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
          beg = s.pending;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }

              flush_pending(strm);
              beg = s.pending;

              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }

            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }

            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }

          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
        s.status = HCRC_STATE;
      }
    }

    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }

        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 0xff);
          put_byte(s, strm.adler >> 8 & 0xff);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }

    if (s.pending !== 0) {
      flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }

    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }

    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }

      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }

        return Z_OK;
      }

      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);

          if (flush === Z_FULL_FLUSH) {
            zero(s.head);

            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }

        flush_pending(strm);

        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }

    if (flush !== Z_FINISH) {
      return Z_OK;
    }

    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }

    if (s.wrap === 2) {
      put_byte(s, strm.adler & 0xff);
      put_byte(s, strm.adler >> 8 & 0xff);
      put_byte(s, strm.adler >> 16 & 0xff);
      put_byte(s, strm.adler >> 24 & 0xff);
      put_byte(s, strm.total_in & 0xff);
      put_byte(s, strm.total_in >> 8 & 0xff);
      put_byte(s, strm.total_in >> 16 & 0xff);
      put_byte(s, strm.total_in >> 24 & 0xff);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }

    flush_pending(strm);

    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }

    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }

  function deflateEnd(strm) {
    var status;

    if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }

    status = strm.state.status;

    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }

    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }

  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;

    if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }

    s = strm.state;
    wrap = s.wrap;

    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }

    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }

    s.wrap = 0;

    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }

      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }

    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);

    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);

      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);

      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }

    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }

  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = 'pako deflate (from Nodeca project)';
},10073,[10067,10076,10079,10082,10085],"projects/com.dreame.devices/node_modules/pako/lib/zlib/deflate.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var utils = _require(_dependencyMap[0]);

  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;

  function zero(buf) {
    var len = buf.length;

    while (--len >= 0) {
      buf[len] = 0;
    }
  }

  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);

  var _dist_code = new Array(DIST_CODE_LEN);

  zero(_dist_code);

  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);

  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }

  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;

  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }

  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }

  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 0xff;
    s.pending_buf[s.pending++] = w >>> 8 & 0xff;
  }

  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 0xffff;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 0xffff;
      s.bi_valid += length;
    }
  }

  function send_code(s, c, tree) {
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }

  function bi_reverse(code, len) {
    var res = 0;

    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);

    return res >>> 1;
  }

  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 0xff;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }

  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;

    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }

    tree[s.heap[s.heap_max] * 2 + 1] = 0;

    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;

      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }

      tree[n * 2 + 1] = bits;

      if (n > max_code) {
        continue;
      }

      s.bl_count[bits]++;
      xbits = 0;

      if (n >= base) {
        xbits = extra[n - base];
      }

      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);

      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }

    if (overflow === 0) {
      return;
    }

    do {
      bits = max_length - 1;

      while (s.bl_count[bits] === 0) {
        bits--;
      }

      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);

    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];

      while (n !== 0) {
        m = s.heap[--h];

        if (m > max_code) {
          continue;
        }

        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }

        n--;
      }
    }
  }

  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;

    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }

    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];

      if (len === 0) {
        continue;
      }

      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }

  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;

    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;

      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }

    _length_code[length - 1] = code;
    dist = 0;

    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;

      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }

    dist >>= 7;

    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;

      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }

    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }

    n = 0;

    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }

    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }

    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }

    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }

    gen_codes(static_ltree, L_CODES + 1, bl_count);

    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }

    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }

  function init_block(s) {
    var n;

    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }

    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }

    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }

    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }

  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }

    s.bi_buf = 0;
    s.bi_valid = 0;
  }

  function copy_block(s, buf, len, header) {
    bi_windup(s);

    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }

    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }

  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;

    var _m2 = m * 2;

    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }

  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;

    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }

      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }

      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }

    s.heap[k] = v;
  }

  function compress_block(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;

    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;

        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];

          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }

          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];

          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }

    send_code(s, END_BLOCK, ltree);
  }

  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }

    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;

      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }

    desc.max_code = max_code;

    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }

    node = elems;

    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);

    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }

  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }

    tree[(max_code + 1) * 2 + 1] = 0xffff;

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];

      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }

        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }

      count = 0;
      prevlen = curlen;

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }

  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];

      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }

        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }

      count = 0;
      prevlen = curlen;

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }

  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);

    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }

    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }

  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);

    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }

    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }

  function detect_data_type(s) {
    var black_mask = 0xf3ffc07f;
    var n;

    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }

    if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0) {
      return Z_TEXT;
    }

    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }

    return Z_BINARY;
  }

  var static_init_done = false;

  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }

    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }

  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  }

  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }

  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;

    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }

      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;

      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }

    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }

    init_block(s);

    if (last) {
      bi_windup(s);
    }
  }

  function _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
    s.last_lit++;

    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }

    return s.last_lit === s.lit_bufsize - 1;
  }

  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
},10076,[10067],"projects/com.dreame.devices/node_modules/pako/lib/zlib/trees.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  function adler32(adler, buf, len, pos) {
    var s1 = adler & 0xffff | 0,
        s2 = adler >>> 16 & 0xffff | 0,
        n = 0;

    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return s1 | s2 << 16 | 0;
  }

  module.exports = adler32;
},10079,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/adler32.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
      c = n;

      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
      }

      table[n] = c;
    }

    return table;
  }

  var crcTable = makeTable();

  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;
    crc ^= -1;

    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1;
  }

  module.exports = crc32;
},10082,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/crc32.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    2: 'need dictionary',
    1: 'stream end',
    0: '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version'
  };
},10085,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/messages.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var utils = _require(_dependencyMap[0]);

  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;

  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }

  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }

  var _utf8len = new utils.Buf8(256);

  for (var q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }

  _utf8len[254] = _utf8len[254] = 1;

  exports.string2buf = function (str) {
    var buf,
        c,
        c2,
        m_pos,
        i,
        str_len = str.length,
        buf_len = 0;

    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);

      if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);

        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }

      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    buf = new utils.Buf8(buf_len);

    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);

      if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);

        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }

      if (c < 0x80) {
        buf[i++] = c;
      } else if (c < 0x800) {
        buf[i++] = 0xC0 | c >>> 6;
        buf[i++] = 0x80 | c & 0x3f;
      } else if (c < 0x10000) {
        buf[i++] = 0xE0 | c >>> 12;
        buf[i++] = 0x80 | c >>> 6 & 0x3f;
        buf[i++] = 0x80 | c & 0x3f;
      } else {
        buf[i++] = 0xf0 | c >>> 18;
        buf[i++] = 0x80 | c >>> 12 & 0x3f;
        buf[i++] = 0x80 | c >>> 6 & 0x3f;
        buf[i++] = 0x80 | c & 0x3f;
      }
    }

    return buf;
  };

  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
      }
    }

    var result = '';

    for (var i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }

    return result;
  }

  exports.buf2binstring = function (buf) {
    return buf2binstring(buf, buf.length);
  };

  exports.binstring2buf = function (str) {
    var buf = new utils.Buf8(str.length);

    for (var i = 0, len = buf.length; i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }

    return buf;
  };

  exports.buf2string = function (buf, max) {
    var i, out, c, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
      c = buf[i++];

      if (c < 0x80) {
        utf16buf[out++] = c;
        continue;
      }

      c_len = _utf8len[c];

      if (c_len > 4) {
        utf16buf[out++] = 0xfffd;
        i += c_len - 1;
        continue;
      }

      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;

      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 0x3f;
        c_len--;
      }

      if (c_len > 1) {
        utf16buf[out++] = 0xfffd;
        continue;
      }

      if (c < 0x10000) {
        utf16buf[out++] = c;
      } else {
        c -= 0x10000;
        utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
        utf16buf[out++] = 0xdc00 | c & 0x3ff;
      }
    }

    return buf2binstring(utf16buf, out);
  };

  exports.utf8border = function (buf, max) {
    var pos;
    max = max || buf.length;

    if (max > buf.length) {
      max = buf.length;
    }

    pos = max - 1;

    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
      pos--;
    }

    if (pos < 0) {
      return max;
    }

    if (pos === 0) {
      return max;
    }

    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
},10088,[10067],"projects/com.dreame.devices/node_modules/pako/lib/utils/strings.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = '';
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }

  module.exports = ZStream;
},10091,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/zstream.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var zlib_inflate = _require(_dependencyMap[0]);

  var utils = _require(_dependencyMap[1]);

  var strings = _require(_dependencyMap[2]);

  var c = _require(_dependencyMap[3]);

  var msg = _require(_dependencyMap[4]);

  var ZStream = _require(_dependencyMap[5]);

  var GZheader = _require(_dependencyMap[6]);

  var toString = Object.prototype.toString;

  function Inflate(options) {
    if (!(this instanceof Inflate)) return new Inflate(options);
    this.options = utils.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ''
    }, options || {});
    var opt = this.options;

    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;

      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }

    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }

    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }

    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }

    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);

    if (opt.dictionary) {
      if (typeof opt.dictionary === 'string') {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }

      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);

        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }

  Inflate.prototype.push = function (data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;

    var status, _mode;

    var next_out_utf8, tail, utf8str;
    var allowBufError = false;

    if (this.ended) {
      return false;
    }

    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;

    if (typeof data === 'string') {
      strm.input = strings.binstring2buf(data);
    } else if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);

      if (status === c.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }

      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }

      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }

      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === 'string') {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;

            if (tail) {
              utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }

            this.onData(utf8str);
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }

      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }

    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }

    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }

    return true;
  };

  Inflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };

  Inflate.prototype.onEnd = function (status) {
    if (status === c.Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }

    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };

  function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);

    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }

    return inflator.result;
  }

  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }

  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
},10094,[10097,10067,10088,10106,10085,10091,10109],"projects/com.dreame.devices/node_modules/pako/lib/inflate.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var utils = _require(_dependencyMap[0]);

  var adler32 = _require(_dependencyMap[1]);

  var crc32 = _require(_dependencyMap[2]);

  var inflate_fast = _require(_dependencyMap[3]);

  var inflate_table = _require(_dependencyMap[4]);

  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;

  function zswap32(q) {
    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
  }

  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }

  function inflateResetKeep(strm) {
    var state;

    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }

    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = '';

    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }

    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }

  function inflateReset(strm) {
    var state;

    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }

    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }

  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;

    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }

    state = strm.state;

    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;

      if (windowBits < 48) {
        windowBits &= 15;
      }
    }

    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }

    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }

    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }

  function inflateInit2(strm, windowBits) {
    var ret;
    var state;

    if (!strm) {
      return Z_STREAM_ERROR;
    }

    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);

    if (ret !== Z_OK) {
      strm.state = null;
    }

    return ret;
  }

  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }

  var virgin = true;
  var lenfix, distfix;

  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;

      while (sym < 144) {
        state.lens[sym++] = 8;
      }

      while (sym < 256) {
        state.lens[sym++] = 9;
      }

      while (sym < 280) {
        state.lens[sym++] = 7;
      }

      while (sym < 288) {
        state.lens[sym++] = 8;
      }

      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
        bits: 9
      });
      sym = 0;

      while (sym < 32) {
        state.lens[sym++] = 5;
      }

      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
        bits: 5
      });
      virgin = false;
    }

    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }

  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;

    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }

    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;

      if (dist > copy) {
        dist = copy;
      }

      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;

      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;

        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }

        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }

    return 0;
  }

  function inflate(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;

    var _in, _out;

    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }

    state = strm.state;

    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }

    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;

    inf_leave: for (;;) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }

          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          if (state.wrap & 2 && hold === 0x8b1f) {
            state.check = 0;
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }

          state.flags = 0;

          if (state.head) {
            state.head.done = false;
          }

          if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
            strm.msg = 'incorrect header check';
            state.mode = BAD;
            break;
          }

          if ((hold & 0x0f) !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }

          hold >>>= 4;
          bits -= 4;
          len = (hold & 0x0f) + 8;

          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = 'invalid window size';
            state.mode = BAD;
            break;
          }

          state.dmax = 1 << len;
          strm.adler = state.check = 1;
          state.mode = hold & 0x200 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;

        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          state.flags = hold;

          if ((state.flags & 0xff) !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }

          if (state.flags & 0xe000) {
            strm.msg = 'unknown header flags set';
            state.mode = BAD;
            break;
          }

          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }

          if (state.flags & 0x0200) {
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
          }

          hold = 0;
          bits = 0;
          state.mode = TIME;

        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          if (state.head) {
            state.head.time = hold;
          }

          if (state.flags & 0x0200) {
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            hbuf[2] = hold >>> 16 & 0xff;
            hbuf[3] = hold >>> 24 & 0xff;
            state.check = crc32(state.check, hbuf, 4, 0);
          }

          hold = 0;
          bits = 0;
          state.mode = OS;

        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          if (state.head) {
            state.head.xflags = hold & 0xff;
            state.head.os = hold >> 8;
          }

          if (state.flags & 0x0200) {
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
          }

          hold = 0;
          bits = 0;
          state.mode = EXLEN;

        case EXLEN:
          if (state.flags & 0x0400) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            state.length = hold;

            if (state.head) {
              state.head.extra_len = hold;
            }

            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }

            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }

          state.mode = EXTRA;

        case EXTRA:
          if (state.flags & 0x0400) {
            copy = state.length;

            if (copy > have) {
              copy = have;
            }

            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;

                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }

                utils.arraySet(state.head.extra, input, next, copy, len);
              }

              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }

              have -= copy;
              next += copy;
              state.length -= copy;
            }

            if (state.length) {
              break inf_leave;
            }
          }

          state.length = 0;
          state.mode = NAME;

        case NAME:
          if (state.flags & 0x0800) {
            if (have === 0) {
              break inf_leave;
            }

            copy = 0;

            do {
              len = input[next + copy++];

              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;

            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }

          state.length = 0;
          state.mode = COMMENT;

        case COMMENT:
          if (state.flags & 0x1000) {
            if (have === 0) {
              break inf_leave;
            }

            copy = 0;

            do {
              len = input[next + copy++];

              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;

            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }

          state.mode = HCRC;

        case HCRC:
          if (state.flags & 0x0200) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            if (hold !== (state.check & 0xffff)) {
              strm.msg = 'header crc mismatch';
              state.mode = BAD;
              break;
            }

            hold = 0;
            bits = 0;
          }

          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }

          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;

        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;

        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT;
          }

          strm.adler = state.check = 1;
          state.mode = TYPE;

        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }

        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }

          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          state.last = hold & 0x01;
          hold >>>= 1;
          bits -= 1;

          switch (hold & 0x03) {
            case 0:
              state.mode = STORED;
              break;

            case 1:
              fixedtables(state);
              state.mode = LEN_;

              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }

              break;

            case 2:
              state.mode = TABLE;
              break;

            case 3:
              strm.msg = 'invalid block type';
              state.mode = BAD;
          }

          hold >>>= 2;
          bits -= 2;
          break;

        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;

          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
            strm.msg = 'invalid stored block lengths';
            state.mode = BAD;
            break;
          }

          state.length = hold & 0xffff;
          hold = 0;
          bits = 0;
          state.mode = COPY_;

          if (flush === Z_TREES) {
            break inf_leave;
          }

        case COPY_:
          state.mode = COPY;

        case COPY:
          copy = state.length;

          if (copy) {
            if (copy > have) {
              copy = have;
            }

            if (copy > left) {
              copy = left;
            }

            if (copy === 0) {
              break inf_leave;
            }

            utils.arraySet(output, input, next, copy, put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }

          state.mode = TYPE;
          break;

        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          state.nlen = (hold & 0x1f) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 0x1f) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 0x0f) + 4;
          hold >>>= 4;
          bits -= 4;

          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = 'too many length or distance symbols';
            state.mode = BAD;
            break;
          }

          state.have = 0;
          state.mode = LENLENS;

        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            state.lens[order[state.have++]] = hold & 0x07;
            hold >>>= 3;
            bits -= 3;
          }

          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }

          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = {
            bits: state.lenbits
          };
          ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid code lengths set';
            state.mode = BAD;
            break;
          }

          state.have = 0;
          state.mode = CODELENS;

        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;;) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;

              if (here_bits <= bits) {
                break;
              }

              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }

                hold >>>= here_bits;
                bits -= here_bits;

                if (state.have === 0) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }

                len = state.lens[state.have - 1];
                copy = 3 + (hold & 0x03);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }

                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 0x07);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }

                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 0x7f);
                hold >>>= 7;
                bits -= 7;
              }

              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }

              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }

          if (state.mode === BAD) {
            break;
          }

          if (state.lens[256] === 0) {
            strm.msg = 'invalid code -- missing end-of-block';
            state.mode = BAD;
            break;
          }

          state.lenbits = 9;
          opts = {
            bits: state.lenbits
          };
          ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid literal/lengths set';
            state.mode = BAD;
            break;
          }

          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = {
            bits: state.distbits
          };
          ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid distances set';
            state.mode = BAD;
            break;
          }

          state.mode = LEN_;

          if (flush === Z_TREES) {
            break inf_leave;
          }

        case LEN_:
          state.mode = LEN;

        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;

            if (state.mode === TYPE) {
              state.back = -1;
            }

            break;
          }

          state.back = 0;

          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }

            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          if (here_op && (here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;

            for (;;) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;

              if (last_bits + here_bits <= bits) {
                break;
              }

              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }

          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;

          if (here_op === 0) {
            state.mode = LIT;
            break;
          }

          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }

          if (here_op & 64) {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD;
            break;
          }

          state.extra = here_op & 15;
          state.mode = LENEXT;

        case LENEXT:
          if (state.extra) {
            n = state.extra;

            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }

          state.was = state.length;
          state.mode = DIST;

        case DIST:
          for (;;) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            }

            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          }

          if ((here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;

            for (;;) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;

              if (last_bits + here_bits <= bits) {
                break;
              }

              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }

          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;

          if (here_op & 64) {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break;
          }

          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;

        case DISTEXT:
          if (state.extra) {
            n = state.extra;

            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }

          if (state.offset > state.dmax) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }

          state.mode = MATCH;

        case MATCH:
          if (left === 0) {
            break inf_leave;
          }

          copy = _out - left;

          if (state.offset > copy) {
            copy = state.offset - copy;

            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              }
            }

            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }

            if (copy > state.length) {
              copy = state.length;
            }

            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }

          if (copy > left) {
            copy = left;
          }

          left -= copy;
          state.length -= copy;

          do {
            output[put++] = from_source[from++];
          } while (--copy);

          if (state.length === 0) {
            state.mode = LEN;
          }

          break;

        case LIT:
          if (left === 0) {
            break inf_leave;
          }

          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;

        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }

            _out -= left;
            strm.total_out += _out;
            state.total += _out;

            if (_out) {
              strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
            }

            _out = left;

            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = 'incorrect data check';
              state.mode = BAD;
              break;
            }

            hold = 0;
            bits = 0;
          }

          state.mode = LENGTH;

        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }

              have--;
              hold += input[next++] << bits;
              bits += 8;
            }

            if (hold !== (state.total & 0xffffffff)) {
              strm.msg = 'incorrect length check';
              state.mode = BAD;
              break;
            }

            hold = 0;
            bits = 0;
          }

          state.mode = DONE;

        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;

        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;

        case MEM:
          return Z_MEM_ERROR;

        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }

    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;

    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }

    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;

    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }

    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }

    return ret;
  }

  function inflateEnd(strm) {
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }

    var state = strm.state;

    if (state.window) {
      state.window = null;
    }

    strm.state = null;
    return Z_OK;
  }

  function inflateGetHeader(strm, head) {
    var state;

    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }

    state = strm.state;

    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }

    state.head = head;
    head.done = false;
    return Z_OK;
  }

  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;

    if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }

    state = strm.state;

    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }

    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);

      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }

    ret = updatewindow(strm, dictionary, dictLength, dictLength);

    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }

    state.havedict = 1;
    return Z_OK;
  }

  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = 'pako inflate (from Nodeca project)';
},10097,[10067,10079,10082,10100,10103],"projects/com.dreame.devices/node_modules/pako/lib/zlib/inflate.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var BAD = 30;
  var TYPE = 12;

  module.exports = function inflate_fast(strm, start) {
    var state;

    var _in;

    var last;

    var _out;

    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;

    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen: for (;;) {
        op = here >>> 24;
        hold >>>= op;
        bits -= op;
        op = here >>> 16 & 0xff;

        if (op === 0) {
          output[_out++] = here & 0xffff;
        } else if (op & 16) {
          len = here & 0xffff;
          op &= 15;

          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }

            len += hold & (1 << op) - 1;
            hold >>>= op;
            bits -= op;
          }

          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }

          here = dcode[hold & dmask];

          dodist: for (;;) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff;

            if (op & 16) {
              dist = here & 0xffff;
              op &= 15;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;

                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }

              dist += hold & (1 << op) - 1;

              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              }

              hold >>>= op;
              bits -= op;
              op = _out - beg;

              if (dist > op) {
                op = dist - op;

                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  }
                }

                from = 0;
                from_source = s_window;

                if (wnext === 0) {
                  from += wsize - op;

                  if (op < len) {
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    from_source = output;
                  }
                } else if (wnext < op) {
                  from += wsize + wnext - op;
                  op -= wnext;

                  if (op < len) {
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = 0;

                    if (wnext < len) {
                      op = wnext;
                      len -= op;

                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);

                      from = _out - dist;
                      from_source = output;
                    }
                  }
                } else {
                  from += wnext - op;

                  if (op < len) {
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    from_source = output;
                  }
                }

                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }

                if (len) {
                  output[_out++] = from_source[from++];

                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;

                do {
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);

                if (len) {
                  output[_out++] = output[from++];

                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }

            break;
          }
        } else if ((op & 64) === 0) {
          here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];
          continue dolen;
        } else if (op & 32) {
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }

        break;
      }
    } while (_in < last && _out < end);

    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
},10100,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/inffast.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var utils = _require(_dependencyMap[0]);

  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
  var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
  var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
  var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0,
        max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;

    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }

    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }

    root = bits;

    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }

    if (root > max) {
      root = max;
    }

    if (max === 0) {
      table[table_index++] = 20971520;
      table[table_index++] = 20971520;
      opts.bits = 1;
      return 0;
    }

    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }

    if (root < min) {
      root = min;
    }

    left = 1;

    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];

      if (left < 0) {
        return -1;
      }
    }

    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }

    offs[1] = 0;

    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }

    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }

    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }

    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;

    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }

    for (;;) {
      here_bits = len - drop;

      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 96;
        here_val = 0;
      }

      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;

      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);

      incr = 1 << len - 1;

      while (huff & incr) {
        incr >>= 1;
      }

      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }

      sym++;

      if (--count[len] === 0) {
        if (len === max) {
          break;
        }

        len = lens[lens_index + work[sym]];
      }

      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }

        next += min;
        curr = len - drop;
        left = 1 << curr;

        while (curr + drop < max) {
          left -= count[curr + drop];

          if (left <= 0) {
            break;
          }

          curr++;
          left <<= 1;
        }

        used += 1 << curr;

        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }

        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }

    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 4194304 | 0;
    }

    opts.bits = root;
    return 0;
  };
},10103,[10067],"projects/com.dreame.devices/node_modules/pako/lib/zlib/inftrees.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
},10106,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/constants.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = '';
    this.comment = '';
    this.hcrc = 0;
    this.done = false;
  }

  module.exports = GZheader;
},10109,[],"projects/com.dreame.devices/node_modules/pako/lib/zlib/gzheader.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    function Optimize2(mapInfo, picW, picH, chargePos) {
        var oldMapInfo = [];

        for (var i = 0; i < mapInfo.length; i++) {
            oldMapInfo[i] = mapInfo[i];
        }

        clearLaminatedWall(mapInfo, picW, picH);
        clearBorder(mapInfo);
        fillMapData(mapInfo, picW, picH, 2, 3, 3);
        denoise(mapInfo, picW, picH);
        denoise2(mapInfo, picW, picH);
        updateBorderValue(mapInfo, picW, picH, 5);
        fillCrossLine(mapInfo, picW, picH, 5);
        linkAdjacentAreas(oldMapInfo, mapInfo, picW, picH, 5);
        var ret = findOutLine(mapInfo, picW, picH, 5, true);

        if (!ret) {
            return null;
        }

        updateBorderValue(mapInfo, picW, picH, 6);
        var index = Math.floor(chargePos.y) * picW + Math.floor(chargePos.x);
        var cChargePos = undefined;

        if (chargePos.angle != 32767 && mapInfo[index] != 0) {
            cChargePos = calculateChargePos(mapInfo, picW, picH, 6, chargePos);
        }

        findOutLine(mapInfo, picW, picH, 6);
        fillMapData2(mapInfo, picW, picH);
        clearSmallObstacle(mapInfo, picW, picH, 3);
        var Multiple = 2;

        if (picW <= 70 && picH <= 70) {
            Multiple = 5;
        } else if (picW >= 220 || picH >= 220) {
            Multiple = 1;
        }

        var nW = picW * Multiple;
        var nH = picH * Multiple;
        var oW = picW;
        var mapInfo2 = [];

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                for (var nj = Multiple * j; nj < Multiple * j + Multiple; nj++) {
                    for (var ni = Multiple * i; ni < Multiple * i + Multiple; ni++) {
                        mapInfo2[nj * nW + ni] = mapInfo[j * oW + i];
                    }
                }
            }
        }

        mapInfo = mapInfo2;
        picW = nW;
        picH = nH;
        updateBorderValue(mapInfo, picW, picH, 7);
        var points = "";

        for (var i = 0; i < mapInfo.length; i++) {
            var _i = i % picW;

            var _j = Math.floor(i / picW);

            var value = mapInfo[_j * picW + _i];

            if (value == 0) {
                points = points + "0";
            } else if (value == 2 || value == 7) {
                points = points + "2";
            } else if (value == 3) {
                points = points + "3";
            } else {
                points = points + "1";
            }

            if (i != mapInfo.length - 1) {
                points = points + ",";
            }
        }

        return {
            picH: picH,
            picW: picW,
            Multiple: Multiple,
            points: points,
            chargePos: cChargePos
        };
    }

    function calculateChargePos(mapInfo, picW, picH, strokeValue, chargerPos) {
        var vLines = [];
        var hLines = [];

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;
                var lastY = j - 1;

                if (mapInfo[index] == strokeValue && j != picH - 1) {
                    var isCross = false;

                    if (i != 0 && mapInfo[index - 1] == strokeValue || i != picW - 1 && mapInfo[index + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (startY < 0 && isCross) {
                        startY = j;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastY = j;
                }

                if (startY >= 0) {
                    if (j == picH - 1 && mapInfo[index] == strokeValue) {
                        lastY = j;
                    }

                    if (lastY == startY) {
                        startY = -1;
                        continue;
                    }

                    var isCross = false;
                    var lastIndex = lastY * picW + i;

                    if (mapInfo[lastIndex - 1] == strokeValue || mapInfo[lastIndex + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (isCross) {
                        var p0 = {
                            x: i,
                            y: startY
                        };
                        var p1 = {
                            x: i,
                            y: lastY
                        };
                        vLines.push({
                            p0: p0,
                            p1: p1
                        });
                        startY = lastY;
                        continue;
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;
                var lastX = i - 1;

                if (mapInfo[index] == strokeValue && i != picW - 1) {
                    var isCross = false;

                    if (mapInfo[index - picW] == strokeValue || mapInfo[index + picW] == strokeValue) {
                        isCross = true;
                    }

                    if (startX < 0 && isCross) {
                        startX = i;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastX = i;
                }

                if (startX >= 0) {
                    if (mapInfo[index] == strokeValue && i == picW - 1) {
                        lastX = i;
                    }

                    if (lastX == startX) {
                        startX = -1;
                        continue;
                    }

                    var isCross = false;
                    var lastIndex = j * picW + lastX;

                    if (mapInfo[lastIndex - picW] == strokeValue || mapInfo[lastIndex + picW] == strokeValue) {
                        isCross = true;
                    }

                    if (isCross) {
                        var p0 = {
                            x: startX,
                            y: j
                        };
                        var p1 = {
                            x: lastX,
                            y: j
                        };
                        hLines.push({
                            p0: p0,
                            p1: p1
                        });
                        startX = lastX;
                        continue;
                    }
                }

                startX = -1;
            }
        }

        var cX = Math.floor(chargerPos.x);
        var cY = Math.floor(chargerPos.y);

        if (Math.abs(chargerPos.angle - 180) <= 15) {
            chargerPos.angle = 180;
            var lastX = undefined;

            for (var i = 0; i < vLines.length; i++) {
                var line = vLines[i];
                var lx = line.p0.x;
                var minY = line.p0.y < line.p1.y ? line.p0.y : line.p1.y;
                var maxY = line.p0.y > line.p1.y ? line.p0.y : line.p1.y;

                if (lx >= cX && cY >= minY && cY <= maxY) {
                    if (lastX == undefined || lx < lastX) {
                        lastX = lx;
                    }
                }
            }

            if (lastX != undefined) {
                if (lastX - cX <= 11) {
                    chargerPos.angle = 180;
                    chargerPos.x = lastX + 0.5;
                }
            }
        } else if (Math.abs(chargerPos.angle - 360) <= 15 || Math.abs(chargerPos.angle) <= 15) {
            chargerPos.angle = 360;
            var lastX = undefined;

            for (var i = 0; i < vLines.length; i++) {
                var line = vLines[i];
                var lx = line.p0.x;
                var minY = line.p0.y < line.p1.y ? line.p0.y : line.p1.y;
                var maxY = line.p0.y > line.p1.y ? line.p0.y : line.p1.y;

                if (lx <= cX && cY >= minY && cY <= maxY) {
                    if (lastX == undefined || lx > lastX) {
                        lastX = lx;
                    }
                }
            }

            if (lastX != undefined) {
                if (cX - lastX <= 11) {
                    chargerPos.angle = 360;
                    chargerPos.x = lastX + 0.5;
                }
            }
        } else if (Math.abs(Math.abs(chargerPos.angle - 270) <= 15)) {
            var lastY = undefined;

            for (var i = 0; i < hLines.length; i++) {
                var line = hLines[i];
                var ly = line.p0.y;
                var minX = line.p0.x < line.p1.x ? line.p0.x : line.p1.x;
                var maxX = line.p0.x > line.p1.x ? line.p0.x : line.p1.x;

                if (ly >= cY && cX >= minX && cX <= maxX) {
                    if (lastY == undefined || ly < lastY) {
                        lastY = ly;
                    }
                }
            }

            if (lastY != undefined) {
                if (lastY - cY <= 11) {
                    chargerPos.angle = 270;
                    chargerPos.y = lastY + 0.5;
                }
            }
        } else if (Math.abs(Math.abs(chargerPos.angle - 90) <= 15)) {
            var lastY = undefined;

            for (var i = 0; i < hLines.length; i++) {
                var line = hLines[i];
                var ly = line.p0.y;
                var minX = line.p0.x < line.p1.x ? line.p0.x : line.p1.x;
                var maxX = line.p0.x > line.p1.x ? line.p0.x : line.p1.x;

                if (ly <= cY && cX >= minX && cX <= maxX) {
                    if (lastY == undefined || ly > lastY) {
                        lastY = ly;
                    }
                }
            }

            if (lastY != undefined) {
                if (cY - lastY <= 11) {
                    chargerPos.angle = 90;
                    chargerPos.y = lastY + 0.5;
                }
            }
        }

        return chargerPos;
    }

    function Optimize(mapInfo, picW, picH) {
        var oldMapInfo = [];

        for (var i = 0; i < mapInfo.length; i++) {
            oldMapInfo[i] = mapInfo[i];
        }

        clearLaminatedWall(mapInfo, picW, picH);
        clearBorder(mapInfo);
        fillMapData(mapInfo, picW, picH, 2, 3, 3);
        denoise(mapInfo, picW, picH);
        denoise2(mapInfo, picW, picH);
        updateBorderValue(mapInfo, picW, picH, 5);
        fillCrossLine(mapInfo, picW, picH, 5);
        linkAdjacentAreas(oldMapInfo, mapInfo, picW, picH, 5);
        var ret = findOutLine(mapInfo, picW, picH, 5, true);

        if (!ret) {
            return null;
        }

        updateBorderValue(mapInfo, picW, picH, 6);
        findOutLine(mapInfo, picW, picH, 6);
        fillMapData2(mapInfo, picW, picH);
        clearSmallObstacle(mapInfo, picW, picH, 3);
        var Multiple = 2;

        if (picW <= 70 && picH <= 70) {
            Multiple = 5;
        } else if (picW >= 220 || picH >= 220) {
            Multiple = 1;
        }

        var nW = picW * Multiple;
        var nH = picH * Multiple;
        var oW = picW;
        var mapInfo2 = [];

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                for (var nj = Multiple * j; nj < Multiple * j + Multiple; nj++) {
                    for (var ni = Multiple * i; ni < Multiple * i + Multiple; ni++) {
                        mapInfo2[nj * nW + ni] = mapInfo[j * oW + i];
                    }
                }
            }
        }

        mapInfo = mapInfo2;
        picW = nW;
        picH = nH;
        updateBorderValue(mapInfo, picW, picH, 7);
        return {
            picH: picH,
            picW: picW,
            Multiple: Multiple,
            mapInfo: mapInfo
        };
    }

    function linkAdjacentAreas(oldMapInfo, mapInfo, picW, picH, strokeValue) {
        var horizontalLines = [];
        var verticalLines = [];
        var DIR_LEFT = 1;
        var DIR_RIGHT = 2;
        var DIR_TOP = 3;
        var DIR_BOTTOM = 4;

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;
                var lastY = j - 1;

                if (mapInfo[index] == strokeValue && j != picH - 1) {
                    var isCross = false;

                    if (i != 0 && mapInfo[index - 1] == strokeValue || i != picW - 1 && mapInfo[index + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (startY < 0 && isCross) {
                        startY = j;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastY = j;
                }

                if (startY >= 0) {
                    if (j == picH - 1 && mapInfo[index] == strokeValue) {
                        lastY = j;
                    }

                    if (lastY == startY) {
                        startY = -1;
                        continue;
                    }

                    var isCross = false;
                    var dir = DIR_LEFT;
                    var lastIndex = lastY * picW + i;

                    if (mapInfo[lastIndex - 1] == strokeValue || mapInfo[lastIndex + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (i == 0) {
                        dir = DIR_LEFT;
                    } else if (i == picW - 1) {
                        dir = DIR_RIGHT;
                    } else if (mapInfo[lastIndex - 1] == strokeValue) {
                        if (mapInfo[lastIndex + 1] != 0) {
                            dir = DIR_LEFT;
                        } else {
                            dir = DIR_RIGHT;
                        }
                    } else if (mapInfo[lastIndex + 1] == strokeValue) {
                        if (mapInfo[lastIndex - 1] != 0) {
                            dir = DIR_RIGHT;
                        } else {
                            dir = DIR_LEFT;
                        }
                    }

                    if (isCross) {
                        var line = {
                            x: i,
                            y: [startY, lastY],
                            ishorizontal: false,
                            dir: dir,
                            length: lastY - startY
                        };
                        verticalLines.push(line);
                        startY = lastY;
                        continue;
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;
                var lastX = i - 1;

                if (mapInfo[index] == strokeValue && i != picW - 1) {
                    var isCross = false;

                    if (mapInfo[index - picW] == strokeValue || mapInfo[index + picW] == strokeValue) {
                        isCross = true;
                    }

                    if (startX < 0 && isCross) {
                        startX = i;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastX = i;
                }

                if (startX >= 0) {
                    if (mapInfo[index] == strokeValue && i == picW - 1) {
                        lastX = i;
                    }

                    if (lastX == startX) {
                        startX = -1;
                        continue;
                    }

                    var isCross = false;
                    var dir = DIR_TOP;
                    var lastIndex = j * picW + lastX;

                    if (mapInfo[lastIndex - picW] == strokeValue || mapInfo[lastIndex + picW] == strokeValue) {
                        isCross = true;
                    }

                    if (j == 0) {
                        dir = DIR_BOTTOM;
                    } else if (j == picH - 1) {
                        dir = DIR_TOP;
                    } else if (mapInfo[lastIndex - picW] == strokeValue) {
                        if (mapInfo[lastIndex + picW] != 0) {
                            dir = DIR_BOTTOM;
                        } else {
                            dir = DIR_TOP;
                        }
                    } else if (mapInfo[lastIndex + picW] == strokeValue) {
                        if (mapInfo[lastIndex - picW] != 0) {
                            dir = DIR_TOP;
                        } else {
                            dir = DIR_BOTTOM;
                        }
                    }

                    if (isCross) {
                        var line = {
                            x: [startX, lastX],
                            y: j,
                            ishorizontal: true,
                            dir: dir,
                            length: lastX - startX
                        };
                        horizontalLines.push(line);
                        startX = lastX;
                        continue;
                    }
                }

                startX = -1;
            }
        }

        var paths = findBounds(horizontalLines, verticalLines);
        var needFill = paths.length > 1;

        function checkIntersect(arr1, arr2) {
            if (arr1[0] >= arr2[1] || arr2[0] >= arr1[1]) {
                return null;
            }

            var tmp = [];
            tmp = tmp.concat(arr1).concat(arr2);
            tmp.sort(function (a, b) {
                return a - b;
            });
            return [tmp[1], tmp[2]];
        }

        function findOldPoints(xs, ys) {
            if (xs[0] > xs[1]) {
                var tmp = xs[0];
                xs[0] = xs[1];
                xs[1] = tmp;
            }

            if (ys[0] > ys[1]) {
                var tmp = ys[0];
                ys[0] = ys[1];
                ys[1] = tmp;
            }

            var num = 0;

            for (var i = xs[0]; i <= xs[1]; i++) {
                for (var j = ys[0]; j <= ys[1]; j++) {
                    var value = oldMapInfo[j * picW + i];

                    if (value != 0) {
                        num++;
                    }
                }
            }

            var weight = num / ((xs[1] - xs[0] + 1) * (ys[1] - ys[0] + 1));

            if (weight > 0.5) {
                for (var i = xs[0]; i <= xs[1]; i++) {
                    for (var j = ys[0]; j <= ys[1]; j++) {
                        mapInfo[j * picW + i] = 1;
                    }
                }
            }

            return weight;
        }

        while (paths.length > 1) {
            var lines = paths.shift().alines;

            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];

                for (var i = 0; i < paths.length; i++) {
                    var nLines = paths[i].alines;

                    for (var j = 0; j < nLines.length; j++) {
                        var nLine = nLines[j];

                        if (line.ishorizontal === false && nLine.ishorizontal === false) {
                            if (line.dir != nLine.dir) {
                                if (line.x > nLine.x && line.dir == DIR_LEFT || line.x < nLine.x && line.dir == DIR_RIGHT) {
                                    if (Math.abs(line.x - nLine.x) <= 10) {
                                        var _ys = checkIntersect(line.y, nLine.y);

                                        if (_ys != null) {
                                            var xs = [line.x + 1, nLine.x - 1];

                                            if (line.x > nLine.x) {
                                                xs = [nLine.x + 1, line.x - 1];
                                            }

                                            var weight = findOldPoints(xs, _ys);
                                        }
                                    }
                                }
                            }
                        } else if (line.ishorizontal === true && nLine.ishorizontal === true) {
                            if (line.dir != nLine.dir) {
                                if (line.y > nLine.y && line.dir == DIR_BOTTOM || line.y < nLine.y && line.dir == DIR_TOP) {
                                    if (Math.abs(line.y - nLine.y) <= 10) {
                                        var _xs = checkIntersect(line.x, nLine.x);

                                        if (_xs != null) {
                                            var ys = [line.y + 1, nLine.y - 1];

                                            if (line.y > nLine.y) {
                                                ys = [nLine.y + 1, line.y - 1];
                                            }

                                            var weight = findOldPoints(_xs, ys);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (needFill) {
            for (var j = 0; j < picH; j++) {
                for (var i = 0; i < picW; i++) {
                    var index = j * picW + i;

                    if (mapInfo[index] == strokeValue) {
                        mapInfo[index] = 1;
                    }
                }
            }

            fillMapData2(mapInfo, picW, picH);
            updateBorderValue(mapInfo, picW, picH, strokeValue);
            fillCrossLine(mapInfo, picW, picH, strokeValue);
        }
    }

    function fillCrossLine(mapInfo, picW, picH, strokeValue) {
        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;
                var lastY = j - 1;

                if (mapInfo[index] == strokeValue && j != picH - 1) {
                    if (startY < 0) {
                        startY = j;
                    }

                    continue;
                }

                if (startY >= 0) {
                    if (j == picH - 1 && mapInfo[index] == strokeValue) {
                        lastY = j;
                    }

                    if (lastY == startY) {
                        startY = -1;
                        continue;
                    }

                    var crossNum = 0;

                    for (var _j = startY; _j <= lastY; _j++) {
                        var _i = i - 1;

                        if (_i >= 0) {
                            var cIndex = _j * picW + _i;

                            if (mapInfo[cIndex] == strokeValue) {
                                crossNum++;
                            }
                        }

                        _i = i + 1;

                        if (_i < picW) {
                            var cIndex = _j * picW + _i;

                            if (mapInfo[cIndex] == strokeValue) {
                                crossNum++;
                            }
                        }

                        if (crossNum > 2) {
                            break;
                        }
                    }

                    if (crossNum > 2) {
                        for (var _j = startY; _j <= lastY; _j++) {
                            var _i = i - 1;

                            if (_i >= 0) {
                                var cIndex = _j * picW + _i;

                                if (mapInfo[cIndex] == 0) {
                                    mapInfo[cIndex] = 1;
                                }
                            }

                            _i = i + 1;

                            if (_i < picW) {
                                var cIndex = _j * picW + _i;

                                if (mapInfo[cIndex] == 0) {
                                    mapInfo[cIndex] = 1;
                                }
                            }
                        }
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;
                var lastX = i - 1;

                if (mapInfo[index] == strokeValue && i != picW - 1) {
                    if (startX < 0) {
                        startX = i;
                    }

                    continue;
                }

                if (startX >= 0) {
                    if (mapInfo[index] == strokeValue && i == picW - 1) {
                        lastX = i;
                    }

                    if (lastX == startX) {
                        startX = -1;
                        continue;
                    }

                    var crossNum = 0;

                    for (var _i = startX; _i <= lastX; _i++) {
                        var _j = j - 1;

                        if (_j >= 0) {
                            var cIndex = _j * picW + _i;

                            if (mapInfo[cIndex] == strokeValue) {
                                crossNum++;
                            }
                        }

                        _j = j + 1;

                        if (_j < picW) {
                            var cIndex = _j * picW + _i;

                            if (mapInfo[cIndex] == strokeValue) {
                                crossNum++;
                            }
                        }

                        if (crossNum > 2) {
                            break;
                        }
                    }

                    if (crossNum > 2) {
                        for (var _i = startX; _i <= lastX; _i++) {
                            var _j = j - 1;

                            if (_j >= 0) {
                                var cIndex = _j * picW + _i;

                                if (mapInfo[cIndex] == 0) {
                                    mapInfo[cIndex] = 1;
                                }
                            }

                            _j = j + 1;

                            if (_j < picW) {
                                var cIndex = _j * picW + _i;

                                if (mapInfo[cIndex] == 0) {
                                    mapInfo[cIndex] = 1;
                                }
                            }
                        }
                    }
                }

                startX = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == strokeValue) {
                    mapInfo[index] = 1;
                }
            }
        }

        updateBorderValue(mapInfo, picW, picH, strokeValue);
    }

    function clearLaminatedWall(mapInfo, picW, picH) {
        for (var j = 1; j < picH - 1; j++) {
            for (var i = 1; i < picW - 1; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == 1) {
                    var num = 0;

                    if (mapInfo[index - 1] != 1) {
                        num++;
                    }

                    if (mapInfo[index + 1] != 1) {
                        num++;
                    }

                    if (mapInfo[index + picW] != 1) {
                        num++;
                    }

                    if (mapInfo[index - picW] != 1) {
                        num++;
                    }

                    if (num > 2) {
                        mapInfo[index] = 0;
                    }
                }
            }
        }

        for (var j = 1; j < picH - 1; j++) {
            for (var i = 1; i < picW - 1; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == 2) {
                    if (mapInfo[index - 1] == 1 && mapInfo[index + 1] == 1) {
                        mapInfo[index] = 1;
                    } else if (mapInfo[index + picW] == 1 && mapInfo[index - picW] == 1) {
                        mapInfo[index] = 1;
                    }
                }
            }
        }
    }

    function clearSmallObstacle(mapInfo, picW, picH, obstacleValue) {
        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;

                if (mapInfo[index] == obstacleValue) {
                    if (startY < 0) {
                        startY = j;
                    }

                    continue;
                }

                if (startY != -1 && j - startY <= 3) {
                    for (var k = startY; k < j; k++) {
                        mapInfo[k * picW + i] = 1;
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == obstacleValue) {
                    if (startX < 0) {
                        startX = i;
                    }

                    continue;
                }

                if (startX != -1 && i - startX <= 3) {
                    for (var k = startX; k < i; k++) {
                        mapInfo[j * picW + k] = 1;
                    }
                }

                startX = -1;
            }
        }
    }

    function findOutLine(mapInfo, picW, picH, strokeValue, isFrist) {
        var horizontalLines = [];
        var verticalLines = [];

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;
                var lastY = j - 1;

                if (mapInfo[index] == strokeValue && j != picH - 1) {
                    var isCross = false;

                    if (i != 0 && mapInfo[index - 1] == strokeValue || i != picW - 1 && mapInfo[index + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (startY < 0 && isCross) {
                        startY = j;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastY = j;
                }

                if (startY >= 0) {
                    if (j == picH - 1 && mapInfo[index] == strokeValue) {
                        lastY = j;
                    }

                    if (lastY == startY) {
                        startY = -1;
                        continue;
                    }

                    var isCross = false;
                    var lastIndex = lastY * picW + i;

                    if (mapInfo[lastIndex - 1] == strokeValue || mapInfo[lastIndex + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (isCross) {
                        var line = {
                            x: i,
                            y: [startY, lastY],
                            ishorizontal: false,
                            length: lastY - startY
                        };
                        verticalLines.push(line);
                        startY = lastY;
                        continue;
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;
                var lastX = i - 1;

                if (mapInfo[index] == strokeValue && i != picW - 1) {
                    var isCross = false;

                    if (mapInfo[index - picW] == strokeValue || mapInfo[index + picW] == strokeValue) {
                        isCross = true;
                    }

                    if (startX < 0 && isCross) {
                        startX = i;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastX = i;
                }

                if (startX >= 0) {
                    if (mapInfo[index] == strokeValue && i == picW - 1) {
                        lastX = i;
                    }

                    if (lastX == startX) {
                        startX = -1;
                        continue;
                    }

                    var isCross = false;
                    var lastIndex = j * picW + lastX;

                    if (mapInfo[lastIndex - picW] == strokeValue || mapInfo[lastIndex + picW] == strokeValue) {
                        isCross = true;
                    }

                    if (isCross) {
                        var line = {
                            x: [startX, lastX],
                            y: j,
                            ishorizontal: true,
                            length: lastX - startX
                        };
                        horizontalLines.push(line);
                        startX = lastX;
                        continue;
                    }
                }

                startX = -1;
            }
        }

        if (horizontalLines.length == 0) {
            return false;
        }

        var paths = findBounds(horizontalLines, verticalLines);
        var covertlines;
        var allLines;
        var totalLen = 0;
        var tmp = [];

        for (var i = 0; i < paths.length; i++) {
            var item = paths[i];

            if (item.length > totalLen) {
                if (covertlines) {
                    if (totalLen < 80) {
                        tmp.push(covertlines);
                    }
                }

                totalLen = item.length;
                covertlines = item.cLines;
                allLines = item.alines;
            } else {
                if (item.length < 80) {
                    tmp.push(item.cLines);
                }
            }
        }

        if (isFrist == true && tmp.length > 0) {
            var clearPos = [];

            for (var i = 0; i < tmp.length; i++) {
                clearPos.push(tmp[i][0].p0);
            }

            while (clearPos.length > 0) {
                var pos = clearPos.pop();
                var i = pos.x;
                var j = pos.y;
                mapInfo[j * picW + i] = 0;

                for (var _i = i - 1; _i <= i + 1; _i++) {
                    for (var _j = j - 1; _j <= j + 1; _j++) {
                        if (_i == i || _j == j) {
                            var index = _j * picW + _i;

                            if (mapInfo[index] != undefined && mapInfo[index] != 0) {
                                clearPos.push({
                                    x: _i,
                                    y: _j
                                });
                            }
                        }
                    }
                }
            }
        }

        var bottom = 5;
        var right = 6;
        var top = 7;
        var left = 8;
        var dirnone = 0;
        var angel = {
            lines: [],
            horizontalDir: dirnone,
            verticalDir: dirnone
        };

        function fillAngle(angel) {
            var l1 = angel.lines[0];
            var l2 = angel.lines[angel.lines.length - 1];

            if (angel.lines.length == 2 || angel.lines.length > 22) {
                var nextAngle = {
                    lines: [],
                    horizontalDir: dirnone,
                    verticalDir: dirnone
                };
                nextAngle.lines.push(l2);

                if (l2.ishorizontal) {
                    nextAngle.horizontalDir = l2.findEnd ? right : left;
                } else {
                    nextAngle.verticalDir = l2.findEnd ? top : bottom;
                }

                return nextAngle;
            }

            var minx, miny, maxx, maxy;

            if (l1.ishorizontal) {
                if (angel.horizontalDir == right) {
                    minx = l1.x[1];
                } else {
                    maxx = l1.x[0];
                }

                if (angel.verticalDir == top) {
                    miny = l1.y;
                } else {
                    maxy = l1.y;
                }

                if (l2.ishorizontal) {
                    if (angel.horizontalDir == right) {
                        maxx = l2.x[0];
                    } else {
                        minx = l2.x[1];
                    }

                    if (angel.verticalDir == top) {
                        maxy = l2.y;
                    } else {
                        miny = l2.y;
                    }
                } else {
                    if (angel.horizontalDir == right) {
                        maxx = l2.x;
                    } else {
                        minx = l2.x;
                    }

                    if (angel.verticalDir == top) {
                        maxy = l2.y[0];
                    } else {
                        miny = l2.y[1];
                    }
                }
            } else {
                if (angel.verticalDir == top) {
                    miny = l1.y[1];
                } else {
                    maxy = l1.y[0];
                }

                if (angel.horizontalDir == right) {
                    minx = l1.x;
                } else {
                    maxx = l1.x;
                }

                if (l2.ishorizontal) {
                    if (angel.horizontalDir == right) {
                        maxx = l2.x[0];
                    } else {
                        minx = l2.x[1];
                    }

                    if (angel.verticalDir == top) {
                        maxy = l2.y;
                    } else {
                        miny = l2.y;
                    }
                } else {
                    if (angel.horizontalDir == right) {
                        maxx = l2.x;
                    } else {
                        minx = l2.x;
                    }

                    if (angel.verticalDir == top) {
                        maxy = l2.y[0];
                    } else {
                        miny = l2.y[1];
                    }
                }
            }

            if (minx == undefined || miny == undefined || maxx == undefined || maxy == undefined) {
                var nextAngle = {
                    lines: [],
                    horizontalDir: dirnone,
                    verticalDir: dirnone
                };
                nextAngle.lines.push(l2);

                if (l2.ishorizontal) {
                    nextAngle.horizontalDir = l2.findEnd ? right : left;
                } else {
                    nextAngle.verticalDir = l2.findEnd ? top : bottom;
                }

                return nextAngle;
            }

            if (l1.ishorizontal && l2.ishorizontal && maxy - miny <= 3) {
                if (angel.horizontalDir == right) {
                    minx = l1.x[0];
                    maxx = l2.x[1];
                } else {
                    minx = l2.x[0];
                    maxx = l1.x[1];
                }
            } else if (!l1.ishorizontal && !l2.ishorizontal && maxx - minx <= 3) {
                if (angel.verticalDir == top) {
                    miny = l1.y[0];
                    maxy = l2.y[1];
                } else {
                    miny = l2.y[0];
                    maxy = l1.y[1];
                }
            }

            var num = 0;

            for (var i = minx; i <= maxx; i++) {
                for (var j = miny; j <= maxy; j++) {
                    var index = j * picW + i;

                    if (mapInfo[index] == 0) {
                        num++;
                    }
                }
            }

            if (num < 20 || num < (maxx - minx + 1) * (maxy - miny + 1) * 2 / 3) {
                for (var i = minx; i <= maxx; i++) {
                    for (var j = miny; j <= maxy; j++) {
                        var index = j * picW + i;

                        if (mapInfo[index] == 0) {
                            mapInfo[index] = strokeValue;
                        }
                    }
                }
            }

            var nextAngle = {
                lines: [],
                horizontalDir: dirnone,
                verticalDir: dirnone
            };
            nextAngle.lines.push(l2);

            if (l2.ishorizontal) {
                nextAngle.horizontalDir = l2.findEnd ? right : left;
            } else {
                nextAngle.verticalDir = l2.findEnd ? top : bottom;
            }

            return nextAngle;
        }

        for (var i = 0; i <= allLines.length; i++) {
            var line = allLines[i];

            if (i == allLines.length) {
                line = allLines[0];
            }

            if (i == 0) {
                angel.lines.push(line);
                angel.type = bottom;
                angel.horizontalDir = right;
            } else {
                if (line.ishorizontal) {
                    var horizontalDir = line.findEnd ? right : left;

                    if (angel.horizontalDir != dirnone && angel.horizontalDir != horizontalDir) {
                        angel = fillAngle(angel);
                    }

                    if (angel.horizontalDir == dirnone) {
                        angel.horizontalDir = horizontalDir;
                    }

                    angel.lines.push(line);
                } else {
                    var verticalDir = line.findEnd ? top : bottom;

                    if (angel.verticalDir != dirnone && angel.verticalDir != verticalDir) {
                        angel = fillAngle(angel);
                    }

                    if (angel.verticalDir == dirnone) {
                        angel.verticalDir = verticalDir;
                    }

                    angel.lines.push(line);
                }

                if (line.length >= 7 || i == allLines.length) {
                    angel = fillAngle(angel);
                }
            }
        }

        return true;
    }

    function updateBorderValue(mapInfo, picW, picH, strokeValue) {
        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] != 0) {
                    if (j == 0 || j == picH - 1 || i == 0 || i == picW - 1) {
                        mapInfo[index] = strokeValue;
                    }

                    var hasFind = false;

                    for (var _i = i - 1; _i <= i + 1; _i++) {
                        for (var _j = j - 1; _j <= j + 1; _j++) {
                            var nIndex = _j * picW + _i;

                            if (mapInfo[nIndex] == 0) {
                                hasFind = true;
                                break;
                            }
                        }

                        if (hasFind) {
                            break;
                        }
                    }

                    if (hasFind) {
                        mapInfo[index] = strokeValue;
                    }
                }
            }
        }
    }

    function createBorder(mapInfo, picW, picH) {
        for (var i = 0; i < picW; i++) {
            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;

                if ((i == 0 || i == picW - 1 || j == 0 || j == picH - 1) && mapInfo[index] != 0) {
                    mapInfo[index] = 5;
                    continue;
                }

                if (mapInfo[index] != 0 && mapInfo[index] != 5) {
                    for (var ii = i - 1; ii < i + 2; ii++) {
                        for (var jj = j - 1; jj < j + 2; jj++) {
                            if (ii == i && jj == j) {
                                continue;
                            }

                            var nIndex = jj * picW + ii;

                            if (mapInfo[nIndex] == 0) {
                                mapInfo[nIndex] = 5;
                            }
                        }
                    }
                }
            }
        }
    }

    function clearBorder(mapInfo) {
        for (var i = 0; i < mapInfo.length; i++) {
            if (mapInfo[i] == 2) {
                mapInfo[i] = 0;
            }
        }
    }

    function denoise2(mapInfo, picW, picH) {
        var len = 2;

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;

                if (mapInfo[index] != 0) {
                    if (startY < 0) {
                        startY = j;
                    }

                    continue;
                }

                if (startY != -1 && j - startY <= len) {
                    for (var k = startY; k < j; k++) {
                        mapInfo[k * picW + i] = 0;
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] != 0) {
                    if (startX < 0) {
                        startX = i;
                    }

                    continue;
                }

                if (startX != -1 && i - startX <= len) {
                    for (var k = startX; k < i; k++) {
                        mapInfo[j * picW + k] = 0;
                    }
                }

                startX = -1;
            }
        }
    }

    function denoise(mapInfo, picW, picH) {
        var tmpMapInfo = [];

        for (var i = 0; i < mapInfo.length; i++) {
            tmpMapInfo[i] = mapInfo[i];
        }

        var len = 20;

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;

                if (mapInfo[index] != 0) {
                    if (startY < 0) {
                        startY = j;
                    }

                    continue;
                }

                if (startY != -1 && j - startY <= len) {
                    var isBorder = false;

                    if (i == 0 || i == picW - 1 || j - startY <= 2) {
                        isBorder = true;
                    }

                    if (!isBorder) {
                        var _i = i - 1;

                        isBorder = true;

                        for (var k = startY; k < j; k++) {
                            if (tmpMapInfo[k * picW + _i] == 1) {
                                isBorder = false;
                                break;
                            }
                        }
                    }

                    if (!isBorder) {
                        var _i = i + 1;

                        isBorder = true;

                        for (var k = startY; k < j; k++) {
                            if (tmpMapInfo[k * picW + _i] == 1) {
                                isBorder = false;
                                break;
                            }
                        }
                    }

                    if (isBorder) {
                        for (var k = startY; k < j; k++) {
                            mapInfo[k * picW + i] = 0;
                        }
                    }
                }

                startY = -1;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] != 0) {
                    if (startX < 0) {
                        startX = i;
                    }

                    continue;
                }

                if (startX != -1 && i - startX <= len) {
                    var isBorder = false;

                    if (j == 0 || j == picH - 1 || i - startX <= 2) {
                        isBorder = true;
                    }

                    if (!isBorder) {
                        var _j = j - 1;

                        isBorder = true;

                        for (var k = startX; k < i; k++) {
                            if (tmpMapInfo[_j * picW + k] == 1) {
                                isBorder = false;
                                break;
                            }

                            ;
                        }
                    }

                    if (!isBorder) {
                        var _j = j + 1;

                        isBorder = true;

                        for (var k = startX; k < i; k++) {
                            if (tmpMapInfo[_j * picW + k] == 1) {
                                isBorder = false;
                                break;
                            }

                            ;
                        }
                    }

                    if (isBorder) {
                        for (var k = startX; k < i; k++) {
                            mapInfo[j * picW + k] = 0;
                        }
                    }
                }

                startX = -1;
            }
        }
    }

    function fillMapData2(mapInfo, picW, picH) {
        function findFristEmptyPoint() {
            for (var i = 0; i < picW; i++) {
                if (mapInfo[i] == 0) {
                    return {
                        x: i,
                        y: 0
                    };
                }

                if (mapInfo[(picH - 1) * picW + i] == 0) {
                    return {
                        x: i,
                        y: picH - 1
                    };
                }
            }

            for (var j = 0; j < picH; j++) {
                if (mapInfo[j * picW] == 0) {
                    return {
                        x: 0,
                        y: j
                    };
                }

                if (mapInfo[j * picW + (picW - 1)] == 0) {
                    return {
                        x: picW - 1,
                        y: j
                    };
                }
            }
        }

        var fillData = 255;

        function findZeroPoint(p) {
            var finds = [];
            var i = p.x;
            var j = p.y;

            for (var _j = j - 1; _j <= j + 1; _j++) {
                for (var _i = i - 1; _i <= i + 1; _i++) {
                    if (_j == j || _i == i) {
                        if (mapInfo[_j * picW + _i] == 0) {
                            mapInfo[_j * picW + _i] = 255;
                            finds.push({
                                x: _i,
                                y: _j
                            });
                        }
                    }
                }
            }

            return finds;
        }

        while (true) {
            var fristPoint = findFristEmptyPoint();

            if (!fristPoint) {
                break;
            }

            mapInfo[fristPoint.x + fristPoint.y * picW] = fillData;
            var needFindPoints = [];
            needFindPoints.push(fristPoint);

            while (needFindPoints.length > 0) {
                var p = needFindPoints.shift();
                var ps = findZeroPoint(p);
                needFindPoints = needFindPoints.concat(ps);
            }
        }

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == 0) {
                    mapInfo[index] = 3;
                }
            }
        }

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == fillData) {
                    mapInfo[index] = 0;
                }
            }
        }
    }

    function fillMapData(mapInfo, picW, picH, times, len, fillValue) {
        function findFristEmptyPoint() {
            for (var i = 0; i < picW; i++) {
                if (mapInfo[i] == 0) {
                    return {
                        x: i,
                        y: 0
                    };
                }

                if (mapInfo[(picH - 1) * picW + i] == 0) {
                    return {
                        x: i,
                        y: picH - 1
                    };
                }
            }

            for (var j = 0; j < picH; j++) {
                if (mapInfo[j * picW] == 0) {
                    return {
                        x: 0,
                        y: j
                    };
                }

                if (mapInfo[j * picW + (picW - 1)] == 0) {
                    return {
                        x: picW - 1,
                        y: j
                    };
                }
            }
        }

        var fillData = 255;

        function findZeroPoint(p) {
            var finds = [];
            var i = p.x;
            var j = p.y;

            for (var _j = j - 1; _j <= j + 1; _j++) {
                for (var _i = i - 1; _i <= i + 1; _i++) {
                    if (_j == j || _i == i) {
                        if (mapInfo[_j * picW + _i] == 0) {
                            mapInfo[_j * picW + _i] = 255;
                            finds.push({
                                x: _i,
                                y: _j
                            });
                        }
                    }
                }
            }

            return finds;
        }

        while (true) {
            var fristPoint = findFristEmptyPoint();

            if (!fristPoint) {
                break;
            }

            mapInfo[fristPoint.x + fristPoint.y * picW] = fillData;
            var needFindPoints = [];
            needFindPoints.push(fristPoint);

            while (needFindPoints.length > 0) {
                var p = needFindPoints.shift();
                var ps = findZeroPoint(p);
                needFindPoints = needFindPoints.concat(ps);
            }
        }

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == 0) {
                    mapInfo[index] = 3;
                }
            }
        }

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == fillData) {
                    mapInfo[index] = 0;
                }
            }
        }

        if (!len || len > 6 || len < 1) {
            len = 4;
        }

        if (!times || times > 3) {
            times = 1;
        }

        for (var t = 0; t < times; t++) {
            for (var i = 0; i < picW; i++) {
                var startY = -1;
                var isEmpty = false;

                for (var j = 0; j < picH; j++) {
                    var index = j * picW + i;

                    if (mapInfo[index] != 0) {
                        if (isEmpty == true && startY >= 0) {
                            if (j - startY - 1 <= len) {
                                for (var _j = startY + 1; _j < j; _j++) {
                                    var num = 0;

                                    if (i > 0 && _j > 0) {
                                        for (var __i = i - 1; __i <= i + 1; __i++) {
                                            for (var __j = _j - 1; __j <= _j + 1; __j++) {
                                                if (__i != i && __j != _j) {
                                                    if (__i == i || __j == _j) {
                                                        if (mapInfo[__j * picW + __i] != 0 && mapInfo[__j * picW + __i] != undefined) {
                                                            num++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        num = 5;
                                    }

                                    if (num >= 3) {
                                        mapInfo[_j * picW + i] = fillValue;
                                    }
                                }
                            }

                            isEmpty = false;
                        }

                        startY = j;
                    } else {
                        if (startY >= 0) {
                            isEmpty = true;
                        }
                    }
                }
            }

            for (var j = 0; j < picH; j++) {
                var startX = -1;
                var isEmpty = false;

                for (var i = 0; i < picW; i++) {
                    var index = j * picW + i;

                    if (mapInfo[index] != 0) {
                        if (isEmpty == true && startX >= 0) {
                            if (i - startX - 1 <= len) {
                                for (var _i = startX + 1; _i < i; _i++) {
                                    var num = 0;

                                    if (_i > 0 && j > 0) {
                                        for (var __i = _i - 1; __i <= _i + 1; __i++) {
                                            for (var __j = j - 1; __j <= j + 1; __j++) {
                                                if (__i != _i && __j != j) {
                                                    if (__i == _i || __j == j) {
                                                        if (mapInfo[__j * picW + __i] != 0 && mapInfo[__j * picW + __i] != undefined) {
                                                            num++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        num = 5;
                                    }

                                    if (num >= 3) {
                                        mapInfo[j * picW + _i] = fillValue;
                                    }
                                }
                            }

                            isEmpty = false;
                        }

                        startX = i;
                    } else {
                        if (startX >= 0) {
                            isEmpty = true;
                        }
                    }
                }
            }
        }
    }

    function findBounds(horizontalLines, verticalLines) {
        function findStartLine(lines) {
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];

                if (line != undefined) {
                    delete lines[i];
                    return line;
                }
            }

            return undefined;
        }

        function addLine(line, covertlines, allLines) {
            var aLine = {
                p0: {},
                p1: {}
            };

            if (line.ishorizontal) {
                aLine.p0.y = line.y;
                aLine.p1.y = line.y;

                if (line.findEnd) {
                    aLine.p0.x = line.x[0];
                    aLine.p1.x = line.x[1];
                } else {
                    aLine.p0.x = line.x[1];
                    aLine.p1.x = line.x[0];
                }

                aLine.length = Math.abs(line.x[1] - line.x[0]);
            } else {
                aLine.p0.x = line.x;
                aLine.p1.x = line.x;
                aLine.length = Math.abs(line.y[1] - line.y[0]);

                if (line.findEnd) {
                    aLine.p0.y = line.y[0];
                    aLine.p1.y = line.y[1];
                } else {
                    aLine.p0.y = line.y[1];
                    aLine.p1.y = line.y[0];
                }
            }

            covertlines.push(aLine);
            allLines.push(line);
        }

        var paths = [];

        while (true) {
            var startLine = findStartLine(horizontalLines);

            if (startLine == undefined) {
                break;
            }

            startLine.findEnd = true;
            var covertlines = [];
            var allLines = [];
            addLine(startLine, covertlines, allLines);

            while (true) {
                var lastLine = allLines[allLines.length - 1];

                if (lastLine.ishorizontal) {
                    var hasFind = false;

                    for (var i = 0; i < verticalLines.length; i++) {
                        var vLine = verticalLines[i];

                        if (vLine == undefined) {
                            continue;
                        }

                        var x = lastLine.x[0];

                        if (lastLine.findEnd) {
                            x = lastLine.x[1];
                        }

                        if (x == vLine.x) {
                            if (lastLine.y == vLine.y[0]) {
                                vLine.findEnd = true;
                                addLine(vLine, covertlines, allLines);
                                delete verticalLines[i];
                                hasFind = true;
                                break;
                            } else if (lastLine.y == vLine.y[1]) {
                                vLine.findEnd = false;
                                addLine(vLine, covertlines, allLines);
                                delete verticalLines[i];
                                hasFind = true;
                                break;
                            } else if (lastLine.y > vLine.y[0] && lastLine.y < vLine.y[1]) {
                                if (lastLine.findEnd) {
                                    if (mapInfo[(lastLine.y + 1) * picW + x - 1] == 0) {
                                        vLine.y[1] = lastLine.y;
                                        vLine.findEnd = false;
                                    } else {
                                        vLine.y[0] = lastLine.y;
                                        vLine.findEnd = true;
                                    }
                                } else {
                                    if (mapInfo[(lastLine.y + 1) * picW + x + 1] == 0) {
                                        vLine.y[1] = lastLine.y;
                                        vLine.findEnd = false;
                                    } else {
                                        vLine.y[0] = lastLine.y;
                                        vLine.findEnd = true;
                                    }
                                }

                                addLine(vLine, covertlines, allLines);
                                delete verticalLines[i];
                                hasFind = true;
                                break;
                            }
                        }
                    }

                    if (!hasFind) {
                        break;
                    }
                } else {
                    var hasFind = false;
                    var _y = lastLine.y[0];

                    if (lastLine.findEnd) {
                        _y = lastLine.y[1];
                    }

                    if (_y == startLine.y && lastLine.x == startLine.x[0]) {
                        break;
                    }

                    for (var i = 0; i < horizontalLines.length; i++) {
                        var hLine = horizontalLines[i];

                        if (!hLine) {
                            continue;
                        }

                        var y = lastLine.y[0];

                        if (lastLine.findEnd) {
                            y = lastLine.y[1];
                        }

                        if (y == hLine.y) {
                            if (lastLine.x == hLine.x[0]) {
                                hLine.findEnd = true;
                                addLine(hLine, covertlines, allLines);
                                delete horizontalLines[i];
                                hasFind = true;
                                break;
                            } else if (lastLine.x == hLine.x[1]) {
                                hLine.findEnd = false;
                                addLine(hLine, covertlines, allLines);
                                delete horizontalLines[i];
                                hasFind = true;
                                break;
                            } else if (lastLine.x > hLine.x[0] && lastLine.x < hLine.x[1]) {
                                if (lastLine.findEnd) {
                                    if (mapInfo[(y - 1) * picW + lastLine.x - 1] == 0) {
                                        hLine.x[0] = lastLine.x;
                                        hLine.findEnd = true;
                                    } else {
                                        hLine.x[1] = lastLine.x;
                                        hLine.findEnd = false;
                                    }
                                } else {
                                    if (mapInfo[(y + 1) * picW + lastLine.x - 1] == 0) {
                                        hLine.x[0] = lastLine.x;
                                        hLine.findEnd = true;
                                    } else {
                                        hLine.x[1] = lastLine.x;
                                        hLine.findEnd = false;
                                    }
                                }

                                addLine(hLine, covertlines, allLines);
                                delete horizontalLines[i];
                                hasFind = true;
                                break;
                            }
                        }
                    }

                    if (!hasFind) {
                        break;
                    }
                }
            }

            var totalLength = 0;

            for (var i = 0; i < covertlines.length; i++) {
                var item = covertlines[i];
                totalLength = totalLength + item.length;
            }

            paths.push({
                cLines: covertlines,
                alines: allLines,
                length: totalLength
            });
        }

        return paths;
    }

    module.exports = {
        clearLaminatedWall: clearLaminatedWall,
        clearBorder: clearBorder,
        fillMapData: fillMapData,
        denoise: denoise,
        denoise2: denoise2,
        updateBorderValue: updateBorderValue,
        fillCrossLine: fillCrossLine,
        linkAdjacentAreas: linkAdjacentAreas,
        findOutLine: findOutLine,
        clearSmallObstacle: clearSmallObstacle,
        Optimize2: Optimize2
    };
},10112,[],"projects/com.dreame.devices/main/DreameUtil/Optimize.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNavigation = _require(_dependencyMap[1]);

  var _ui = _require(_dependencyMap[2]);

  var _HomePage = _require(_dependencyMap[3]);

  var _HomePage2 = babelHelpers.interopRequireDefault(_HomePage);

  var _SettingPage = _require(_dependencyMap[4]);

  var _SettingPage2 = babelHelpers.interopRequireDefault(_SettingPage);

  var _RobotSettingPage = _require(_dependencyMap[5]);

  var _RobotSettingPage2 = babelHelpers.interopRequireDefault(_RobotSettingPage);

  var _TimeZonePage = _require(_dependencyMap[6]);

  var _TimeZonePage2 = babelHelpers.interopRequireDefault(_TimeZonePage);

  var _VolumeSettingPage = _require(_dependencyMap[7]);

  var _VolumeSettingPage2 = babelHelpers.interopRequireDefault(_VolumeSettingPage);

  var _NoDisturbPage = _require(_dependencyMap[8]);

  var _NoDisturbPage2 = babelHelpers.interopRequireDefault(_NoDisturbPage);

  var _GeneralSettingPage = _require(_dependencyMap[9]);

  var _GeneralSettingPage2 = babelHelpers.interopRequireDefault(_GeneralSettingPage);

  var _RemoteControlPage = _require(_dependencyMap[10]);

  var _RemoteControlPage2 = babelHelpers.interopRequireDefault(_RemoteControlPage);

  var _TimingTaskPage = _require(_dependencyMap[11]);

  var _TimingTaskPage2 = babelHelpers.interopRequireDefault(_TimingTaskPage);

  var _AddTimingPage = _require(_dependencyMap[12]);

  var _AddTimingPage2 = babelHelpers.interopRequireDefault(_AddTimingPage);

  var _NetInfoPage = _require(_dependencyMap[13]);

  var _NetInfoPage2 = babelHelpers.interopRequireDefault(_NetInfoPage);

  var _MaterialPage = _require(_dependencyMap[14]);

  var _MaterialPage2 = babelHelpers.interopRequireDefault(_MaterialPage);

  var _MaterialInfoPage = _require(_dependencyMap[15]);

  var _MaterialInfoPage2 = babelHelpers.interopRequireDefault(_MaterialInfoPage);

  var _AreaEditPage = _require(_dependencyMap[16]);

  var _AreaEditPage2 = babelHelpers.interopRequireDefault(_AreaEditPage);

  var _VoiceManagerPage = _require(_dependencyMap[17]);

  var _VoiceManagerPage2 = babelHelpers.interopRequireDefault(_VoiceManagerPage);

  var _WarnInfoPage = _require(_dependencyMap[18]);

  var _WarnInfoPage2 = babelHelpers.interopRequireDefault(_WarnInfoPage);

  var _CleanLogPage = _require(_dependencyMap[19]);

  var _CleanLogPage2 = babelHelpers.interopRequireDefault(_CleanLogPage);

  var _CleanLogInfo = _require(_dependencyMap[20]);

  var _CleanLogInfo2 = babelHelpers.interopRequireDefault(_CleanLogInfo);

  var _OTAPage = _require(_dependencyMap[21]);

  var _OTAPage2 = babelHelpers.interopRequireDefault(_OTAPage);

  var _CalibrationPage = _require(_dependencyMap[22]);

  var _CalibrationPage2 = babelHelpers.interopRequireDefault(_CalibrationPage);

  var RootStack = (0, _reactNavigation.createStackNavigator)({
    "Home": _HomePage2.default,
    "setting": _SettingPage2.default,
    "robotSetting": _RobotSettingPage2.default,
    "timeZone": _TimeZonePage2.default,
    "volume": _VolumeSettingPage2.default,
    "nodistrub": _NoDisturbPage2.default,
    "generalSetting": _GeneralSettingPage2.default,
    "RemoteControlPage": _RemoteControlPage2.default,
    "timingTask": _TimingTaskPage2.default,
    "addTiming": _AddTimingPage2.default,
    "netInfo": _NetInfoPage2.default,
    "material": _MaterialPage2.default,
    "materialInfo": _MaterialInfoPage2.default,
    "areaEdit": _AreaEditPage2.default,
    "voiceManage": _VoiceManagerPage2.default,
    "warnInfo": _WarnInfoPage2.default,
    "cleanLog": _CleanLogPage2.default,
    "cleanLogInfo": _CleanLogInfo2.default,
    "ota": _OTAPage2.default,
    "calibration": _CalibrationPage2.default
  }, {
    initialRouteName: 'Home',
    navigationOptions: function navigationOptions(_ref) {
      var navigation = _ref.navigation;
      return {
        header: _react2.default.createElement(_ui.TitleBarBlack, {
          title: navigation.state.params ? navigation.state.params.title : '',
          style: {
            backgroundColor: '#fff'
          },
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      };
    },
    transitionConfig: function transitionConfig() {
      return {};
    }
  });

  var App = function (_React$Component) {
    babelHelpers.inherits(App, _React$Component);

    function App() {
      babelHelpers.classCallCheck(this, App);
      return babelHelpers.possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
    }

    babelHelpers.createClass(App, [{
      key: "render",
      value: function render() {
        return _react2.default.createElement(RootStack, null);
      }
    }]);
    return App;
  }(_react2.default.Component);

  exports.default = App;
},10115,[10297,10918,10230,10118,10337,10349,10352,10355,10370,10394,10397,10415,10427,10436,10439,10451,10463,10493,10502,10550,10556,10565,10580],"projects/com.dreame.devices/main/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _miot = _require(_dependencyMap[1]);

  var _reactNative = _require(_dependencyMap[2]);

  var _TitleBarBlack = _require(_dependencyMap[3]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[4]);

  var _MapDataUtil = _require(_dependencyMap[5]);

  var _MapDataUtil2 = babelHelpers.interopRequireDefault(_MapDataUtil);

  var _index = _require(_dependencyMap[6]);

  var _index2 = babelHelpers.interopRequireDefault(_index);

  var _indexv = _require(_dependencyMap[7]);

  var _indexv2 = babelHelpers.interopRequireDefault(_indexv);

  var _reactNativeUiKitten = _require(_dependencyMap[8]);

  var _CleanMap = _require(_dependencyMap[9]);

  var _CleanMap2 = babelHelpers.interopRequireDefault(_CleanMap);

  var _RobotInfoView = _require(_dependencyMap[10]);

  var _RobotInfoView2 = babelHelpers.interopRequireDefault(_RobotInfoView);

  var _CardButton = _require(_dependencyMap[11]);

  var _CardButton2 = babelHelpers.interopRequireDefault(_CardButton);

  var _CleanModeView = _require(_dependencyMap[12]);

  var _CleanModeView2 = babelHelpers.interopRequireDefault(_CleanModeView);

  var _MopModeView = _require(_dependencyMap[13]);

  var _MopModeView2 = babelHelpers.interopRequireDefault(_MopModeView);

  var _ListItemView = _require(_dependencyMap[14]);

  var _ListItemView2 = babelHelpers.interopRequireDefault(_ListItemView);

  var _CopyMessageDialog = _require(_dependencyMap[15]);

  var _CopyMessageDialog2 = babelHelpers.interopRequireDefault(_CopyMessageDialog);

  var _reactNativeShadow = _require(_dependencyMap[16]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var did = _miot.Device.getDeviceWifi().deviceID;

  var styles = _reactNative.StyleSheet.create({
    cardStyle: {
      backgroundColor: '#ffffffff',
      borderWidth: _reactNative.StyleSheet.hairlineWidth,
      borderRadius: 10,
      borderColor: '#ffffffff'
    }
  });

  var reportLogs = [];
  var initTimes = 0;

  var HomePage = function (_React$Component) {
    babelHelpers.inherits(HomePage, _React$Component);

    function HomePage(props) {
      babelHelpers.classCallCheck(this, HomePage);

      var _this = babelHelpers.possibleConstructorReturn(this, (HomePage.__proto__ || Object.getPrototypeOf(HomePage)).call(this, props));

      _initialiseProps.call(_this);

      _this.state = {
        cleanArea: "--",
        cleanTime: '--',
        battery: "--",
        chargeState: -1,
        workMode: -1,
        mainHeight: height,
        openHeight: 155,
        cardHeight: Math.floor((width - 30) / 2 * 230 / 495),
        nextStartTips: (0, _MHLocalizableString.getString)('cleanTimingEmpty'),
        cleanInfoHeight: 69,
        warnCode: 0,
        mapType: Const.MAP_EDIT_TYPE_NULL,
        areaTipVisible: false,
        dialogVisible: false,
        ledMode: 0,
        dialogTitle: "",
        dialogMessage: "",
        descHeight: 0,
        showMopMode: false,
        dialogConfium: null
      };
      _this.startChargingTime = 0;
      _this.hasNewFirmware = false;
      _this.mapDataUtil = mapDataUtil;

      _this.mapDataUtil.setOnErrListener(_this.onErr);

      _this.mapDataUtil.setOnMapInfoListener(_this.onMapInfo);

      Const.status.setOnRefreshDataListener(_this.onRefreshData);
      _this.selectMode = 1;
      _this.lastGetMap = 0;
      _this.lastReceiveMsg = Date.now();
      _this.appState = "";
      _this.materials = [];
      _this.selectMopMode = 2;
      initTimes = 0;
      var materialKey = did + "material";
      _this.materialHasShow = {};

      _miot.Host.storage.load([materialKey + '1', materialKey + '2', materialKey + '3']).then(function (res) {
        console.log("load", res);
        _this.materialHasShow[materialKey + "1"] = res[0] == true;
        _this.materialHasShow[materialKey + "2"] = res[1] == true;
        _this.materialHasShow[materialKey + "3"] = res[2] == true;
      }).catch(function (e) {});

      _this.addReportLog("did:" + did);

      console.log("====did", did);
      return _this;
    }

    babelHelpers.createClass(HomePage, [{
      key: "requestMapData",
      value: function requestMapData(mInfo) {
        var _this2 = this;

        var mInfoData = JSON.stringify({
          frame_type: "I"
        });

        if (mInfo) {
          mInfoData = JSON.stringify({
            map_id: mInfo.mapid,
            frame_id: mInfo.frameid,
            frame_type: "P"
          });
          this.lastGetPMap = Date.now();
        } else {
          if (this.lastGetIMap && Date.now() - this.lastGetIMap < 4500) {
            return;
          }

          this.lastGetIMap = Date.now();
        }

        this.addReportLog(mInfoData);

        _miot.Device.getDeviceWifi().callMethod("action", {
          "did": did,
          "siid": 23,
          "aiid": 1,
          "in": [{
            "piid": 2,
            "value": mInfoData
          }]
        }).then(function (res) {
          _this2.addReportLog("request map success");

          if (res.code == 0 && res.result && res.result.out) {
            for (var i = 0; i < res.result.out.length; i++) {
              var item = res.result.out[i];

              if (item.piid == 1) {
                _this2.mapDataUtil.setMapData(item.value);
              } else if (item.piid == 3) {
                _this2.receiveFdsFile(item.value);
              }
            }
          }

          console.log("------requestMapData-----", res);
        }).catch(function (err) {
          _this2.addReportLog("request map failed");

          console.log('requestMapData failed:', err);
        });
      }
    }, {
      key: "componentWillMount",
      value: function componentWillMount() {
        var _this3 = this;

        this._deviceNameChangedListener = _miot.DeviceEvent.deviceNameChanged.addListener(function (device) {
          _this3.props.navigation.setParams({
            name: device.name
          });

          _this3.forceUpdate();
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _reactNative.AppState.removeEventListener('change', this._handleAppStateChange);

        if (this._deviceNameChangedListener) {
          this._deviceNameChangedListener.remove();
        }

        if (this.willBlurListener) {
          this.willBlurListener.remove();
        }

        if (this.didFocusListener) {
          this.didFocusListener.remove();
        }

        this.clearInter();
        this.clearPollingInter();
        this.didBlurListener && this.didBlurListener.remove();
        this.willFocusListener && this.willFocusListener.remove();

        if (this.msgSubscription) {
          this.msgSubscription.remove();
        }

        if (this.propChangeListener) {
          this.propChangeListener.remove();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this4 = this;

        _reactNative.AppState.addEventListener('change', this._handleAppStateChange);

        this.willBlurListener = this.props.navigation.addListener('willBlur', function () {
          _this4.reportLogsToServer();

          if (_this4.CleanMap) {
            _this4.CleanMap.stopAnimation();
          }

          _this4.actionTime = Date.now();
        });
        this.didBlurListener = this.props.navigation.addListener('didBlur', function () {
          if (_this4.CleanMap) {
            _this4.CleanMap.stopAnimation();
          }

          _this4.actionTime = Date.now();
        });
        this.willFocusListener = this.props.navigation.addListener('willFocus', function () {
          _this4.actionTime = Date.now();
        });
        this.didFocusListener = this.props.navigation.addListener('didFocus', function () {
          _this4.actionTime = Date.now();
          var params = _this4.props.navigation.state.params;
          var updateTitle = {};

          if (gData.hasNewFirmware != _this4.hasNewFirmware) {
            updateTitle.hasNewFirmware = gData.hasNewFirmware == true ? true : false;
          }

          if (params && params.timeZone) {
            if (params.timeZone != gData.timeZone) {
              updateTitle.timeZone = gData.timeZone;
            }
          }

          if (Object.keys(updateTitle).length > 0) {
            _this4.props.navigation.setParams(updateTitle);
          }

          _this4.initTimingTip();

          if (_this4.CleanMap) {
            setTimeout(_this4.startAnimtion, 800);
          }
        });
        this.lastReceiveSubMsgTime = Date.now();
        this.propChangeListener = _miot.DeviceEvent.deviceReceivedMessages.addListener(function (device, messages) {
          if (!_this4.hasReceive) {
            _this4.hasReceive = true;

            _this4.addReportLog("first receive data");
          }

          var prop = null;
          var updateState = {};

          if (messages.has('prop.2.1')) {
            prop = messages.get('prop.2.1');

            if (prop.length > 0) {
              updateState.battery = prop[0] + "";
              Const.status.setBattery(prop[0]);
            }
          } else if (messages.has('prop.2.2')) {
            prop = messages.get('prop.2.2');

            if (prop.length > 0) {
              updateState.chargeState = prop[0];
              var changeToCharging = Const.status.setChargingStatus(prop[0]);

              if (changeToCharging) {
                _this4.startChargingTime = Date.now();

                if (Const.status.hasTask()) {
                  setTimeout(_this4.refreshUI, 8000);
                }

                if (_this4.CleanMap) {
                  console.log("refresh robot");

                  _this4.CleanMap.onMapChange();
                }
              }
            }
          } else if (messages.has('prop.18.1')) {
            prop = messages.get('prop.18.1');

            if (prop.length > 0) {
              updateState.workMode = prop[0];
              gData.workMode = prop[0];
              Const.status.setWorkMode(prop[0]);

              if (_this4.isShowLog && Const.status.isCleaning()) {
                _this4.isShowLog = false;
                updateState.cleanTime = 0;
                updateState.cleanArea = 0;
              }
            }
          } else if (messages.has('prop.18.2')) {
            prop = messages.get('prop.18.2');

            if (prop.length > 0) {
              updateState.cleanTime = prop[0] + "";
            }
          } else if (messages.has('prop.18.3')) {
            prop = messages.get('prop.18.3');

            if (prop.length > 0) {
              updateState.cleanArea = prop[0] + "";
            }
          } else if (messages.has('prop.18.4')) {
            prop = messages.get('prop.18.4');
          } else if (messages.has('prop.18.5')) {
            prop = messages.get('prop.18.5');
            _this4.tasks = prop[0];
            gData.tasks = _this4.tasks;

            var time = _this4.calculateNextStartTime(_this4.tasks);

            if (time > 0) {
              var hour = Math.floor(time / 60);
              var min = Math.floor(time % 60);
              updateState.nextStartTips = (0, _MHLocalizableString.getString)("cleanTimingStart", {
                hour: hour,
                minute: min
              });
            }
          } else if (messages.has('prop.18.6')) {
            prop = messages.get('prop.18.6');
            _this4.selectMode = prop[0];

            if (_this4.cleanModeView) {
              _this4.cleanModeView.setMode(_this4.selectMode);
            }
          } else if (messages.has('prop.18.9')) {
            prop = messages.get('prop.18.9');
            Const.status.setWaterBoxStatus(prop[0]);
          } else if (messages.has('prop.18.17')) {
            prop = messages.get('prop.18.17');
            Const.status.setLedMode(prop[0]);
          } else if (messages.has('prop.18.18')) {
            prop = messages.get('prop.18.18');
            Const.status.setTaskStatus(prop[0]);
          } else if (messages.has('prop.23.1')) {
            prop = messages.get('prop.23.1');
            _this4.lastReceiveSubMsgTime = Date.now();

            if (prop && Array.isArray(prop) && prop.length > 0) {
              var mapData = prop[0];
              _this4.hasReceiveMap = true;

              _this4.receiveMsg(mapData);
            }
          } else if (messages.has('prop.23.3')) {
            prop = messages.get('prop.23.3');
            _this4.lastReceiveSubMsgTime = Date.now();

            if (prop && Array.isArray(prop) && prop.length > 0) {
              var _objname = prop[0];
              _this4.hasReceiveMap = true;

              _this4.receiveFdsFile(_objname);
            }
          } else if (messages.has('prop.22.1')) {
            prop = messages.get('prop.22.1');
            updateState.warnCode = prop[0];
            Const.status.setWarnCode(updateState.warnCode);
          } else if (messages.has('event.22.1')) {
            prop = messages.get('event.22.1');

            if (Array.isArray(prop) && prop.length > 0) {
              for (var i = 0; i < prop.length; i++) {
                if (prop[i].piid == 1) {
                  updateState.warnCode = prop[i].value;
                  Const.status.setWarnCode(updateState.warnCode);
                  break;
                }
              }
            }
          } else if (messages.has('event.18.1')) {
            prop = messages.get('event.18.1');

            if (Array.isArray(prop) && prop.length > 0) {
              var lastLog = {};

              for (var _i = 0; _i < prop.length; _i++) {
                var pvalue = prop[_i];

                if (pvalue.piid == 2) {
                  lastLog.time = pvalue.value;
                } else if (pvalue.piid == 3) {
                  lastLog.cleanArea = pvalue.value;
                } else if (pvalue.piid == 11) {
                  lastLog.fileName = pvalue.value;
                }
              }

              _this4.lastLog = lastLog;

              if (_this4.lastLog.fileName) {
                _this4.isShowLog = true;

                _this4.loadMapFile(_this4.lastLog.fileName);
              }
            }
          } else if (messages.has('prop.26.2')) {
            prop = messages.get('prop.26.2');
            var level = prop[0];

            if (level > 5) {
              _this4.deleteMaterialCard(3);
            }
          } else if (messages.has('prop.27.1')) {
            prop = messages.get('prop.27.1');
            var _level = prop[0];

            if (_level > 5) {
              _this4.deleteMaterialCard(1);
            }
          } else if (messages.has('prop.28.2')) {
            prop = messages.get('prop.28.2');
            var _level2 = prop[0];

            if (_level2 > 5) {
              _this4.deleteMaterialCard(2);
            }
          }

          var currentTitle = Const.status.getStatusText();

          if (_this4.workMode != currentTitle) {
            _this4.workMode = currentTitle;

            _this4.props.navigation.setParams({
              subTitle: _this4.workMode
            });
          }

          if (Object.keys(updateState).length > 0) {
            for (var key in updateState) {
              _this4.state[key] = updateState[key];
            }
          }

          _this4.forceUpdate();

          if (Const.status.hasWarn()) {
            _this4.CleanMap.setDeviceStatus(3);
          } else if (Const.status.isCleaning()) {
            _this4.CleanMap.setDeviceStatus(1);
          } else if (Const.status.isCharging()) {
            _this4.CleanMap.setDeviceStatus(2);
          } else if (Const.status.isSleep()) {
            _this4.CleanMap.setDeviceStatus(4);
          } else {
            _this4.CleanMap.setDeviceStatus(0);
          }
        });
        this.msgSubscription = null;
        this.subscribeTimes = 0;
        this.subscribeMessages();
        this.checkPrivacy();
        this.requestMapData();
        this.initData1();
        this.startInterval();
      }
    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        var Drawer = _index2.default;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: {
              flex: 1
            },
            onLayout: this.handleSetViewport
          },
          _react2.default.createElement(_CopyMessageDialog2.default, {
            visible: this.state.dialogVisible,
            title: this.state.dialogTitle,
            message: this.state.dialogMessage,
            buttons: [{
              text: (0, _MHLocalizableString.getString)('cancle'),
              callback: function callback(_) {
                return _this5.dismissTip();
              }
            }, {
              text: (0, _MHLocalizableString.getString)('sure'),
              style: {
                color: '#5696ff'
              },
              callback: function callback(_) {
                _this5.state.dialogConfium();

                _this5.dismissTip();
              }
            }],
            onDismiss: this.dismissTip
          }),
          _react2.default.createElement(
            Drawer,
            {
              styles: {
                drawer: {},
                main: {},
                backgroundColor: '#fff'
              },
              ref: function ref(c) {
                return _this5.drawer = c;
              },
              openDrawerOffset: this.state.openHeight,
              sliderType: this.state.showMopMode ? 1 : 0,
              content: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_CleanMap2.default, {
                  ref: function ref(_ref) {
                    _this5.CleanMap = _ref;
                  },
                  mapDataUtil: this.mapDataUtil,
                  width: width,
                  height: this.state.mainHeight,
                  openDrawerOffset: this.state.openHeight,
                  checkFocused: this.checkFocused,
                  cleanInfoHeight: this.state.cleanInfoHeight
                })
              ),
              messageHeight: this.state.cleanInfoHeight,
              message: _react2.default.createElement(
                _reactNative.View,
                {
                  style: {
                    width: width,
                    height: this.state.cleanInfoHeight
                  }
                },
                _react2.default.createElement(
                  _reactNative.View,
                  {
                    style: {
                      flexDirection: "row",
                      width: width,
                      height: this.state.cleanInfoHeight - Const.onePixel,
                      paddingLeft: 20,
                      paddingRight: 20,
                      backgroundColor: "#fff"
                    }
                  },
                  _react2.default.createElement(_RobotInfoView2.default, {
                    minDescHeight: this.state.descHeight,
                    onHeight: this.onRobotInfoDescHeight,
                    desc: (0, _MHLocalizableString.getString)('cleaned'),
                    value: this.state.cleanArea,
                    unit: (0, _MHLocalizableString.getString)("areaUnit")
                  }),
                  _react2.default.createElement(_RobotInfoView2.default, {
                    minDescHeight: this.state.descHeight,
                    onHeight: this.onRobotInfoDescHeight,
                    desc: (0, _MHLocalizableString.getString)('cleantime'),
                    value: this.state.cleanTime,
                    isTime: true,
                    unit: "'"
                  }),
                  _react2.default.createElement(_RobotInfoView2.default, {
                    minDescHeight: this.state.descHeight,
                    onHeight: this.onRobotInfoDescHeight,
                    desc: (0, _MHLocalizableString.getString)('surplusPower'),
                    value: this.state.battery,
                    unit: "%"
                  }),
                  this.state.mapType != Const.MAP_EDIT_TYPE_NULL ? _react2.default.createElement(
                    _reactNative.View,
                    {
                      style: {
                        position: "absolute",
                        width: width,
                        height: this.state.cleanInfoHeight,
                        backgroundColor: "#fff"
                      },
                      justifyContent: "center",
                      alignItems: "center"
                    },
                    _react2.default.createElement(
                      _reactNative.Text,
                      {
                        style: {
                          color: "rgba(0,0,0,0.6)",
                          fontSize: 15,
                          fontFamily: Const.fontFamily
                        }
                      },
                      (0, _MHLocalizableString.getString)('spotTips')
                    )
                  ) : null
                ),
                _react2.default.createElement(_reactNative.View, {
                  style: {
                    width: width,
                    height: Const.onePixel,
                    backgroundColor: 'rgba(0,0,0,0.15)'
                  }
                })
              )
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  padding: 10
                },
                onLayout: this.handleSetSlider
              },
              Const.status.showRemoveWaterBoxTip() ? _react2.default.createElement(
                _reactNativeShadow.BoxShadow,
                {
                  setting: {
                    width: width - 20,
                    height: this.state.cardHeight,
                    color: "#000",
                    border: 5,
                    radius: 11,
                    opacity: 0.03,
                    x: 0,
                    y: 3,
                    style: {
                      marginVertical: 0,
                      marginBottom: 10
                    }
                  }
                },
                _react2.default.createElement(_ListItemView2.default, {
                  style: {
                    borderTopLeftRadius: 11,
                    borderTopRightRadius: 11,
                    borderBottomRightRadius: 11,
                    borderBottomLeftRadius: 11,
                    height: this.state.cardHeight
                  },
                  title: (0, _MHLocalizableString.getString)('removeWaterBoxTitle'),
                  tips: (0, _MHLocalizableString.getString)('removeWaterBoxMessage'),
                  nomalImage: _require(_dependencyMap[17])
                })
              ) : Const.status.showKeepSweeperTip() && Date.now() - this.startChargingTime > 7000 ? _react2.default.createElement(
                _reactNativeShadow.BoxShadow,
                {
                  setting: {
                    width: width - 20,
                    height: this.state.keepSweeperHeight || this.state.cardHeight,
                    color: "#000",
                    border: 5,
                    radius: 11,
                    opacity: 0.03,
                    x: 0,
                    y: 3,
                    style: {
                      marginVertical: 0,
                      marginBottom: 10
                    }
                  }
                },
                _react2.default.createElement(_ListItemView2.default, {
                  style: {
                    borderTopLeftRadius: 11,
                    borderTopRightRadius: 11,
                    borderBottomRightRadius: 11,
                    borderBottomLeftRadius: 11,
                    paddingTop: 5,
                    paddingBottom: 5,
                    minHeight: this.state.cardHeight
                  },
                  onCardHeightChange: this.onCardHeightChange,
                  title: (0, _MHLocalizableString.getString)('keepSweeperTitle'),
                  tips: (0, _MHLocalizableString.getString)('keepSweeperMessage'),
                  tipLineNum: 5,
                  nomalImage: _require(_dependencyMap[17])
                })
              ) : this.renderMaterialCard(),
              this.state.warnCode != 0 && (0, _MHLocalizableString.getString)('warnInfo')[this.state.warnCode] ? _react2.default.createElement(
                _reactNativeShadow.BoxShadow,
                {
                  setting: {
                    width: width - 20,
                    height: this.state.cardHeight,
                    color: "#000",
                    border: 5,
                    radius: 11,
                    opacity: 0.03,
                    x: 0,
                    y: 3,
                    style: {
                      marginVertical: 0,
                      marginBottom: 10
                    }
                  }
                },
                _react2.default.createElement(_ListItemView2.default, {
                  style: {
                    borderTopLeftRadius: 11,
                    borderTopRightRadius: 11,
                    borderBottomRightRadius: 11,
                    borderBottomLeftRadius: 11,
                    height: this.state.cardHeight
                  },
                  onPress: this.state.warnCode == "20" ? undefined : this.goWarnInfo,
                  title: (0, _MHLocalizableString.getString)('warnInfo')[this.state.warnCode].title,
                  tips: (0, _MHLocalizableString.getString)('warnInfo')[this.state.warnCode].desc,
                  nomalImage: _require(_dependencyMap[18])
                })
              ) : null,
              _react2.default.createElement(
                _reactNative.View,
                {
                  style: {
                    flexDirection: "row",
                    width: width - 20,
                    height: this.state.cardHeight
                  }
                },
                _react2.default.createElement(_CardButton2.default, {
                  style: {
                    marginLeft: 0,
                    height: this.state.cardHeight,
                    width: (width - 30) / 2
                  },
                  nomalImage: this.isCharging() ? _require(_dependencyMap[19]) : _require(_dependencyMap[20]),
                  text: this.getChargeText(),
                  onPress: function onPress() {
                    _this5.startCharge(true);
                  }
                }),
                _react2.default.createElement(_CardButton2.default, {
                  style: {
                    marginLeft: 10,
                    height: this.state.cardHeight,
                    width: (width - 30) / 2
                  },
                  nomalImage: this.isCLean() ? _require(_dependencyMap[21]) : _require(_dependencyMap[22]),
                  text: this.isCLean() ? (0, _MHLocalizableString.getString)("cleanPause") : (0, _MHLocalizableString.getString)("cleanStart"),
                  onPress: function onPress() {
                    _this5.startClean();
                  }
                })
              ),
              _react2.default.createElement(_CleanModeView2.default, {
                ref: function ref(_ref2) {
                  _this5.cleanModeView = _ref2;
                },
                style: {
                  height: 508 * (width - 20) / 1020
                },
                selectMode: this.selectMode,
                onModeSelect: this.changeMode
              }),
              this.state.showMopMode ? _react2.default.createElement(_MopModeView2.default, {
                ref: function ref(_ref3) {
                  _this5.mopModeView = _ref3;
                },
                style: {
                  height: 508 * (width - 20) / 1020
                },
                selectMode: this.selectMopMode - 1,
                onModeSelect: this.changeMopMode
              }) : null,
              _react2.default.createElement(
                _reactNativeShadow.BoxShadow,
                {
                  setting: {
                    width: width - 20,
                    height: this.state.cardHeight * 2 + 1 / _reactNative.PixelRatio.get(),
                    color: "#000",
                    border: 5,
                    radius: 11,
                    opacity: 0.03,
                    x: 0,
                    y: 3,
                    style: {
                      marginVertical: 0
                    }
                  }
                },
                _react2.default.createElement(
                  _reactNative.View,
                  {
                    style: {
                      height: this.state.cardHeight * 2 + 1 / _reactNative.PixelRatio.get(),
                      width: width - 20
                    }
                  },
                  _react2.default.createElement(_ListItemView2.default, {
                    style: {
                      borderTopLeftRadius: 11,
                      borderTopRightRadius: 11,
                      height: this.state.cardHeight
                    },
                    onPress: this.goTimingTasks,
                    title: (0, _MHLocalizableString.getString)('cleanTiming'),
                    tips: this.state.nextStartTips,
                    nomalImage: _require(_dependencyMap[23])
                  }),
                  _react2.default.createElement(_reactNative.View, {
                    style: {
                      height: 1 / _reactNative.PixelRatio.get(),
                      backgroundColor: '#e5e5e5'
                    }
                  }),
                  _react2.default.createElement(_ListItemView2.default, {
                    style: {
                      borderBottomRightRadius: 11,
                      borderBottomLeftRadius: 11,
                      height: this.state.cardHeight
                    },
                    onPress: this.goVoiceManage,
                    title: (0, _MHLocalizableString.getString)('robotVoice'),
                    nomalImage: _require(_dependencyMap[24])
                  })
                )
              )
            )
          )
        );
      }
    }]);
    return HomePage;
  }(_react2.default.Component);

  HomePage.navigationOptions = function (_ref4) {
    var navigation = _ref4.navigation;
    var showDot = navigation.state["params"] && (navigation.state.params.hasNewFirmware === true || navigation.state.params.timeZone != undefined && navigation.state.params.timeZone != gData.localTimeZone);
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: navigation.state["params"] && navigation.state.params.name ? navigation.state.params.name : _miot.Device.name,
          style: {
            backgroundColor: '#fff'
          },
          showDot: showDot,
          subTitle: navigation.state["params"] && navigation.state.params.subTitle ? navigation.state.params.subTitle : (0, _MHLocalizableString.getString)('loading'),
          onPressLeft: function onPressLeft() {
            _miot.Package.exit();
          },
          onPressRight: function onPressRight() {
            navigation.navigate("setting", {
              hasNewFirmware: navigation.state["params"] && navigation.state.params.hasNewFirmware === true
            });
          }
        })
      )
    };
  };

  var _initialiseProps = function _initialiseProps() {
    var _this6 = this;

    this.onRefreshData = function () {
      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 2,
        "piid": 1
      }, {
        "did": did,
        "siid": 2,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 1
      }, {
        "did": did,
        "siid": 18,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 3
      }, {
        "did": did,
        "siid": 18,
        "piid": 18
      }, {
        "did": did,
        "siid": 22,
        "piid": 1
      }]).then(function (res) {
        if (res.code == 0) {
          _this6.showData(res.result);
        } else {
          return Promise.reject({
            err: "onRefreshData err"
          });
        }
      }).catch(function (err) {
        console.log("onRefreshData data:", err);
      });
    };

    this.onErr = function (errCode, mInfo) {
      if (errCode == 1) {
        _this6.requestMapData();
      } else if (errCode == 2) {
        if (_this6.lastGetPMap == undefined) {
          _this6.requestMapData(mInfo);
        } else if (_this6.lastGetPMap && Date.now() - _this6.lastGetPMap > 1100) {
          _this6.requestMapData(mInfo);
        }
      }
    };

    this.checkFocused = function () {
      console.log("--cFocused", _this6.props.navigation.isFocused());

      if (_this6.actionTime) {
        if (Date.now() - _this6.actionTime <= 790) {
          return false;
        }
      }

      return _this6.props.navigation.isFocused();
    };

    this.receiveFdsFile = function (objname) {
      _this6.addReportLog("InterimFile:" + objname);

      var self = _this6;
      objname = objname.replace(/\//g, "/");

      _miot.Service.smarthome.getInterimFileUrl({
        obj_name: objname
      }).then(function (res) {
        _this6.addReportLog("InterimFileUrl:" + res.url);

        fetch(res.url).then(function (res) {
          return res.text();
        }).then(function (resData) {
          _this6.addReportLog("InterimFileData");

          console.log("----fds--getInterimFileUrl:");
          self.receiveMsg(resData);
        }).catch(function (err) {
          _this6.addReportLog("InterimFileDataERR");
        });
      }).catch(function (err) {
        console.log("----", err, _miot.Service.account.ID);
      });
    };

    this.receiveMsg = function (msg) {
      if (_this6.rdate) {
        console.log("-----mapDate:" + (Date.now() - _this6.rdate));
      }

      _this6.rdate = Date.now();
      console.log(msg);

      _this6.mapDataUtil.setMapData(msg);
    };

    this.onMapInfo = function (mapInfo) {
      if (mapInfo && mapInfo.frame_type == 73 && mapInfo.dataIntegrity) {
        _this6.hasReceiveIFrame = true;
      }

      if (!_this6.receiveFristI && mapInfo && mapInfo.frame_type == 73) {
        _this6.receiveFristI = true;

        _this6.addReportLog("receive I:" + JSON.stringify(mapInfo));
      }
    };

    this.handleSetViewport = function (e) {
      var height = e.nativeEvent.layout.height;

      if (!Const.contentViewHeight || Const.contentViewHeight != height) {
        Const.contentViewHeight = height;
      }

      if (_this6.state.mainHeight != height && height > 0) {
        _this6.setState({
          mainHeight: height
        });
      }
    };

    this.handleSetSlider = function (e) {
      if (_this6.drawer) {
        _this6.drawer.setSliderHeight(e.nativeEvent.layout.height);
      }
    };

    this._handleAppStateChange = function (nextAppState) {
      if (_this6.appState == undefined) {
        _this6.appState = "";
      }

      if (_this6.appState.match(/inactive|background/) && nextAppState === 'active') {
        if (_this6.lastReceiveMsg) {
          _this6.addReportLog("active:inactive time is" + new Date(_this6.lastReceiveMsg).toString());
        } else {
          _this6.addReportLog("active:lastReceiveMsg is null");
        }

        _this6.hasReceive = false;

        if (Date.now() - _this6.lastReceiveMsg > 30000) {
          _this6.receiveFristI = false;

          _this6.requestMapData();

          _this6.refreshData();
        }
      } else if (nextAppState === 'active') {
        _this6.addReportLog("active last app state:" + _this6.appState);
      }

      if (nextAppState.match(/inactive|background/)) {
        _this6.lastReceiveMsg = Date.now();
      }

      _this6.appState = nextAppState;
    };

    this.initTimingTip = function () {
      if (gData.tasks != undefined && _this6.tasks != undefined) {
        if (gData.tasks != _this6.tasks) {
          _this6.tasks = gData.tasks;
        }

        var updateState = {};

        var time = _this6.calculateNextStartTime(_this6.tasks);

        if (time > 0) {
          var hour = Math.floor(time / 60);
          var min = Math.floor(time % 60);
          updateState.nextStartTips = (0, _MHLocalizableString.getString)("cleanTimingStart", {
            hour: hour,
            minute: min
          });
        } else {
          updateState.nextStartTips = (0, _MHLocalizableString.getString)('cleanTimingEmpty');
        }

        _this6.setState(updateState);
      }
    };

    this.startAnimtion = function () {
      if (_this6.CleanMap) {
        _this6.CleanMap.startAnimtion();
      }
    };

    this.subscribeMessages = function () {
      _this6.subscribeStatus = 1;
      _this6.subscribeTimes++;

      _miot.Device.getDeviceWifi().subscribeMessages('prop.2.1', 'prop.2.2', 'prop.18.1', 'prop.18.2', 'prop.18.3', 'prop.18.4', 'prop.18.5', 'prop.18.6', 'prop.18.9', 'prop.18.18', 'prop.23.1', 'prop.23.3', 'event.22.1', 'prop.22.1', 'event.18.1', 'prop.26.2', 'prop.27.1', 'prop.28.2', 'prop.18.20').then(function (subcription) {
        _this6.msgSubscription = subcription;
        _this6.subscribeStatus = 2;

        _this6.addReportLog("subscribe success");

        console.log('subscribe success');
      }).catch(function (e) {
        _this6.subscribeStatus = 0;

        _this6.addReportLog("subscribe failed");
      });
    };

    this.clearInter = function () {
      console.log("clearInter");

      if (_this6.interval) {
        clearInterval(_this6.interval);
        _this6.interval = null;
      }
    };

    this.startInterval = function () {
      _this6.clearInter();

      _this6.startIntervalTime = Date.now();
      _this6.interval = setInterval(function () {
        var allSuccess = true;

        var _time = Date.now() - _this6.startIntervalTime;

        if (_time > 900000) {
          _this6.clearInter();

          return;
        }

        if (_this6.deviceOffine) {
          _this6.clearInter();

          return;
        }

        console.log(_this6.initStatus1, _this6.initStatus2, _this6.subscribeStatus, _this6.hasReceiveIFrame);

        if (_this6.initStatus1 != 2) {
          allSuccess = false;
        }

        if (_this6.initStatus2 != 2) {
          allSuccess = false;
        }

        if (_this6.subscribeStatus != 2 && _this6.subscribeTimes < 10) {
          allSuccess = false;
        }

        if (_this6.initStatus1 == undefined || _this6.initStatus1 == 0) {
          _this6.initData1();
        }

        if (_this6.initStatus1 == 2 && (_this6.initStatus2 == undefined || _this6.initStatus2 == 0)) {
          _this6.initData2();
        }

        if ((_this6.subscribeStatus == undefined || _this6.subscribeStatus == 0) && _this6.subscribeTimes < 10) {
          _this6.subscribeMessages();
        }

        if (!_this6.hasReceiveIFrame && _this6.initStatus1 == 2 && Const.status.hasTask()) {
          allSuccess = false;

          _this6.requestMapData();
        }

        if (allSuccess) {
          _this6.clearInter();

          _this6.startPollingInterval();
        }
      }, 2000);
    };

    this.clearPollingInter = function () {
      console.log("clearPollingInter");

      if (_this6.pollingInterval) {
        clearInterval(_this6.pollingInterval);
        _this6.pollingInterval = null;
      }
    };

    this.startPollingInterval = function () {
      _this6.clearPollingInter();

      if (!_this6.mapDataUtil.hasLastTimestamp()) {
        return;
      }

      var times = 0;
      _this6.pollingInterval = setInterval(function () {
        if (_this6.subscribeStatus != 2 || Date.now() - _this6.lastReceiveSubMsgTime > 15000) {
          times++;

          if (Const.status.isGoCharing() || Const.status.isCleaning()) {
            var lastMapTime = _this6.mapDataUtil.getLastTimestamp();

            if (lastMapTime && Date.now() - lastMapTime.timestamp < 30000) {
              _this6.requestPMaps(lastMapTime);
            } else {
              _this6.clearPollingInter();

              _this6.hasReceiveIFrame = false;

              _this6.startInterval();
            }

            if (times % 5 == 0) {
              _this6.refreshPollingData();
            }
          }

          if (times > 3600) {
            times = 0;
          }
        }
      }, 10000);
    };

    this.requestPMaps = function (lastMapTime) {
      var startTime = lastMapTime.timestamp;
      var mapStrs = {};

      _miot.Service.smarthome.getDeviceData({
        did: did,
        uid: _miot.Service.account.ID,
        key: "23.1",
        type: "prop",
        time_start: Math.ceil(startTime / 1000),
        time_end: Math.floor(Date.now()),
        limit: 20
      }).then(function (res) {
        console.log("requestPMaps", startTime, res.length);
        var map_id = lastMapTime.map_id;
        var frame_id = lastMapTime.frame_id;
        var iMap = undefined;

        for (var i = 0; i < res.length; i++) {
          var item = res[i];
          var pmap = JSON.parse(item.value)[0];

          var pmapInfo = _this6.mapDataUtil.decodeMapData(pmap);

          if (pmapInfo) {
            if (pmapInfo.map_id > map_id) {
              map_id = pmapInfo.map_id;
            }

            if (pmapInfo.map_id < map_id) {
              continue;
            }

            if (pmapInfo.frame_id <= frame_id) {
              continue;
            }

            mapStrs[pmapInfo.frame_id] = pmap;

            if (pmapInfo.frame_type == 73) {
              iMap = {
                map_id: pmapInfo.map_id,
                frame_id: pmapInfo.frame_id,
                map: pmap
              };
              break;
            }
          }
        }

        if (iMap) {
          if (lastMapTime.map_id == iMap.map_id) {
            _this6.mapDataUtil.setPMaps(iMap.map, mapStrs);
          }
        } else {
          var ids = Object.keys(mapStrs);

          if (ids.length > 0) {
            var min = parseInt(ids[0]);
            var max = parseInt(ids[0]);

            for (var _i2 = 0; _i2 < ids.length; _i2++) {
              var k = parseInt(ids[_i2]);

              if (k < min) {
                min = k;
              }

              if (k > max) {
                max = k;
              }
            }

            var fristMap = mapStrs[frame_id + 1];

            if (max - min == ids.length - 1 && fristMap) {
              delete mapStrs[frame_id + 1];

              if (fristMap) {
                _this6.mapDataUtil.setPMaps(fristMap, mapStrs);
              }
            } else {
              return _miot.Service.smarthome.getDeviceData({
                did: did,
                uid: _miot.Service.account.ID,
                key: "23.3",
                type: "prop",
                time_start: Math.ceil(startTime / 1000),
                time_end: Math.floor(Date.now()),
                limit: 1
              });
            }
          }
        }
      }).then(function (res) {
        console.log("requestIMaps", startTime, res);

        if (!res || res.length == 0) {
          return;
        } else {
          var item = res[0];
          var fileName = JSON.parse(item.value)[0];
          objname = fileName.replace(/\//g, "/");
          return _miot.Service.smarthome.getInterimFileUrl({
            obj_name: objname
          });
        }
      }).then(function (res) {
        return fetch(res.url);
      }).then(function (res) {
        return res.text();
      }).then(function (resData) {
        var fristMap = resData;

        var pmapInfo = _this6.mapDataUtil.decodeMapData(fristMap);

        var ids = Object.keys(mapStrs);

        if (ids.length > 0) {
          for (var i = 0; i < ids.length; i++) {
            var id = ids[i];
            var k = parseInt(ids[i]);

            if (pmapInfo.frame_id >= k) {
              delete mapStrs[k];
            }
          }
        }

        _this6.mapDataUtil.setPMaps(fristMap, mapStrs);
      }).catch(function (e) {});
    };

    this.checkPrivacy = function () {
      _miot.Service.smarthome.batchGetDeviceDatas([{
        did: _miot.Device.deviceID,
        props: ["prop.s_auth_config"]
      }]).then(function (res) {
        console.log("-----", res);
        var alreadyAuthed = false;
        var result = res[_miot.Device.deviceID];
        var config = void 0;

        if (result && result['prop.s_auth_config']) {
          config = result['prop.s_auth_config'];
        }

        if (config) {
          try {
            var authJson = JSON.parse(config);
            alreadyAuthed = authJson.privacyAuthed && true;
          } catch (err) {}
        }

        if (alreadyAuthed) {
          _this6.checkUpgrading();

          return new Promise.resolve("已经授权");
        } else {
          return _miot.Host.ui.openPrivacyLicense((0, _MHLocalizableString.getString)('licenseTitle'), Const.license, (0, _MHLocalizableString.getString)('policyTitle'), Const.policy).then(function (res) {
            console.log('授权结果', res);

            if (res) {
              _this6.checkUpgrading();

              return _miot.Service.smarthome.batchSetDeviceDatas([{
                did: _miot.Device.deviceID,
                props: {
                  "prop.s_auth_config": JSON.stringify({
                    'privacyAuthed': 'true'
                  })
                }
              }]);
            } else {
              return new Promise.reject("取消授权");
            }
          });
        }
      }).catch(function (err) {
        console.log('授权错误', err);

        _miot.Package.exit();
      });
    };

    this.refreshUI = function () {
      if (Const.status.hasTask()) {
        _this6.forceUpdate();
      }
    };

    this.addReportLog = function (desc) {};

    this.reportLogsToServer = function () {
      if (reportLogs.length > 0) {
        var logs = JSON.stringify(reportLogs);
        reportLogs = [];

        _miot.Service.smarthome.reportLog(_miot.Device.model, logs);
      }
    };

    this.initData1 = function () {
      _this6.initStatus1 = 1;

      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 2,
        "piid": 1
      }, {
        "did": did,
        "siid": 2,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 1
      }, {
        "did": did,
        "siid": 18,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 3
      }, {
        "did": did,
        "siid": 18,
        "piid": 6
      }, {
        "did": did,
        "siid": 18,
        "piid": 9
      }, {
        "did": did,
        "siid": 18,
        "piid": 16
      }, {
        "did": did,
        "siid": 18,
        "piid": 18
      }, {
        "did": did,
        "siid": 18,
        "piid": 20
      }]).then(function (res) {
        console.log("init1", res);

        if (res.code == 0) {
          _this6.initStatus1 = 2;

          _this6.showData(res.result);

          _this6.addReportLog("success1");
        } else {
          return Promise.reject({
            err: "response1 err"
          });
        }
      }).catch(function (err) {
        if (err && err.error == -2) {
          _this6.deviceOffine = true;
        }

        _this6.initStatus1 = 0;
        console.log("init1 data:", err);
      });
    };

    this.initData2 = function () {
      _this6.initStatus2 = 1;

      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 22,
        "piid": 1
      }, {
        "did": did,
        "siid": 25,
        "piid": 1
      }, {
        "did": did,
        "siid": 18,
        "piid": 5
      }, {
        "did": did,
        "siid": 19,
        "piid": 1
      }, {
        "did": did,
        "siid": 19,
        "piid": 2
      }, {
        "did": did,
        "siid": 19,
        "piid": 3
      }]).then(function (res) {
        if (res.code == 0) {
          _this6.initStatus2 = 2;
          console.log("----init2", res.result);

          _this6.showData(res.result);

          _this6.addReportLog("success1");
        } else {
          return Promise.reject({
            err: "response1 err"
          });
        }
      }).catch(function (err) {
        _this6.initStatus2 = 0;
        console.log("init2 data:", err);
      });
    };

    this.showData = function (result) {
      var updateState = {};

      for (var i = 0; i < result.length; i++) {
        var item = result[i];

        if (item.code != 0) {
          continue;
        }

        switch (item.siid) {
          case 2:
            if (item.piid == 1) {
              if (item.value < 0) {
                updateState.battery = "0";
              } else if (item.value > 100) {
                updateState.battery = "100";
              } else {
                updateState.battery = item.value + "";
              }
            } else if (item.piid == 2) {
              updateState.chargeState = item.value;
              Const.status.setChargingStatus(item.value);
            }

            break;

          case 25:
            if (item.piid == 1) {
              var timeZone = item.value;
              gData.timeZone = timeZone;

              _this6.props.navigation.setParams({
                timeZone: timeZone
              });
            }

            break;

          case 18:
            if (item.piid == 1) {
              updateState.workMode = item.value;
              gData.workMode = item.value;
              Const.status.setWorkMode(item.value);

              if (_this6.isShowLog && Const.status.isCleaning()) {
                _this6.isShowLog = false;
                updateState.cleanTime = 0;
                updateState.cleanArea = 0;
              }
            } else if (item.piid == 2) {
              updateState.cleanTime = item.value;
            } else if (item.piid == 3) {
              updateState.cleanArea = item.value;
            } else if (item.piid == 4) {} else if (item.piid == 5) {
              _this6.tasks = item.value;
              gData.tasks = item.value;

              var time = _this6.calculateNextStartTime(_this6.tasks);

              if (time > 0) {
                var hour = Math.floor(time / 60);
                var min = Math.floor(time % 60);
                updateState.nextStartTips = (0, _MHLocalizableString.getString)("cleanTimingStart", {
                  hour: hour,
                  minute: min
                });
              }
            } else if (item.piid == 6) {
              _this6.selectMode = item.value;
            } else if (item.piid == 9) {
              Const.status.setWaterBoxStatus(item.value);
            } else if (item.piid == 16) {
              _this6.logStartTime = item.value;

              if (_this6.logStartTime == 0) {
                _this6.logStartTime = Math.floor(Date.now() / 1000) - 5;
              }

              _this6.requestLastCleanInfo();
            } else if (item.piid == 17) {
              updateState.ledMode = item.value;
              Const.status.setLedMode(item.value);
            } else if (item.piid == 18) {
              updateState.taskStatus = item.value;
              Const.status.setTaskStatus(item.value);
            } else if (item.piid == 20) {
              _this6.selectMopMode = item.value;
            }

            break;

          case 22:
            if (item.piid == 1) {
              updateState.warnCode = item.value;
              Const.status.setWarnCode(updateState.warnCode);
            }

            break;

          case 19:
            var value = item.value;
            var data = value.split("-");
            var percent = Math.floor(data[1] * 100 / data[0]);
            var materialKey = did + "material" + item.piid;

            if (percent <= 5 && percent > 0 && !_this6.materialHasShow[materialKey]) {
              _this6.addMaterial(item.piid, percent, value);
            } else if (percent == 0) {
              _this6.addMaterial(item.piid, percent, value);
            } else if (percent > 5 && _this6.materialHasShow[materialKey]) {
              _miot.Host.storage.set(materialKey, false);
            }

            break;

          default:
            break;
        }
      }

      var currentTitle = Const.status.getStatusText();

      if (_this6.workMode != currentTitle) {
        _this6.workMode = currentTitle;

        _this6.props.navigation.setParams({
          subTitle: _this6.workMode
        });
      }

      if (Const.status.hasWarn()) {
        _this6.CleanMap.setDeviceStatus(3);
      } else if (Const.status.isCleaning()) {
        _this6.CleanMap.setDeviceStatus(1);
      } else if (Const.status.isCharging()) {
        _this6.CleanMap.setDeviceStatus(2);
      } else if (Const.status.isSleep()) {
        _this6.CleanMap.setDeviceStatus(4);
      } else {
        _this6.CleanMap.setDeviceStatus(0);
      }

      if (updateState.chargeState != undefined || updateState.workMode != undefined) {
        if (updateState.chargeState != undefined) {
          _this6.state.chargeState = updateState.chargeState;
        }

        if (updateState.workMode != undefined) {
          _this6.state.workMode = updateState.workMode;
        }
      }

      if (!Const.status.isCleaning() && !Const.status.hasTask() && _this6.state.cleanArea != "--") {
        delete updateState.cleanArea;
        delete updateState.cleanTime;
      }

      _this6.setState(updateState);

      if (_this6.cleanModeView) {
        _this6.cleanModeView.setMode(_this6.selectMode);
      }

      if (_this6.mopModeView) {
        _this6.mopModeView.setMode(_this6.selectMopMode - 1);
      }
    };

    this.deleteMaterialCard = function (type) {
      if (_this6.materials.length > 0) {
        var newMaterials = _this6.materials.filter(function (item) {
          return item.type != type;
        });

        if (newMaterials.length != _this6.materials.length) {
          _this6.materials = newMaterials;

          _this6.forceUpdate();
        }
      }
    };

    this.addMaterial = function (type, level, state) {
      var value = level;
      var tip = undefined;

      if (type == 1) {
        if (value <= 5 && value > 0) {
          tip = {
            title: (0, _MHLocalizableString.getString)('heapWarnTitle1'),
            message: (0, _MHLocalizableString.getString)('heapWarnMsg1'),
            type: type
          };
        } else if (value == 0) {
          tip = {
            title: (0, _MHLocalizableString.getString)('heapWarnTitle2'),
            message: (0, _MHLocalizableString.getString)('heapWarnMsg2'),
            type: type
          };
        } else {}
      } else if (type == 2) {
        if (value <= 5 && value > 0) {
          tip = {
            title: (0, _MHLocalizableString.getString)('slidBrushWarnTipTitle1'),
            message: (0, _MHLocalizableString.getString)('slidBrushWarnTipMsg1'),
            type: type
          };
        } else if (value == 0) {
          tip = {
            title: (0, _MHLocalizableString.getString)('slidBrushWarnTipTitle2'),
            message: (0, _MHLocalizableString.getString)('slidBrushWarnTipMsg2'),
            type: type
          };
        } else {}
      } else if (type == 3) {
        if (value <= 5 && value > 0) {
          tip = {
            title: (0, _MHLocalizableString.getString)('rollingBrushWarnTitle1'),
            message: (0, _MHLocalizableString.getString)('rollingBrushWarnMsg1'),
            type: type
          };
        } else if (value == 0) {
          tip = {
            title: (0, _MHLocalizableString.getString)('rollingBrushWarnTitle2'),
            message: (0, _MHLocalizableString.getString)('rollingBrushWarnMsg2'),
            type: type
          };
        } else {}
      }

      if (tip) {
        tip.level = value;
        tip.state = state;

        if (!_this6.materials) {
          _this6.materials = [];
        }

        var newData = [];

        for (var i = 0; i < _this6.materials.length; i++) {
          var item = _this6.materials[i];

          if (item && item.type != type) {
            newData.push(item);
          }
        }

        if (value == 0) {
          newData.unshift(tip);
        } else {
          newData.push(tip);
        }

        _this6.materials = newData;
      } else {}
    };

    this.refreshMode = function () {
      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 18,
        "piid": 6
      }, {
        "did": did,
        "siid": 18,
        "piid": 20
      }]).then(function (res) {
        console.log("refresMode", res);

        if (res.code == 0) {
          _this6.showData(res.result);
        } else {
          return Promise.reject({
            err: "response1 err"
          });
        }
      }).catch(function (err) {
        console.log("init data:", err);
      });
    };

    this.refreshActionData = function () {
      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 2,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 1
      }, {
        "did": did,
        "siid": 18,
        "piid": 6
      }, {
        "did": did,
        "siid": 18,
        "piid": 9
      }, {
        "did": did,
        "siid": 18,
        "piid": 18
      }, {
        "did": did,
        "siid": 22,
        "piid": 1
      }]).then(function (res) {
        console.log("refreshActionData", res);

        if (res.code == 0) {
          _this6.showData(res.result);
        } else {
          return Promise.reject({
            err: "response1 err"
          });
        }
      }).catch(function (err) {
        console.log("init data:", err);
      });
    };

    this.refreshPollingData = function () {
      _this6.addReportLog("refresh Data");

      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 2,
        "piid": 1
      }, {
        "did": did,
        "siid": 2,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 1
      }, {
        "did": did,
        "siid": 18,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 3
      }, {
        "did": did,
        "siid": 18,
        "piid": 6
      }, {
        "did": did,
        "siid": 18,
        "piid": 9
      }, {
        "did": did,
        "siid": 18,
        "piid": 18
      }, {
        "did": did,
        "siid": 22,
        "piid": 1
      }]).then(function (res) {
        console.log("init1", res);

        _this6.addReportLog("refresh Data receive success");

        if (res.code == 0) {
          _this6.showData(res.result);
        } else {
          return Promise.reject({
            err: "response1 err"
          });
        }
      }).catch(function (err) {
        _this6.addReportLog("refresh Data receive failed");

        console.log("init data:", err);
      });
    };

    this.refreshData = function () {
      _this6.addReportLog("refresh Data");

      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 2,
        "piid": 1
      }, {
        "did": did,
        "siid": 2,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 1
      }, {
        "did": did,
        "siid": 18,
        "piid": 2
      }, {
        "did": did,
        "siid": 18,
        "piid": 3
      }, {
        "did": did,
        "siid": 18,
        "piid": 6
      }, {
        "did": did,
        "siid": 18,
        "piid": 9
      }, {
        "did": did,
        "siid": 18,
        "piid": 16
      }, {
        "did": did,
        "siid": 18,
        "piid": 18
      }, {
        "did": did,
        "siid": 22,
        "piid": 1
      }]).then(function (res) {
        console.log("init1", res);

        _this6.addReportLog("refresh Data receive success");

        if (res.code == 0) {
          _this6.showData(res.result);
        } else {
          return Promise.reject({
            err: "response1 err"
          });
        }
      }).catch(function (err) {
        _this6.addReportLog("refresh Data receive failed");

        console.log("init data:", err);
      });
    };

    this.requestLastCleanInfo = function () {
      _this6.addReportLog("requestLastCleanInfo");

      _miot.Service.smarthome.getDeviceData({
        did: did,
        uid: _miot.Service.account.ID,
        key: "18.1",
        type: "event",
        time_start: _this6.logStartTime,
        time_end: Math.floor(Date.now() / 1000),
        limit: 1
      }).then(function (data) {
        if (data.length > 0) {
          _this6.addReportLog("receiveLastCleanInfo");

          var log = JSON.parse(data[0].value);
          var lastLog = {};

          for (var i = 0; i < log.length; i++) {
            var pvalue = log[i];

            if (pvalue.piid == 2) {
              lastLog.time = pvalue.value;
            } else if (pvalue.piid == 3) {
              lastLog.cleanArea = pvalue.value;
            } else if (pvalue.piid == 11) {
              lastLog.fileName = pvalue.value;
            }
          }

          if (_this6.lastLog) {
            if (_this6.lastLog.fileName == lastLog.fileName) {
              return;
            }
          }

          _this6.lastLog = lastLog;

          if (_this6.lastLog.fileName) {
            _this6.loadMapFile(_this6.lastLog.fileName);
          }
        }
      }).catch(function (err) {});
    };

    this.loadMapFile = function (objname) {
      _this6.addReportLog("requestloadMapFile");

      objname = objname.replace(/\//g, "/");

      _miot.Service.smarthome.getFileUrl({
        obj_name: objname
      }).then(function (res) {
        _this6.addReportLog("requestloadMapFileData");

        console.log("---res.url---", res.url);
        return fetch(res.url);
      }).then(function (res) {
        return res.text();
      }).then(function (mapDataStr) {
        _this6.addReportLog("receiveloadMapFileData");

        if (_this6.lastLog) {
          _this6.lastLog.mapStr = mapDataStr;
        }

        if (!Const.status.hasTask() && !Const.status.isCleaning()) {
          _this6.isShowLog = true;

          _this6.setState({
            cleanArea: '' + _this6.lastLog.cleanArea,
            cleanTime: '' + _this6.lastLog.time
          });

          _this6.mapDataUtil.setMapData(mapDataStr, true);
        }
      }).catch(function (err) {
        console.log("---errload--", err);

        _this6.setState({
          loadingVisible: false
        });
      });
    };

    this.goUpdate = function () {
      _this6.props.navigation.navigate("ota");
    };

    this.checkUpgrading = function () {
      _miot.Service.smarthome.checkDeviceVersion(did).then(function (res) {
        gData.curVersion = res.curVersion;

        if (gData.curVersion && gData.curVersion.indexOf("_") >= 0) {
          var vers = gData.curVersion.split("_");
          var ver = vers[1];
        }

        gData.hasNewFirmware = res.hasNewFirmware;

        if (_this6.hasNewFirmware != res.hasNewFirmware) {
          _this6.hasNewFirmware = res.hasNewFirmware;

          _this6.props.navigation.setParams({
            hasNewFirmware: _this6.hasNewFirmware
          });

          var key = did + "updateTip";
          var newVersion = res.newVersion;

          _miot.Host.storage.get(key).then(function (res) {
            var needDialog = true;

            if (res) {
              res = JSON.parse(res);

              if (res[newVersion] == true) {
                needDialog = false;
              }
            }

            if (needDialog) {
              var value = {};
              value[newVersion] = true;

              _miot.Host.storage.set(key, JSON.stringify(value), {
                expire: 259200000
              });

              _this6.setState({
                dialogVisible: true,
                dialogTitle: (0, _MHLocalizableString.getString)('prompt'),
                dialogMessage: (0, _MHLocalizableString.getString)('updateDialogTip', {
                  version: newVersion
                }),
                dialogConfium: _this6.goUpdate
              });
            }
          }).catch(function (err) {
            var value = {};
            value[newVersion] = true;

            _miot.Host.storage.set(key, JSON.stringify(value), {
              expire: 259200000
            });

            _this6.setState({
              dialogVisible: true,
              dialogTitle: (0, _MHLocalizableString.getString)('prompt'),
              dialogMessage: (0, _MHLocalizableString.getString)('updateDialogTip', {
                version: newVersion
              }),
              dialogConfium: _this6.goUpdate
            });
          });
        }
      }).catch(function (err) {
        return console.log('failed:', err);
      });
    };

    this.calculateNextStartTime = function (task) {
      var taskStrs = task.split(",");
      var nextStart = -1;

      for (var i = 0; i < taskStrs.length; i++) {
        var item = taskStrs[i];

        if (item.indexOf("-") > 0) {
          var datas = item.split("-");

          if (datas.length === 8) {
            var taskItem = {
              id: datas[0],
              enable: datas[1] == "1",
              ts: datas[2],
              time: datas[3],
              week: datas[4],
              loop: datas[5],
              mode: datas[6],
              area: datas[7]
            };

            var times = _this6.calculateStartTime(taskItem);

            if (times > 0) {
              if (nextStart < 0) {
                nextStart = times;
              } else {
                if (times < nextStart) {
                  nextStart = times;
                }
              }
            }
          }
        }
      }

      return nextStart - 1;
    };

    this.calculateStartTime = function (taskItem) {
      var tDate = new Date();
      var tDay = tDate.getDay();
      var tHour = tDate.getHours();
      var tMinute = tDate.getMinutes();

      if (!taskItem.enable) {
        return -1;
      }

      var time = taskItem.time.split(":");

      if (time.length != 2) {
        return -1;
      }

      var nHour = parseInt(time[0]);
      var nMin = parseInt(time[1]);
      var obsolete = tHour * 60 + tMinute > nHour * 60 + nMin;
      var _day = 0;

      if (taskItem.loop == "0" || taskItem.week.indexOf("1") < 0) {
        if (obsolete) {
          _day++;
        }
      } else {
        for (var i = tDay; i < tDay + 7; i++) {
          var index = i % 7;
          var c = taskItem.week.charAt(index);

          if (c == "1") {
            if (i === tDay && obsolete) {
              continue;
            }

            _day = i - tDay;
            break;
          }
        }
      }

      var nDate = new Date();
      nDate.setDate(nDate.getDate() + _day);
      nDate.setHours(nHour);
      nDate.setMinutes(nMin);
      return Math.ceil((nDate.getTime() - tDate.getTime()) / 60000);
    };

    this.isClean = function () {
      if (_this6.state.workMode == 2 || _this6.state.workMode == 4 || _this6.state.workMode == 5 || _this6.state.workMode == 13) {
        return true;
      }

      return false;
    };

    this.isCharging = function () {
      return Const.status.isGoCharing();
    };

    this.startCharge = function (checkClean) {
      if (_this6.isCharging()) {
        _miot.Device.getDeviceWifi().callMethod("action", {
          "did": did,
          "siid": 18,
          "aiid": 2,
          "in": []
        }).then(function (res) {
          _this6.refreshActionData();
        }).catch(function (err) {
          _this6.refreshActionData();
        });

        return;
      }

      if (checkClean == true && _this6.isCLean()) {
        return _this6.setState({
          dialogVisible: true,
          dialogTitle: (0, _MHLocalizableString.getString)('prompt'),
          dialogMessage: (0, _MHLocalizableString.getString)('cleanTip'),
          dialogConfium: _this6.startCharge
        });
      }

      _miot.Device.getDeviceWifi().callMethod("action", {
        "did": did,
        "siid": 2,
        "aiid": 1,
        "in": []
      }).then(function (res) {
        _this6.refreshActionData();

        console.log("-----------", res);
      }).catch(function (err) {
        _this6.refreshActionData();

        console.log('startCharge failed:', err);
      });
    };

    this.startClean = function () {
      if (_this6.isCLean()) {
        _miot.Device.getDeviceWifi().callMethod("action", {
          "did": did,
          "siid": 18,
          "aiid": 2,
          "in": []
        }).then(function (res) {
          _this6.refreshActionData();

          console.log("-----------", res);
        }).catch(function (err) {
          _this6.refreshActionData();

          console.log('startClean failed:', err);
        });

        return;
      }

      _miot.Device.getDeviceWifi().callMethod("action", {
        "did": did,
        "siid": 18,
        "aiid": 1,
        "in": [{
          "piid": 1,
          "value": 2
        }]
      }).then(function (res) {
        _this6.refreshActionData();

        console.log("-----------", res);
      }).catch(function (err) {
        _this6.refreshActionData();

        console.log('startClean failed:', err);
      });
    };

    this.changeMopMode = function (mopMode) {
      _this6.selectMopMode = mopMode;

      _miot.Device.getDeviceWifi().callMethod("set_properties", [{
        "did": did,
        "siid": 18,
        "piid": 20,
        "value": mopMode + 1
      }]).then(function (res) {
        console.log("-----------", res);

        _this6.refreshMode();
      }).catch(function (err) {
        _this6.refreshMode();

        console.log('changeMode failed:', err);
      });
    };

    this.changeMode = function (mode) {
      _this6.selectMode = mode;

      _miot.Device.getDeviceWifi().callMethod("set_properties", [{
        "did": did,
        "siid": 18,
        "piid": 6,
        "value": mode
      }]).then(function (res) {
        console.log("-----------", res);

        _this6.refreshMode();
      }).catch(function (err) {
        _this6.refreshMode();

        console.log('changeMode failed:', err);
      });
    };

    this.navigationRightPress = function () {};

    this.goTimingTasks = function () {
      _this6.props.navigation.navigate("timingTask");
    };

    this.goVoiceManage = function () {
      _this6.props.navigation.navigate("voiceManage");
    };

    this.goAreaEdit = function () {
      if (_this6.mapDataUtil.hasArea()) {
        _this6.props.navigation.navigate("areaEdit");
      } else {
        {
          _this6.setState({
            dialogVisible: true
          });
        }
      }
    };

    this.goWarnInfo = function () {
      if (_this6.state.warnCode == "20") {
        return;
      }

      _this6.props.navigation.navigate("warnInfo", {
        warnCode: _this6.state.warnCode
      });
    };

    this.deleteWarn = function () {
      _this6.setState({
        warnCode: 0
      });
    };

    this.setSpot = function () {
      if (_this6.CleanMap && _this6.mapDataUtil.hasArea()) {
        if (_this6.state.mapType == Const.MAP_EDIT_TYPE_NULL) {
          var type = Const.MAP_EDIT_TYPE_SPOT;

          _this6.CleanMap.setType(type);

          _this6.setState({
            mapType: type
          });
        } else if (_this6.state.mapType == Const.MAP_EDIT_TYPE_SPOT) {
          var _type = Const.MAP_EDIT_TYPE_NULL;

          _this6.CleanMap.setType(_type);

          _this6.setState({
            mapType: _type
          });
        }
      }
    };

    this.setArea = function () {
      if (_this6.CleanMap && _this6.mapDataUtil.hasArea()) {
        if (_this6.state.mapType == Const.MAP_EDIT_TYPE_NULL) {
          var type = Const.MAP_EDIT_TYPE_AREA;

          _this6.CleanMap.setType(type);

          _this6.setState({
            mapType: type
          });
        } else if (_this6.state.mapType == Const.MAP_EDIT_TYPE_AREA) {
          var _type2 = Const.MAP_EDIT_TYPE_NULL;

          _this6.CleanMap.setType(_type2);

          _this6.setState({
            mapType: _type2
          });
        }
      }
    };

    this.isCLean = function () {
      return Const.status.isCleaning();
    };

    this.getChargeText = function () {
      return Const.status.getChargingButtonText();
    };

    this.getSpotButton = function () {
      if (!_this6.mapDataUtil.hasArea() || _this6.isCLean() || _this6.state.mapType == Const.MAP_EDIT_TYPE_AREA) {
        return _require(_dependencyMap[25]);
      }

      if (_this6.state.mapType == Const.MAP_EDIT_TYPE_SPOT) {
        return _require(_dependencyMap[26]);
      }

      return _require(_dependencyMap[27]);
    };

    this.getAreaButton = function () {
      if (!_this6.mapDataUtil.hasArea() || _this6.isCLean() || _this6.state.mapType == Const.MAP_EDIT_TYPE_SPOT) {
        return _require(_dependencyMap[28]);
      }

      if (_this6.state.mapType == Const.MAP_EDIT_TYPE_AREA) {
        return _require(_dependencyMap[29]);
      }

      return _require(_dependencyMap[30]);
    };

    this.dismissTip = function () {
      _this6.setState({
        dialogVisible: false
      });
    };

    this.deleteMaterial = function () {
      var showMaterialCard = _this6.materials.length > 0;

      if (showMaterialCard) {
        var showItem = _this6.materials.shift();

        _this6.forceUpdate();

        _miot.Host.storage.set(did + "material" + showItem.type, true);
      }
    };

    this.renderMaterialCard = function () {
      var showMaterialCard = _this6.materials.length > 0;
      var showItem = undefined;

      if (showMaterialCard) {
        showItem = _this6.materials[0];
      }

      return showMaterialCard ? _react2.default.createElement(
        _reactNativeShadow.BoxShadow,
        {
          setting: {
            width: width - 20,
            height: _this6.state.cardHeight,
            color: "#000",
            border: 5,
            radius: 11,
            opacity: 0.03,
            x: 0,
            y: 3,
            style: {
              marginVertical: 0,
              marginBottom: 10
            }
          }
        },
        _react2.default.createElement(_ListItemView2.default, {
          style: {
            borderTopLeftRadius: 11,
            borderTopRightRadius: 11,
            borderBottomRightRadius: 11,
            borderBottomLeftRadius: 11,
            height: _this6.state.cardHeight
          },
          title: showItem.title,
          tips: showItem.message,
          onDelete: showItem.level > 0 ? _this6.deleteMaterial : undefined,
          onPress: function onPress() {
            var names = {
              "1": (0, _MHLocalizableString.getString)('heap'),
              "2": (0, _MHLocalizableString.getString)('slidBrush'),
              "3": (0, _MHLocalizableString.getString)('rollingBrush')
            };

            _this6.props.navigation.navigate("materialInfo", {
              piid: showItem.type,
              name: names[showItem.type],
              value: showItem.state
            });
          },
          nomalImage: _require(_dependencyMap[17])
        })
      ) : null;
    };

    this.onRobotInfoDescHeight = function (h) {
      if (h > _this6.state.descHeight) {
        _this6.setState({
          descHeight: h
        });
      }
    };

    this.onCardHeightChange = function (h) {
      console.log("onCardHeightChange", h, _this6.state.cardHeight);

      _this6.setState({
        keepSweeperHeight: h
      });
    };
  };

  exports.default = HomePage;
},10118,[10297,10074,10033,10121,10157,10004,10163,10172,11251,10175,10202,10205,10208,10250,10280,10289,13699,10295,10298,10301,10304,10307,10310,10313,10316,10319,10322,10325,10328,10331,10334],"projects/com.dreame.devices/main/HomePage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _ui = _require(_dependencyMap[2]);

  var _reactNavigation = _require(_dependencyMap[3]);

  var _reactNativeUiKitten = _require(_dependencyMap[4]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var lineHeight = 1 / _reactNative.PixelRatio.get();

  var titleHeight = 73;
  var imgHeight = 45;

  var TitleBarBlack = function (_Component) {
    babelHelpers.inherits(TitleBarBlack, _Component);

    function TitleBarBlack(props) {
      babelHelpers.classCallCheck(this, TitleBarBlack);
      return babelHelpers.possibleConstructorReturn(this, (TitleBarBlack.__proto__ || Object.getPrototypeOf(TitleBarBlack)).call(this, props));
    }

    babelHelpers.createClass(TitleBarBlack, [{
      key: "render",
      value: function render() {
        _reactNative.StatusBar.setBarStyle('dark-content');

        {
          _reactNative.StatusBar.setTranslucent(true);
        }
        styles.titleBarContainer.height = _reactNative.StatusBar.currentHeight + titleHeight;
        styles.line.top = _reactNative.StatusBar.currentHeight + titleHeight - lineHeight;
        var leftWidth = this.props.leftTextStyle ? this.props.leftTextStyle.width : 0;
        var rightWidth = this.props.rightTextStyle ? this.props.rightTextStyle.width : 0;
        return _react2.default.createElement(
          _reactNavigation.SafeAreaView,
          {
            style: [styles.titleBarContainer, this.props.style]
          },
          this.props.onPressLeft2 ? _react2.default.createElement(_ui.ImageButton, {
            onPress: this.props.onPressLeft2,
            style: [styles.img, {
              height: this.props.onPressLeft2 ? imgHeight : 0,
              width: this.props.onPressLeft2 ? imgHeight : 0
            }],
            source: _require(_dependencyMap[5]),
            highlightedSource: _require(_dependencyMap[6])
          }) : _react2.default.createElement(_ui.ImageButton, {
            onPress: this.props.onPressLeft,
            style: [styles.img, {
              height: this.props.onPressLeft ? imgHeight : 0
            }],
            source: _require(_dependencyMap[7]),
            highlightedSource: _require(_dependencyMap[8])
          }),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: [styles.textContainer]
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [styles.titleText],
                onPress: this.props.onPressTitle
              },
              this.props.title
            ),
            this.props.subTitle && _react2.default.createElement(
              _reactNative.Text,
              {
                style: [styles.subtitleText],
                onPress: this.props.onPressTitle
              },
              this.props.subTitle
            )
          ),
          _react2.default.createElement(_ui.ImageButton, {
            onPress: this.props.onPressRight2,
            style: [styles.img, {
              marginRight: this.props.onPressRight ? 0 : 7,
              height: this.props.onPressRight2 ? imgHeight : 0,
              width: this.props.onPressRight2 ? imgHeight : 0
            }],
            onPress: this.props.onPressRight2,
            source: _require(_dependencyMap[9]),
            highlightedSource: _require(_dependencyMap[10])
          }),
          this.props.onPressRight3 ? _react2.default.createElement(_ui.ImageButton, {
            onPress: this.props.onPressRight3,
            style: [styles.img, {
              height: this.props.onPressRight3 ? imgHeight : 0
            }],
            source: _require(_dependencyMap[11]),
            highlightedSource: _require(_dependencyMap[12])
          }) : _react2.default.createElement(_ui.ImageButton, {
            onPress: this.props.onPressRight,
            style: [styles.img, {
              height: this.props.onPressRight ? imgHeight : 0,
              width: this.props.onPressRight2 ? 0 : imgHeight
            }],
            source: _require(_dependencyMap[13]),
            highlightedSource: _require(_dependencyMap[14])
          }),
          this.props.showDot && _react2.default.createElement(_reactNative.Image, {
            style: styles.dot,
            source: _require(_dependencyMap[15])
          }),
          this.props.showLine && _react2.default.createElement(_reactNative.View, {
            style: styles.line
          })
        );
      }
    }]);
    return TitleBarBlack;
  }(_react.Component);

  exports.default = TitleBarBlack;

  var styles = _reactNative.StyleSheet.create({
    titleBarContainer: {
      flexDirection: 'row',
      width: width,
      alignItems: 'flex-end',
      height: _reactNative.StatusBar.currentHeight + titleHeight
    },
    textContainer: {
      height: titleHeight,
      flex: 1,
      alignItems: 'stretch',
      justifyContent: 'center'
    },
    titleText: {
      color: 'rgba(0,0,0,0.9)',
      fontSize: 17,
      fontWeight: "500",
      fontFamily: " ",
      textAlignVertical: 'center',
      textAlign: 'center'
    },
    subtitleText: {
      color: 'rgba(0,0,0,0.5)',
      fontSize: 13,
      marginTop: 0,
      fontWeight: "200",
      fontFamily: " ",
      textAlignVertical: 'center',
      textAlign: 'center'
    },
    leftRightText: {
      flexDirection: 'column',
      backgroundColor: '#0000',
      color: '#00000088',
      fontSize: 14,
      alignItems: 'center',
      justifyContent: 'center',
      textAlignVertical: "center",
      textAlign: "center"
    },
    img: {
      width: imgHeight,
      height: imgHeight,
      resizeMode: 'contain',
      marginLeft: 7,
      marginTop: (titleHeight - imgHeight) / 2,
      marginBottom: (titleHeight - imgHeight) / 2,
      marginRight: 7
    },
    dot: {
      position: 'absolute',
      width: 10,
      height: 10,
      resizeMode: 'contain',
      right: 14,
      bottom: (titleHeight + 30) / 2
    },
    line: {
      position: 'absolute',
      width: width,
      height: lineHeight,
      backgroundColor: 'rgba(0,0,0,0.1)',
      top: _reactNative.StatusBar.currentHeight + titleHeight - lineHeight
    }
  });
},10121,[10297,10033,10230,10918,11251,10124,10127,10130,10133,10136,10139,10142,10145,10148,10151,10154],"projects/com.dreame.devices/main/widget/TitleBarBlack.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "466e7d8194d71b39d2212f8e9582d950",
      "name": "std_tittlebar_main_device_back2_normal",
      "type": "png"
   });
},10124,[10420],"projects/com.dreame.devices/resources/title/std_tittlebar_main_device_back2_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "00b2d4e43c61cacacffcbf3c8e6d2a01",
      "name": "std_tittlebar_main_device_back2_press",
      "type": "png"
   });
},10127,[10420],"projects/com.dreame.devices/resources/title/std_tittlebar_main_device_back2_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "a947e1dc2cebd4caa35176a08689dc16",
      "name": "titlebar_black_back_normal",
      "type": "png"
   });
},10130,[10420],"projects/com.dreame.devices/resources/title/titlebar_black_back_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "2edce457298e214dc6cc90843a167afa",
      "name": "titlebar_black_back_press",
      "type": "png"
   });
},10133,[10420],"projects/com.dreame.devices/resources/title/titlebar_black_back_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "34eb9cb1c15e554ee4be192206605d1a",
      "name": "std_tittlebar_main_device_share_normal",
      "type": "png"
   });
},10136,[10420],"projects/com.dreame.devices/resources/title/std_tittlebar_main_device_share_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "94161dc5b8be5b4afd474ab91f75bab7",
      "name": "std_tittlebar_main_device_share_press",
      "type": "png"
   });
},10139,[10420],"projects/com.dreame.devices/resources/title/std_tittlebar_main_device_share_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "03f2633f1fe1ad43f2ac643531ef1263",
      "name": "titlebar_black_confium_normal",
      "type": "png"
   });
},10142,[10420],"projects/com.dreame.devices/resources/title/titlebar_black_confium_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "652cfa9de35fe4622d6e887c62b61cfd",
      "name": "titlebar_black_confium_press",
      "type": "png"
   });
},10145,[10420],"projects/com.dreame.devices/resources/title/titlebar_black_confium_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "d26a15089ddb0103071fb5fc8fe6f03f",
      "name": "titlebar_black_more_normal",
      "type": "png"
   });
},10148,[10420],"projects/com.dreame.devices/resources/title/titlebar_black_more_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
      "width": 130,
      "height": 130,
      "scales": [1],
      "hash": "175b891912dba08a3711f9ce770deebb",
      "name": "titlebar_black_more_press",
      "type": "png"
   });
},10151,[10420],"projects/com.dreame.devices/resources/title/titlebar_black_more_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/title",
    "width": 30,
    "height": 30,
    "scales": [1],
    "hash": "d13f3ee1e886c69b794e4adde2487c8d",
    "name": "std_tittlebar_main_device_massage_point",
    "type": "png"
  });
},10154,[10420],"projects/com.dreame.devices/resources/title/std_tittlebar_main_device_massage_point.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.localStrings = exports.strings = undefined;
    exports.getString = getString;

    var _LocalizedStrings = _require(_dependencyMap[0]);

    var _LocalizedStrings2 = babelHelpers.interopRequireDefault(_LocalizedStrings);

    var _intlMessageformat = _require(_dependencyMap[1]);

    var _intlMessageformat2 = babelHelpers.interopRequireDefault(_intlMessageformat);

    _require(_dependencyMap[2]);

    _require(_dependencyMap[3]);

    _require(_dependencyMap[4]);

    _require(_dependencyMap[5]);

    _require(_dependencyMap[6]);

    var strings = exports.strings = {
        'en': {
            cleaning: 'Cleaning',
            mop: "Mopping",
            customClean: "Zoned cleanup",
            cleaned: "Cleaned",
            cleantime: "Cleaning time",
            surplusPower: "Battery",
            charge: "Dock",
            chargePause: "Pause",
            cleanPause: "Pause",
            cleanStart: "Start\ncleanup",
            areaClean: "Area cleanup",
            remoteClean: "Remote control cleanup",
            localClean: "Partial cleanup",
            chargingBtnText: 'Charging',
            charging: 'Charging',
            completedCharge: 'Charging completed',
            completedChargeBtnText: 'Charging\ncompleted',
            cleanMode: "Cleanup mode",
            modeQuiet: "Silent",
            modeStandard: "Standard",
            modeMedium: "Medium",
            modeStrong: "Turbo",
            cleanTiming: "Scheduled cleanup",
            cleanTimingStart: 'Starts in {hour, plural,=0 { }other {#h and}} {minute} min',
            cleanTimingEmpty: "No scheduled cleanup tasks",
            areaEdit: "Area editor",
            robotVoice: "Voice alerts",
            prompt: "Notifications",
            waiting: 'Standby',
            gocharging: 'Returning to the dock to charge…',
            areaSlect: "Areas selected: {areaNum}",
            areaMerge: "Merge",
            areaSplit: "Divide",
            areaRename: "Rename",
            spot: 'Clean there',
            removeWaterBoxTitle: "Remove the mop's board",
            removeWaterBoxMessage: "To start charging, please remove the mop's board",
            keepSweeperTitle: "Resume cleanup",
            keepSweeperMessage: "The vacuum-mop will automatically resume unfinished cleaning tasks after charging its battery to 80%.",
            setting: 'Settings',
            robotSetting: 'Device Settings',
            msgSwitch: 'Notifications',
            cleanLog: 'Cleaning history',
            materialTime: 'Service schedule',
            remoteControl: 'Remote control',
            productGuide: 'Help',
            functionSetting: 'More settings',
            generalSetting: 'General settings',
            securitySetting: "Security settings",
            moreSetting: "Additional settings",
            locationRobot: 'Locate my vacuum-mop',
            deleteDevice: 'Delete device',
            timeZone: "Vacuum-mop's time zone",
            volume: "Volume settings",
            disturbTime: "DND mode",
            noTiming: 'No schedules',
            repeat: 'Repeat',
            once: 'Once',
            everyDay: 'Daily',
            workDay: 'Working days (Mon - Fri)',
            weekend: 'Weekends',
            custom: 'Custom',
            Sunday: "Sun",
            Monday: "Mon",
            Tuesday: "Tue",
            Wednesday: "Wed",
            Thursday: "Thu",
            Friday: "Fri",
            Saturday: "Sat",
            startTime: 'Starting time',
            sure: 'OK',
            cancle: 'Cancel',
            heap: 'Filter',
            heapDesc: "The filter is made of polymer fibers to prevent dust from escaping the dust compartment. Over time, it will slowly get blocked and lose its effectiveness. Therefore, it is recommended to replace the filter every {time} operating hours or less.",
            slidBrush: 'Side brush',
            slidBrushDesc: 'The side brush directs dirt and debris from the corners towards the main brush. Over time, it will wear and tear and lose its effectiveness. Therefore, it is recommended to replace the side brush every {time} operating hours or less.',
            rollingBrush: 'Main brush',
            rollingBrushDesc: "The main brush directs dirt and debris into the vacuum-mop's dust compartment. Over time, it will wear and tear and lose its effectiveness. Therefore, it is recommended to replace the main brush every {time} operating hours or less.",
            brushExpireDesc: "Replace in about {time} hours",
            buy: 'Purchase now',
            timezoneTip1: 'You can sync your phone’s time zone with your vacuum-mop, to make sure both are in the same time zone.',
            timezoneTip2: "* When the vacuum-mop's time zone is inaccurate, scheduled cleanups and DND mode may not work as expected.",
            syncTimeZone: 'Sync now',
            volumeTip: 'The voice alert volume of the vacuum-mop can be adjusted by moving the slider up/down. Tap the test volume button to try.',
            listen: 'Listen',
            nodistrubTip: 'While enabled, the vacuum-mop will not automatically resume cleanups during the specified period. However, scheduled cleanups will still be carried out during the DND period.',
            endTime: 'Ending time',
            remain: "Remaining",
            remainDay: "Remaining service life: Approx. {hour} hours",
            materialReset: "Reset {name}",
            resetHeapTitle: "Reset filter's usage time",
            resetHeapMessage: "Has the filter been replaced with a new one?",
            resetRollingBrushTitle: "Reset main brush's usage time",
            resetRollingBrushMessage: "Has the main brush been replaced with a new one?",
            resetSlidBrushTitle: "Reset side brush's usage time",
            resetSlidBrushMessage: "Has the side brush been replaced with a new one?",
            deveiceName: "Device name",
            deviceShare: 'Device sharing',
            locationManager: 'Location management',
            otaCheck: 'Firmware update',
            addDesktop: 'Add Home screen shortcut',
            feedback: 'Feedback',
            useTerms: 'Legal information',
            licenseTitle: "User Agreement",
            policyTitle: "Privacy Policy",
            loading: "Loading data…",
            pause: 'Paused',
            timingStart: "Enable",
            selectArea: "Select area",
            selectAreaDesc: "This scheduled cleanup will be invalid when the map changes.",
            cancle: "Cancel",
            confirm: "OK",
            autoClean: "Full cleanup",
            deleteMsg: "Delete this schedule",
            upgradeErr1: "Could not download firmware",
            upgradeErr5: "Could not update firmware",
            upgradeErr7: "Unable to update while battery level is too low",
            upgradeErr8: "Vacuum-mop cannot be updated while not charging",
            networkTimeout: "Request timed out",
            remoteTips: "The vacuum-mop and the phone are not connected to the same Wi-Fi network. Please connect both to the same network so as to use the remote control functionality.",
            remoteTip2: "Check the firmware and network status",
            areaEditTip1: "It is recommended to adjust the areas according to the home's actual layout.",
            areaEditTip2: "Please select two adjacent areas to merge",
            areaEditTip3: "Please select one area to divide",
            areaEditTip3: "Please select the area you want to rename",
            areaEditTip4: "Please select one area to rename",
            areaNames: ["Basement", "Attic", "Media Room", "Dining Room", "Balcony", "Activity Room", "Living Room", "Bedroom", "Bathroom", "Kitchen"],
            defaultArea: "Default room",
            addArea: "Add",
            areaTipTitle: "Please carry out automatic partitioning before use",
            areaTipMessage: "Automatic partitioning: The vacuum-mop starts from the charging dock. After cleaning and automatically recharging successfully, the map will be automatically saved and partitioned into areas.",
            areaTipButton: "OK",
            use: "Use",
            used: "Current",
            netErr: "Network error",
            voiceDownloadErr: "Could not download voice pack",
            voiceTip: "Downloading voice pack, please try again later",
            warnInfoTitle: "Error details",
            totalTime: "Total time",
            totalArea: "Total area",
            totalTimes: "Total times",
            spotTips: "Clean up the 1.5 m by 1.5 m area around the coordinate point",
            timingNumTip: "Max. scheduled cleanups has been reached, unable to add a scheduled cleanup.",
            resetFail: "Could not reset",
            syncSuccess: "Synchronized successfully",
            cleanTip: "End current cleanup, and return to the dock to charge?",
            emptyLog: "History is empty",
            disturbTip: "Cannot be the same as the starting time, please set again.",
            otatitle: "Check for firmware updates",
            otaChecking: "Checking…",
            currentVersion: "Current version",
            latestVersion: "Latest version",
            isLatestVersion: "Current version is the latest",
            back: "Go back",
            checkVersionFailed: "Could not check for firmware updates",
            retry: "Try again",
            updateNow: "Update now",
            updateTip: "Place the vacuum-mop at the charging dock before updating, and make sure the battery level is more than 15%.",
            upgradeErr: "Could not update",
            updating: "Updating…",
            updateTip2: "Updating, do not turn off or use the vacuum-mop before the update is completed.",
            installing: "Installing update…",
            installtip: "Installation process requires restarting the vacuum-mop. This may take a while, please be patient.",
            updatesuccess: "Updated successfully",
            IntelligentScene: "Smart scenes",
            warnInfo: {
                "1": {
                    title: "Wheels are suspended",
                    desc: "Please reposition the vacuum-mop and start again.",
                    warninfo: "Wheels are suspended, please reposition the vacuum-mop and start again."
                },
                "2": {
                    title: "Obstacle sensor error",
                    desc: "Please wipe the obstacle sensor and start the cleanup away from any obstacles.",
                    warninfo: "The vacuum-mop's wheels are suspended, try moving it to a new location. When the obstacle sensor is too dirty, this kind of error may also occur. Please wipe the obstacle sensor clean and try again."
                },
                "3": {
                    title: "Collision sensor is stuck",
                    desc: "Please clean and gently tap the collision sensor.",
                    warninfo: 'When the bumper is stuck, try tapping it several times to clear any trapped objects. When it is not stuck, try moving the vacuum-mop to a new location and start again.'
                },
                "4": {
                    title: "Vacuum is tilted",
                    desc: "Please move the vacuum-mop to a level surface and start again.",
                    warninfo: 'Please move the vacuum-mop to a level surface and start again.'
                },
                "5": {
                    title: "Collision sensor is stuck",
                    desc: "Please clean and gently tap the collision sensor.",
                    warninfo: 'When the bumper is stuck, try tapping it several times to clear any trapped objects. When it is not stuck, try moving the vacuum-mop to a new location and start again.'
                },
                "6": {
                    title: "Wheels are suspended",
                    desc: "Please reposition the vacuum-mop and start again.",
                    warninfo: "Wheels are suspended, please reposition the vacuum-mop and start again."
                },
                "7": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "8": {
                    title: "Dust compartment has not been installed.",
                    desc: "Please install the dust compartment and filter.",
                    warninfo: 'Please correctly install both the dust compartment and the filter. If the error still occurs, try replacing the filter.'
                },
                "11": {
                    title: "The filter may not be dry or may be blocked.",
                    desc: "Please check whether the filter has dried or needs to be cleaned.",
                    warninfo: "When the filter is not dry, please let it dry for at least 24 hours. When the filter is blocked, please clean it. If the issue cannot be resolved, please replace the filter."
                },
                "12": {
                    title: "Some object may be wrapped around the main brush.",
                    desc: "Please remove the main brush and clean its bristles and bearings.",
                    warninfo: "Some object may be wrapped around the main brush, please remove the main brush to clean the bristles and bearings."
                },
                "13": {
                    title: "Some object may be wrapped around the side brush.",
                    desc: "Please remove and clean the side brush.",
                    warninfo: "Some object may be wrapped around the side brush, please remove the side brush to clean the bristles."
                },
                "14": {
                    title: "The filter may not be dry or may be blocked.",
                    desc: "Please check whether the filter has dried or needs to be cleaned.",
                    warninfo: "When the filter is not dry, please let it dry for at least 24 hours. When the filter is blocked, please clean it. If the issue cannot be resolved, please replace the filter."
                },
                "15": {
                    title: "The vacuum-mop is stuck, or its wheels may be blocked by an object.",
                    desc: "Check whether the wheels are blocked by an object, please rotate the wheels to clean them, and move the vacuum-mop to a new location to start again.",
                    warninfo: "The wheels may be blocked by an object, please rotate the wheels to clean them, and start again."
                },
                "16": {
                    title: "The vacuum-mop is stuck, or its wheels may be blocked by an object.",
                    desc: "Check whether the wheels are blocked by an object, please rotate the wheels to clean them, and move the vacuum-mop to a new location to start again.",
                    warninfo: "The wheels may be blocked by an object, please rotate the wheels to clean them, and start again."
                },
                "17": {
                    title: "The vacuum-mop may be blocked or stuck.",
                    desc: "Please clear surrounding obstacles",
                    warninfo: "The vacuum-mop may be blocked or stuck, please clear surrounding obstacles."
                },
                "18": {
                    title: "The vacuum-mop may be blocked or stuck.",
                    desc: "Please clear surrounding obstacles",
                    warninfo: "The vacuum-mop may be blocked or stuck, please clear surrounding obstacles."
                },
                "20": {
                    title: "Low battery",
                    desc: "Battery level is too low, please charge.",
                    warninfo: ""
                },
                "21": {
                    title: "Charging error",
                    desc: "Charging error, please try cleaning the charging contact area.",
                    warninfo: "Please wipe the charging contacts on both the dock and the vacuum-mop with a dry cloth."
                },
                "23": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "24": {
                    title: "Visual positioning sensor error",
                    desc: "Please clean the visual positioning sensor.",
                    warninfo: "Please wipe the visual positioning sensor clean and restart."
                },
                "25": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "29": {
                    title: "Battery error",
                    desc: "Battery error",
                    warninfo: "The battery temperature is too high or too low, please wait until the battery temperature is normal again."
                },
                "30": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "31": {
                    title: "The vacuum-mop is stuck, or its wheels may be blocked by an object.",
                    desc: "Check whether the wheels are blocked by an object, please rotate the wheels to clean them, and move the vacuum-mop to a new location to start again.",
                    warninfo: "The wheels may be blocked by an object, please rotate the wheels to clean them, and start again."
                },
                "32": {
                    title: "The vacuum-mop is stuck, or its wheels may be blocked by an object.",
                    desc: "Check whether the wheels are blocked by an object, please rotate the wheels to clean them, and move the vacuum-mop to a new location to start again.",
                    warninfo: "The wheels may be blocked by an object, please rotate the wheels to clean them, and start again."
                },
                "33": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "34": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "35": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "36": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "37": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "38": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "39": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "40": {
                    title: "Internal error",
                    desc: "Please try resetting the system.",
                    warninfo: "Internal error detected, unable to continue operating, please try resetting the system."
                },
                "41": {
                    title: "Strong magnetic field detected",
                    desc: "Strong magnetic field detected, please stay away from the virtual wall.",
                    warninfo: "Vacuum-mop is too close to the virtual wall at startup, please move it to another location to start."
                }
            },
            "slidBrushWarnTipTitle1": "Side brush needs to be replaced soon",
            "slidBrushWarnTipMsg1": "The side brush is nearly worn out, please replace it as soon as possible.",
            "slidBrushWarnTipTitle2": "Side brush needs to be replaced",
            "slidBrushWarnTipMsg2": "The side brush is worn out, please replace it.",
            "rollingBrushWarnTitle1": "Main brush needs to be replaced soon",
            "rollingBrushWarnMsg1": "The main brush is nearly worn out, please replace it as soon as possible.",
            "rollingBrushWarnTitle2": "Main brush needs to be replaced",
            "rollingBrushWarnMsg2": "The main brush is worn out, please replace it.",
            "heapWarnTitle1": "Filter is nearly exhausted",
            "heapWarnMsg1": "The filter is nearly exhausted, please replace it as soon as possible.",
            "heapWarnTitle2": "Filter is exhausted",
            "heapWarnMsg2": "The filter is exhausted, please replace it.",
            "updateDialogTip": "Firmware update ({version}) available. Update now?",
            "logDate": "{month}/{day} {hour}:{minute}",
            "mopModeSet": "Water level setting",
            "mopMode1": "Level 1",
            "mopMode2": "Level 2",
            "mopMode3": "Level 3",
            "areaUnit": "m²",
            "minute": "min"
        },
        'zh': {
            cleaning: '正在清扫',
            mop: "拖地",
            customClean: "划区清扫",
            cleaned: "已清扫",
            cleantime: "清扫时间",
            surplusPower: "电量",
            charge: '回充',
            chargePause: "暂停回充",
            cleanPause: "暂停清扫",
            cleanStart: "开始清扫",
            areaClean: "区域清扫",
            remoteClean: "遥控清扫",
            localClean: "局部清扫",
            chargingBtnText: '正在充电',
            charging: '正在充电',
            completedCharge: '充电完成',
            completedChargeBtnText: '充电完成',
            cleanMode: "清扫模式",
            modeQuiet: "安静",
            modeStandard: "标准",
            modeMedium: "中挡",
            modeStrong: "强力",
            cleanTiming: "定时清扫",
            cleanTimingStart: '{hour, plural,=0 { }other {#小时}}{minute}分钟后开始',
            cleanTimingEmpty: "暂无定时任务",
            areaEdit: "区域编辑",
            robotVoice: "机器人语音",
            prompt: "提示",
            waiting: '待机',
            gocharging: '回充中',
            areaSlect: "已选择{areaNum}个区域",
            areaMerge: "合并",
            areaSplit: "分割",
            areaRename: "重命名",
            spot: '指哪扫哪',
            setting: '设置',
            robotSetting: '设备设置',
            msgSwitch: '消息提醒开关',
            cleanLog: '清扫记录',
            materialTime: '耗材计时',
            remoteControl: '遥控器',
            productGuide: '使用帮助',
            functionSetting: '功能设置',
            generalSetting: '通用设置',
            securitySetting: "安全设置",
            moreSetting: "更多设置",
            locationRobot: '定位我的设备',
            timeZone: '设备所在时区',
            volume: "音量设置",
            disturbTime: "勿扰模式",
            noTiming: '定时为空',
            repeat: '重复',
            once: '执行一次',
            everyDay: '每天',
            workDay: '工作日（周一到周五）',
            weekend: '周末',
            custom: '自定义',
            Sunday: "周日",
            Monday: "周一",
            Tuesday: "周二",
            Wednesday: "周三",
            Thursday: "周四",
            Friday: "周五",
            Saturday: "周六",
            startTime: '开启时间',
            sure: '确认',
            cancle: '取消',
            heap: '滤网',
            heapDesc: "滤网由高分子纤维组成，用于防止吸入尘盒的灰尘逸出。随工作时间的增长，会缓慢堵塞失效。建议工作{time}小时或更短时间更换一次。",
            slidBrush: '边刷',
            slidBrushDesc: '边刷用于清扫墙角垃圾，将垃圾送入主刷。随工作时间的增长会有磨损，影响清扫效果。建议工作{time}小时或更短时间更换一次。',
            rollingBrush: '主刷',
            rollingBrushDesc: '主刷是主要清扫部件，它以高速旋转卷起垃圾进入尘盒。 随工作时间的增长主刷会有磨损。建议工作{time}小时或更短时间更换一次。',
            brushExpireDesc: "预计剩余{time}小时更换",
            buy: '立即购买',
            timezoneTip1: '可以将手机所在时区同步到设备，请确保手机和设备处在同一时区',
            timezoneTip2: '*设备时区不准确，可能造成定时清扫和勿扰模式时间紊乱',
            syncTimeZone: '现在同步',
            volumeTip: '可拖动调节设备语音音量大小，可点击试听按钮试听',
            listen: '试听',
            nodistrubTip: '开启后，设定时间内不会自动续扫。勿扰时间段内会执行已设置的预约工作。',
            endTime: '结束时间',
            remain: "剩余",
            remainDay: "预计还可使用{hour}小时",
            materialReset: "{name}复位",
            resetHeapTitle: "重置滤芯使用时间",
            resetHeapMessage: "已更换新的滤芯？",
            resetRollingBrushTitle: "重置主刷使用时间",
            resetRollingBrushMessage: "已更换新的主刷？",
            resetSlidBrushTitle: "重置边刷使用时间",
            resetSlidBrushMessage: "已更换新的边刷？",
            deveiceName: "设备名称",
            deviceShare: '设备共享',
            locationManager: '位置管理',
            otaCheck: '固件升级',
            deleteDevice: '删除设备',
            addDesktop: '添加桌面快捷方式',
            feedback: '反馈问题',
            useTerms: '法律信息',
            loading: "数据加载中…",
            pause: '暂停',
            timingStart: "开启",
            selectArea: "选择区域",
            selectAreaDesc: "若地图发生变化则该定时无效",
            cancle: "取消",
            confirm: "确认",
            autoClean: "全局清扫",
            deleteMsg: "删除此项定时设置",
            upgradeErr1: "固件下载失败",
            upgradeErr5: "固件更新失败",
            upgradeErr7: "电量过低，无法升级",
            upgradeErr8: "主机未在充电状态，无法升级",
            networkTimeout: "请求超时",
            remoteTips: "设备与手机不在同一局域网内，请连接在同一局域网后使用遥控器",
            remoteTip2: "检查固件和网络状况",
            areaEditTip1: "建议按照真实户型调整区域",
            areaEditTip2: "请选择两个相邻可达区域进行合并",
            areaEditTip3: "请选择1个区域进行分割",
            areaEditTip3: "请选择需要命名的区域",
            areaEditTip4: "请选择单个区域进行重命名",
            areaNames: ["地下室", "阁楼", "媒体房", "餐厅", "阳台", "活动室", "客厅", "卧室", "卫生间", "厨房"],
            defaultArea: "默认房间",
            addArea: "添加",
            areaTipTitle: "请自动分区后使用",
            areaTipMessage: "如何自动分区：设备从充电座出发，清扫完成并自动回充成功后，将自动保存地图并分区",
            areaTipButton: "确定",
            use: "使用",
            used: "使用中",
            netErr: "网络异常",
            voiceDownloadErr: "语音包下载失败",
            voiceTip: "当前有语音包正在下载中，请稍后再试",
            warnInfoTitle: "故障详情",
            totalTime: "累计时长",
            totalArea: "累计面积",
            totalTimes: "累计次数",
            spotTips: "清扫坐标点周边1.5×1.5米的方形区域",
            timingNumTip: "预约任务已到达上限，无法新增任务",
            resetFail: "重置失败",
            syncSuccess: "同步成功",
            cleanTip: "结束当前清扫，开始回充？",
            licenseTitle: "用户协议",
            policyTitle: "隐私政策",
            removeWaterBoxTitle: "取下抹布支架",
            removeWaterBoxMessage: "拖地工作已完成，请及时取下并清洗拖布",
            keepSweeperTitle: "断点续扫",
            keepSweeperMessage: "主机将在充电达到80%以后自动开始未完成的清扫工作",
            emptyLog: "记录为空",
            disturbTip: "设置的起始时间相同，请重新设置",
            otatitle: "检查固件更新",
            otaChecking: "正在检测…",
            currentVersion: "当前版本",
            latestVersion: "最新版本",
            isLatestVersion: "当前已经是最新版本",
            back: "返回",
            checkVersionFailed: "检测可更新固件失败",
            retry: "重试",
            updateNow: "立即更新",
            updateTip: "升级前请将设备置于充电座，并保持电量15%以上",
            upgradeErr: "升级失败",
            updating: "正在升级...",
            updateTip2: "升级中，请勿断电，等待升级完成后再使用",
            installing: "安装更新中...",
            installtip: "安装过程需要重启设备，可能耗时较长，请耐心等待",
            updatesuccess: "更新成功",
            IntelligentScene: "智能场景",
            warnInfo: {
                "1": {
                    title: "轮子悬空",
                    desc: "请将主机移动到新位置启动",
                    warninfo: "轮子悬空，请移到新位置启动。"
                },
                "2": {
                    title: "悬崖传感器异常",
                    desc: "请擦拭悬崖传感器并远离悬崖后启动",
                    warninfo: "主机悬空，请移到新位置启动；悬崖传感器太脏也可能导致该故障，请擦拭悬崖传感器排除。"
                },
                "3": {
                    title: "碰撞传感器被卡住",
                    desc: "请清理并轻拍碰撞传感器",
                    warninfo: '碰撞缓冲器被卡住，请清除异物；如无异物请移到新位置启动。'
                },
                "4": {
                    title: "主机倾斜",
                    desc: "请将主机放置到水平地面启动",
                    warninfo: '请将主机放置到水平地面启动。'
                },
                "5": {
                    title: "碰撞传感器被卡住",
                    desc: "请清理并轻拍碰撞传感器",
                    warninfo: '碰撞缓冲器被卡住，请清除异物；如无异物请移到新位置启动。'
                },
                "6": {
                    title: "轮子悬空",
                    desc: "请将主机移动到新位置启动",
                    warninfo: "轮子悬空，请移到新位置启动。"
                },
                "7": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "8": {
                    title: "尘盒未装回",
                    desc: "请装回尘盒及滤网",
                    warninfo: '请装回尘盒及滤网并确认安装到位；若仍报错，请尝试更换滤网。'
                },
                "11": {
                    title: "滤网可能未晾干或被堵塞",
                    desc: "请确认滤网已晾干或清理滤网",
                    warninfo: "滤网未干透，请晾晒至少24小时；滤网可能被堵塞，请清理滤网；如无法解决请更换滤网。"
                },
                "12": {
                    title: "主刷可能缠绕异物",
                    desc: "请取下主刷，清理刷毛及轴承",
                    warninfo: "主刷可能缠绕异物，请取下主刷及轴承并清理。"
                },
                "13": {
                    title: "边刷可能缠绕异物",
                    desc: "请拆卸并清理边刷",
                    warninfo: "边刷可能缠绕异物，请拆卸边刷并清理。"
                },
                "14": {
                    title: "滤网可能未晾干或被堵塞",
                    desc: "请确认滤网已晾干或清理滤网",
                    warninfo: "滤网未干透，请晾晒至少24小时；滤网可能被堵塞，请清理滤网；如无法解决请更换滤网。"
                },
                "15": {
                    title: "可能被卡住或主轮卷入异物",
                    desc: "请检查主轮是否卡入异物并移到新位置启动",
                    warninfo: "主轮可能缠绕异物，请清理后重新启动。"
                },
                "16": {
                    title: "可能被卡住或主轮卷入异物",
                    desc: "请检查主轮是否卡入异物并移到新位置启动",
                    warninfo: "主轮可能缠绕异物，请清理后重新启动。"
                },
                "17": {
                    title: "可能被卡住或者困住了",
                    desc: "请清除主机周围障碍物",
                    warninfo: "主机可能被卡住或困住，请清除主机周围障碍物。"
                },
                "18": {
                    title: "可能被卡住或者困住了",
                    desc: "请清除主机周围障碍物",
                    warninfo: "主机可能被卡住或困住，请清除主机周围障碍物。"
                },
                "20": {
                    title: "电量过低",
                    desc: "电量过低，请充电",
                    warninfo: ""
                },
                "21": {
                    title: "充电异常",
                    desc: "充电异常，请尝试清理充电接触区域",
                    warninfo: "请用干布擦拭主机充电触片及充电座弹片。"
                },
                "23": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "24": {
                    title: "视觉定位传感器异常",
                    desc: "请清理视觉定位传感器",
                    warninfo: "请擦拭视觉定位传感器后重新启动。"
                },
                "25": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "29": {
                    title: "电池异常",
                    desc: "电池异常",
                    warninfo: "电池温度过高或过低，请等待电池温度正常后再使用。"
                },
                "30": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "31": {
                    title: "可能被卡住或主轮卷入异物",
                    desc: "请检查主轮是否卡入异物并移到新位置启动",
                    warninfo: "主轮可能缠绕异物，请清理后重新启动。"
                },
                "32": {
                    title: "可能被卡住或主轮卷入异物",
                    desc: "请检查主轮是否卡入异物并移到新位置启动",
                    warninfo: "主轮可能缠绕异物，请清理后重新启动。"
                },
                "33": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "34": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "35": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "36": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "37": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "38": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "39": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "40": {
                    title: "内部错误",
                    desc: "请尝试重置系统",
                    warninfo: "检测到内部错误，无法继续工作，请尝试重置系统。"
                },
                "41": {
                    title: "检测到强磁场",
                    desc: "检测到强磁场，请远离虚拟墙启动",
                    warninfo: "启动时主机太靠近虚拟墙，请移动到新位置启动。"
                }
            },
            "slidBrushWarnTipTitle1": "边刷即将到期",
            "slidBrushWarnTipMsg1": "边刷即将到期，请及时更换",
            "slidBrushWarnTipTitle2": "边刷已到期",
            "slidBrushWarnTipMsg2": "边刷已到期，请更换",
            "rollingBrushWarnTitle1": "主刷即将到期",
            "rollingBrushWarnMsg1": "主刷即将到期，请及时更换",
            "rollingBrushWarnTitle2": "主刷已到期",
            "rollingBrushWarnMsg2": "主刷已到期，请更换",
            "heapWarnTitle1": "滤芯即将到期",
            "heapWarnMsg1": "滤芯即将到期，请及时更换",
            "heapWarnTitle2": "滤芯已到期",
            "heapWarnMsg2": "滤芯已到期，请更换",
            "updateDialogTip": "检测到设备有最新固件版本{version},是否升级?",
            "mopModeSet": "水量设置",
            "mopMode1": "1挡",
            "mopMode2": "2挡",
            "mopMode3": "3挡",
            "logDate": "{month}/{day} {hour}:{minute}",
            "areaUnit": "m²",
            "minute": "min"
        },
        'it': {
            "cleaning": "Pulizia",
            "mop": "Pulizia pavimento",
            "customClean": "Pulizia a zone",
            "cleaned": "Pulito",
            "cleantime": "Tempo di pulizia",
            "surplusPower": "Batteria",
            "charge": "Base",
            "chargePause": "Pausa",
            "cleanPause": "Pausa",
            "cleanStart": "Iniziare \nla pulizia",
            "areaClean": "Pulizia dell'area",
            "remoteClean": "Pulizia telecomando",
            "localClean": "Pulizia parziale",
            "chargingBtnText": "Ricarica",
            "charging": "Ricarica",
            "completedCharge": "Ricarica completata",
            "completedChargeBtnText": "Ricarica \ncompletata",
            "cleanMode": "Modalità di pulizia",
            "modeQuiet": "Silenzioso",
            "modeStandard": "Standard",
            "modeMedium": "Medio",
            "modeStrong": "Turbo",
            "cleanTiming": "Pulizia programmata",
            "cleanTimingStart": "Inizia tra {hour, plural,=0 {}other {# h e }}{minute} min",
            "cleanTimingEmpty": "Nessuna attività di pulizia programmata",
            "areaEdit": "Editor di area",
            "robotVoice": "Avvisi vocali",
            "prompt": "Notifiche",
            "waiting": "Standby",
            "gocharging": "Ritorno alla base per ricaricare",
            "areaSlect": "Aree Selezionate: {areaNum}",
            "areaMerge": "Unisci",
            "areaSplit": "Dividi",
            "areaRename": "Rinomina",
            "spot": "Pulisci lì",
            "setting": "Impostazioni",
            "robotSetting": "Impostazioni dispositivo",
            "msgSwitch": "Notifiche",
            "cleanLog": "Cronologia della pulizia",
            "materialTime": "Programma di servizio",
            "remoteControl": "Telecomando",
            "productGuide": "Guida",
            "functionSetting": "Impostazioni aggiuntive",
            "generalSetting": "Impostazioni generali",
            "securitySetting": "Impostazioni di sicurezza",
            "moreSetting": "Impostazioni aggiuntive",
            "locationRobot": "Localizza il mio aspirapolvere/pulisci pavimenti",
            "timeZone": "Zona temporale del mio aspirapolvere/pulisci pavimenti",
            "volume": "Impostazioni del volume",
            "disturbTime": "Modalità DND",
            "noTiming": "Nessun programma",
            "repeat": "Ripeti",
            "once": "Una volta",
            "everyDay": "Quotidiano",
            "workDay": "Giorni lavorativi (lun - ven)",
            "weekend": "Fine settimana",
            "custom": "Personalizza",
            "Sunday": "Dom",
            "Monday": "Lun",
            "Tuesday": "Mar",
            "Wednesday": "Mer",
            "Thursday": "Gio",
            "Friday": "Ven",
            "Saturday": "Sab",
            "startTime": "Ora di inizio",
            "sure": "OK",
            "cancle": "Annulla",
            "heap": "Filtro",
            "heapDesc": "Il filtro è realizzato in fibre polimeriche per impedire alla polvere di fuoriuscire dal vano della polvere. Nel tempo, si bloccherà lentamente e perderà la sua efficacia. Pertanto, si consiglia di sostituire il filtro ogni {time} ore di funzionamento o meno.",
            "slidBrush": "Spazzola laterale",
            "slidBrushDesc": "La spazzola laterale dirige sporco e detriti dagli angoli verso la spazzola principale. Nel tempo, si usurerà e perderà la sua efficacia. Pertanto, si consiglia di sostituire la spazzola laterale ogni {time} ore di funzionamento o meno.",
            "rollingBrush": "Spazzola Principale",
            "rollingBrushDesc": "La spazzola principale dirige sporco e detriti nel vano polvere dell'aspirapolvere/pulisci pavimenti. Nel tempo, si usurerà e perderà la sua efficacia. Pertanto, si consiglia di sostituire la spazzola principale ogni {time} ore di funzionamento o meno.",
            "brushExpireDesc": "Sostituisci tra circa {time} ore",
            "buy": "Acquista adesso",
            "timezoneTip1": "Puoi sincronizzare la zona temporale del tuo telefono con il tuo aspirapolvere/pulisci pavimenti, per assicurarti che entrambi si trovino nella stessa zona temporale.",
            "timezoneTip2": "* Quando la zona temporale dell'aspirapolvere/pulisci pavimenti non è precisa, le pulizie programmate e la modalità DND potrebbero non funzionare come previsto.",
            "syncTimeZone": "Sincronizza ora",
            "volumeTip": "Il volume degli allarmi vocali dell'aspirapolvere/pulisci pavimenti può essere regolato spostando il cursore su giù. Tocca il pulsante del volume di prova per testare.",
            "listen": "Ascolta",
            "nodistrubTip": "Se abilitato, l'aspirapolvere/pulisci pavimenti non riprenderà automaticamente le pulizie durante il periodo specificato. Tuttavia, le pulizie programmate verranno comunque eseguite durante il periodo di DND.",
            "endTime": "Ora di fine",
            "remain": "Rimanente",
            "remainDay": "Durata residua: ca. {hour} ore",
            "materialReset": "Reimposta {name}",
            "resetHeapTitle": "Reimp. tempo uso filtro",
            "resetHeapMessage": "Il filtro è stato sostituito con uno nuovo?",
            "resetRollingBrushTitle": "Ripristina tempo uso spazzola princ",
            "resetRollingBrushMessage": "La spazzola principale è stata sostituita con una nuova?",
            "resetSlidBrushTitle": "Ripristina tempo uso spazzola lat",
            "resetSlidBrushMessage": "La spazzola laterale è stata sostituita con una nuova?",
            "deveiceName": "Nome dispositivo",
            "deviceShare": "Condivisione dispositivo",
            "locationManager": "Gestione delle sedi",
            "otaCheck": "Aggiornamento firmware",
            "deleteDevice": "Elimina dispositivo",
            "addDesktop": "Aggiungi collegamento schermata iniziale",
            "feedback": "Feedback",
            "useTerms": "Informazioni legali",
            "loading": "Caricamento dati...",
            "pause": "Pausa",
            "timingStart": "Abilita",
            "selectArea": "Seleziona area",
            "selectAreaDesc": "Questa pulizia programmata non sarà valida quando la mappa cambia.",
            "confirm": "OK",
            "autoClean": "Pulizia completa",
            "deleteMsg": "Eliminare la pianificazione",
            "upgradeErr1": "Impossibile scaricare il firmware",
            "upgradeErr5": "Impossibile aggiornare il firmware",
            "upgradeErr7": "Impossibile aggiornare mentre il livello della batteria è troppo basso",
            "upgradeErr8": "L'aspirapolvere/pulisci pavimenti non può essere aggiornato mentre non è in carica",
            "networkTimeout": "Timeout richiesta",
            "remoteTips": "L'aspirapolvere/pulisci pavimenti e il telefono non sono collegati alla stessa rete Wi-Fi. Connettere entrambi alla stessa rete in modo da utilizzare la funzionalità di controllo remoto.",
            "remoteTip2": "Controlla lo stato del firmware e della rete",
            "areaEditTip1": "Si consiglia di regolare le aree in base al layout effettivo della casa.",
            "areaEditTip2": "Seleziona due aree adiacenti da unire",
            "areaEditTip3": "Seleziona l'area che desideri rinominare",
            "areaEditTip4": "Seleziona un'area da rinominare",
            "areaNames": ["Seminterrato", "Soffitta", "Sala multimediale", "Sala da pranzo", "Balcone", "Sala attività", "Soggiorno", "Camera da letto", "Bagno", "Cucina"],
            "defaultArea": "Stanza predefinita",
            "addArea": "Aggiungi",
            "areaTipTitle": "Effettuare il partizionamento automatico prima dell'uso",
            "areaTipMessage": "Partizionamento automatico: l'aspirapolvere/pulisci pavimenti parte dala base di ricarica. Dopo la pulizia e la ricarica automatica, la mappa verrà automaticamente salvata e suddivisa in aree.",
            "areaTipButton": "OK",
            "use": "Utilizza",
            "used": "Corrente",
            "netErr": "Errore di rete",
            "voiceDownloadErr": "Impossibile scaricare il pacchetto vocale",
            "voiceTip": "Download del pacchetto vocale, riprovare più tardi",
            "warnInfoTitle": "Dettagli errore",
            "totalTime": "Tempo totale",
            "totalArea": "Area totale",
            "totalTimes": "Tempi totali",
            "spotTips": "Pulire l'area di 1,5 m per 1,5 m attorno al punto di coordinata",
            "timingNumTip": "La max. pulizia programmata è stata raggiunta, impossibile aggiungere una pulizia programmata.",
            "resetFail": "Ripristino non riuscito",
            "syncSuccess": "Sincronizzazione avvenuta con successo",
            "cleanTip": "Terminare la pulizia corrente e tornare alla base per caricare?",
            "licenseTitle": "Contratto di licenza",
            "policyTitle": "Informativa sulla privacy",
            "removeWaterBoxTitle": "Rimuovere la scheda dello straccio",
            "removeWaterBoxMessage": "Per iniziare la ricarica, rimuovere la scheda dello straccio",
            "keepSweeperTitle": "Riprendi pulizia",
            "keepSweeperMessage": "L'aspirapolvere/pulisci pavimenti riprenderà automaticamente le attività di pulizia non completate dopo aver caricato la batteria all'80%.",
            "emptyLog": "La cronologia è vuota",
            "disturbTip": "Non può coincidere con l'ora di inizio, imposta nuovamente.",
            "otatitle": "Controlla se sono disponibili aggiornamenti del firmware",
            "otaChecking": "Controllo in corso…",
            "currentVersion": "Versione in uso",
            "latestVersion": "Versione più recente",
            "isLatestVersion": "La versione in uso è la più recente.",
            "back": "Torna indietro",
            "checkVersionFailed": "Impossibile controllare gli aggiornamenti firmware",
            "retry": "Riprova",
            "updateNow": "Aggiorna adesso",
            "updateTip": "Posizionare l'aspirapolvere/pulisci pavimenti sulla base di ricarica prima dell'aggiornamento e assicurati che il livello della batteria sia superiore al 15%.",
            "upgradeErr": "Aggiornamento non riuscito",
            "updating": "Aggiornamento in corso...",
            "updateTip2": "In aggiornamento, non spegnere o utilizzare l'aspirapolvere/pulisci pavimenti prima che l'aggiornamento sia completato.",
            "installing": "Installazione aggiornamenti in corso...",
            "installtip": "Il processo di installazione richiede il riavvio dell'aspirapolvere/pulisci pavimenti. Questo potrebbe richiedere del tempo, sii paziente.",
            "updatesuccess": "Aggiornamento completato",
            "IntelligentScene": "Scene smart",
            "warnInfo": {
                "1": {
                    "title": "Le ruote sono sospese.",
                    "desc": "Riposizionare l'aspirapolvere/pulisci pavimenti e ricominciare.",
                    "warninfo": "Le ruote sono sospese, riposizionare l'aspirapolvere/pulisci pavimenti e ricominciare."
                },
                "2": {
                    "title": "Errore del sensore dell'ostacolo",
                    "desc": "Pulisci il sensore ostacoli e inizia la pulizia lontano da eventuali ostacoli.",
                    "warninfo": "Le ruote dell'aspirapolvere/pulisci pavimenti sono sospese, cerca di spostarle in una nuova posizione. Quando il sensore ostacoli è troppo sporco, può verificarsi anche questo tipo di errore. Pulisci il sensore ostacoli e riprova."
                },
                "3": {
                    "title": "Il sensore di collisione è bloccato",
                    "desc": "Pulire e toccare delicatamente il sensore di collisione.",
                    "warninfo": "Quando il paraurti è bloccato, cercare di toccarlo più volte per eliminare eventuali oggetti intrappolati. Quando non è bloccato, cercare di spostare l'aspirapolvere/pulisci pavimenti in una nuova posizione e ricominciare."
                },
                "4": {
                    "title": "L'aspirapolvere è inclinata",
                    "desc": "Sposta l'aspirapolvere/pulisci pavimenti su una superficie piana e ricomincia.",
                    "warninfo": "Sposta l'aspirapolvere/pulisci pavimenti su una superficie piana e ricomincia."
                },
                "5": {
                    "title": "Il sensore di collisione è bloccato",
                    "desc": "Pulire e toccare delicatamente il sensore di collisione.",
                    "warninfo": "Quando il paraurti è bloccato, cercare di toccarlo più volte per eliminare eventuali oggetti intrappolati. Quando non è bloccato, cercare di spostare l'aspirapolvere/pulisci pavimenti in una nuova posizione e ricominciare."
                },
                "6": {
                    "title": "Le ruote sono sospese.",
                    "desc": "Riposizionare l'aspirapolvere/pulisci pavimenti e ricominciare.",
                    "warninfo": "Le ruote sono sospese, riposizionare l'aspirapolvere/pulisci pavimenti e ricominciare."
                },
                "7": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "8": {
                    "title": "Il vano polvere non è stato installato.",
                    "desc": "Installe il vano polvere e il filtro.",
                    "warninfo": "Installa correttamente sia il vano polvere che il filtro. Se l'errore persiste, cerca di sostituire il filtro."
                },
                "11": {
                    "title": "Il filtro potrebbe non essere asciutto o potrebbe essere bloccato.",
                    "desc": "Verifica se il filtro si è asciugato o deve essere pulito.",
                    "warninfo": "Quando il filtro non è asciutto, lascialo asciugare per almeno 24 ore. Quando il filtro è bloccato, puliscilo. Se il problema non può essere risolto, sostituisci il filtro."
                },
                "12": {
                    "title": "Alcuni oggetti potrebbero essere avvolti attorno alla spazzola principale.",
                    "desc": "Rimuovere la spazzola principale e pulire le setole e i cuscinetti.",
                    "warninfo": "Alcuni oggetti potrebbero essere avvolti attorno alla spazzola principale, rimuovi la spazzola principale per pulire le setole e i cuscinetti."
                },
                "13": {
                    "title": "Alcuni oggetti potrebbero essere avvolti attorno alla spazzola laterale.",
                    "desc": "Rimuovere e pulire la spazzola laterale.",
                    "warninfo": "Alcuni oggetti potrebbero essere avvolti attorno alla spazzola laterale, rimuovi la spazzola laterale per pulire le setole."
                },
                "14": {
                    "title": "Il filtro potrebbe non essere asciutto o potrebbe essere bloccato.",
                    "desc": "Verifica se il filtro si è asciugato o deve essere pulito.",
                    "warninfo": "Quando il filtro non è asciutto, lascialo asciugare per almeno 24 ore. Quando il filtro è bloccato, puliscilo. Se il problema non può essere risolto, sostituisci il filtro."
                },
                "15": {
                    "title": "L'aspirapolvere/pulisci pavimenti è bloccata o le sue ruote potrebbero essere bloccate da un oggetto.",
                    "desc": "Controlla se le ruote sono bloccate da un oggetto, ruota le ruote per pulirle e sposta l'aspirapolvere/pulisci pavimenti in una nuova posizione per ricominciare.",
                    "warninfo": "Le ruote potrebbero essere bloccate da un oggetto, ruota le ruote per pulirle e ricomincia."
                },
                "16": {
                    "title": "L'aspirapolvere/pulisci pavimenti è bloccata o le sue ruote potrebbero essere bloccate da un oggetto.",
                    "desc": "Controlla se le ruote sono bloccate da un oggetto, ruota le ruote per pulirle e sposta l'aspirapolvere/pulisci pavimenti in una nuova posizione per ricominciare.",
                    "warninfo": "Le ruote potrebbero essere bloccate da un oggetto, ruota le ruote per pulirle e ricomincia."
                },
                "17": {
                    "title": "L 'aspirapolvere/pulisci pavimenti potrebbe essere ostruito o bloccato.",
                    "desc": "Elimina gli ostacoli circostanti",
                    "warninfo": "L 'aspirapolvere/pulisci pavimenti potrebbe essere ostruito o bloccato, elimina gli ostacoli circostanti."
                },
                "18": {
                    "title": "L 'aspirapolvere/pulisci pavimenti potrebbe essere ostruito o bloccato.",
                    "desc": "Elimina gli ostacoli circostanti",
                    "warninfo": "L 'aspirapolvere/pulisci pavimenti potrebbe essere ostruito o bloccato, elimina gli ostacoli circostanti."
                },
                "20": {
                    "title": "Batteria scarica",
                    "desc": "Il livello della batteria è troppo basso, ricarica.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Errore di ricarica",
                    "desc": "Errore di ricarica, prova a pulire l'area dei contatti di ricarica.",
                    "warninfo": "Pulisci i contatti di ricarica sia sulla base che sull'aspirapolvere/pulisci pavimenti con un panno asciutto."
                },
                "23": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "24": {
                    "title": "Errore del sensore di posizionamento visivo",
                    "desc": "Pulisci il sensore di posizionamento visivo.",
                    "warninfo": "Pulisci il sensore di posizionamento visivo e riavvia."
                },
                "25": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "29": {
                    "title": "Errore batteria",
                    "desc": "Errore batteria",
                    "warninfo": "La temperatura della batteria è troppo alta o troppo bassa, attendi che la temperatura della batteria sia di nuovo normale."
                },
                "30": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "31": {
                    "title": "L'aspirapolvere/pulisci pavimenti è bloccata o le sue ruote potrebbero essere bloccate da un oggetto.",
                    "desc": "Controlla se le ruote sono bloccate da un oggetto, ruota le ruote per pulirle e sposta l'aspirapolvere/pulisci pavimenti in una nuova posizione per ricominciare.",
                    "warninfo": "Le ruote potrebbero essere bloccate da un oggetto, ruota le ruote per pulirle e ricomincia."
                },
                "32": {
                    "title": "L'aspirapolvere/pulisci pavimenti è bloccata o le sue ruote potrebbero essere bloccate da un oggetto.",
                    "desc": "Controlla se le ruote sono bloccate da un oggetto, ruota le ruote per pulirle e sposta l'aspirapolvere/pulisci pavimenti in una nuova posizione per ricominciare.",
                    "warninfo": "Le ruote potrebbero essere bloccate da un oggetto, ruota le ruote per pulirle e ricomincia."
                },
                "33": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "34": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "35": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "36": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "37": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "38": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "39": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "40": {
                    "title": "Errore interno",
                    "desc": "Cerca di ripristinare il sistema.",
                    "warninfo": "Rilevato errore interno, impossibile continuare l'operazione, cerca di ripristinare il sistema."
                },
                "41": {
                    "title": "Rilevato un forte campo magnetico.",
                    "desc": "È stato rilevato un forte campo magnetico, stai lontano dalla parete virtuale.",
                    "warninfo": "L 'aspirapolvere/pulisci pavimenti è troppo vicino al muro virtuale all'avvio, spostalo in un'altra posizione per iniziare."
                }
            },
            "slidBrushWarnTipTitle1": "La spazzola laterale deve essere sostituita presto",
            "slidBrushWarnTipMsg1": "La spazzola laterale è quasi usurata, sostituirla il prima possibile.",
            "slidBrushWarnTipTitle2": "La spazzola laterale deve essere sostituita",
            "slidBrushWarnTipMsg2": "La spazzola laterale è usurata, sostituirla.",
            "rollingBrushWarnTitle1": "La spazzola principale deve essere sostituita presto",
            "rollingBrushWarnMsg1": "La spazzola principale è quasi usurata, sostituirla il prima possibile.",
            "rollingBrushWarnTitle2": "La spazzola principale deve essere sostituita",
            "rollingBrushWarnMsg2": "La spazzola principale èusurata, sostituirla.",
            "heapWarnTitle1": "Il filtro è quasi esaurito",
            "heapWarnMsg1": "Il filtro è quasi esaurito, sostituirlo il prima possibile.",
            "heapWarnTitle2": "Il filtro è esaurito",
            "heapWarnMsg2": "Il filtro è esaurito, sostituirlo.",
            "updateDialogTip": "Disponibile aggiornamento firmware ({version}). Aggiornare adesso?",
            "logDate": "{day}/{month} {hour}:{minute}"
        },
        'fr': {
            "IntelligentScene": "Smart Scenes",
            "cleaning": "Nettoyage",
            "mop": "Lavage",
            "customClean": "Nettoyage zoné",
            "cleaned": "Nettoyé",
            "cleantime": "Tem.de Netyg",
            "surplusPower": "Batterie",
            "charge": "Station",
            "chargePause": "Suspendre",
            "cleanPause": "Suspendre",
            "cleanStart": "Commencer \nle nettoyage",
            "areaClean": "Zone de nettoyage",
            "remoteClean": "Nettoyage de la télécommande",
            "localClean": "Nettoyage partiel",
            "chargingBtnText": "En charge",
            "charging": "En charge",
            "completedCharge": "Chargement terminé",
            "completedChargeBtnText": "Chargement \nterminé",
            "cleanMode": "Mode de nettoyage",
            "modeQuiet": "Silencieux",
            "modeStandard": "Standard",
            "modeMedium": "Medium",
            "modeStrong": "Turbo",
            "cleanTiming": "Nettoyage programmé",
            "cleanTimingStart": "Commence à {hour, plural,=0 {}other {# h et}} {minute} min",
            "cleanTimingEmpty": "Aucune tâche de nettoyage programmé",
            "areaEdit": "Éditeur de zone",
            "robotVoice": "Alertes vocales",
            "prompt": "Notifications",
            "waiting": "En veille",
            "gocharging": "Retour à la station pour charger",
            "areaSlect": "Zones sélectionnées : {areaNum}",
            "areaMerge": "Fusionner",
            "areaSplit": "Diviser",
            "areaRename": "Renommer",
            "spot": "Nettoyer cette partie",
            "setting": "Paramètres",
            "robotSetting": "Réglages de l'appareil",
            "msgSwitch": "Notifications",
            "cleanLog": "Historique de nettoyage",
            "materialTime": "Programme d'entretien",
            "remoteControl": "Télécommande",
            "productGuide": "Aide",
            "functionSetting": "Plus de paramètres",
            "generalSetting": "Paramètres généraux",
            "securitySetting": "Paramètres de sécurité",
            "moreSetting": "Réglages supplémentaires",
            "locationRobot": "Localiser mon aspirateur laveur",
            "timeZone": "Fuseau horaire de l'aspirateur laveur",
            "volume": "Paramètres de volume",
            "disturbTime": "Mode DND",
            "noTiming": "Aucun programme",
            "repeat": "Répéter",
            "once": "Une fois",
            "everyDay": "Chaque jour",
            "workDay": "Jours ouvrables (Lun. – Ven.)",
            "weekend": "Le week-end",
            "custom": "Personnaliser",
            "Sunday": "Dim.",
            "Monday": "Lun.",
            "Tuesday": "Mar.",
            "Wednesday": "Mer.",
            "Thursday": "Jeu.",
            "Friday": "Ven.",
            "Saturday": "Sam.",
            "startTime": "Heure de début",
            "sure": "OK",
            "cancle": "Annuler",
            "heap": "Filtre",
            "heapDesc": "Le filtre est fait de fibres de polymère qui empêche à la poussière de s'échapper du compartiment. Au fil du temps, il se bouchera petit à petit et perdra de son efficacité. Par conséquent, il est recommandé de remplacer le filtre toutes les {time} heures de fonctionnement ou moins.",
            "slidBrush": "Brosse latérale",
            "slidBrushDesc": "La brosse principale dirige les saletés et les débris des coins vers la brosse principale. Au fil du temps, elle va s'user et perdre de son efficacité. Par conséquent, il est recommandé de remplacer la brosse latérale après toutes les {time} heures de fonctionnement ou moins.",
            "rollingBrush": "Brosse principale",
            "rollingBrushDesc": "La brosse principale dirige les saletés et les débris dans le compartiment à poussière de l'aspirateur laveur. Au fil du temps, elle va s'user et perdre de son efficacité. Par conséquent, il est recommandé de remplacer la brosse principale toutes les {time} heures de fonctionnement ou moins.",
            "brushExpireDesc": "Remplacez dans environ {time} heures",
            "buy": "Acheter maintenant",
            "timezoneTip1": "Vous pouvez synchroniser le fuseau horaire de votre téléphone avec l'aspirateur laveur pour vous assurer que les deux sont dans le même fuseau horaire.",
            "timezoneTip2": "* Lorsque le fuseau horaire de l'aspirateur laveur est imprécis, les nettoyages programmés et le mode DND peuvent ne pas fonctionner comme souhaité.",
            "syncTimeZone": "Synchroniser maintenant",
            "volumeTip": "Le volume de l'alerte vocale de l'aspirateur laveur peut être réglé en déplaçant le coulissant vers le haut/bas. Tapoter le bouton de test de volume pour essayer.",
            "listen": "Écouter",
            "nodistrubTip": "Lorsque l'aspirateur laveur est actif, il ne reprendra pas automatiquement les nettoyages lors de la période spécifiée. Toutefois, les nettoyages programmés seront toujours effectués lors de la période DND.",
            "endTime": "Heure de fin",
            "remain": "Restant",
            "remainDay": "Durée de vie restante : Environ {hour} heures",
            "materialReset": "Réinitialisation de {name}",
            "resetHeapTitle": "Réinitialiser le temps d'utilisation du filtre",
            "resetHeapMessage": "Le filtre a-t-il été remplacé avec un nouveau filtre?",
            "resetRollingBrushTitle": "Réinitialiser le temps d'utilisation de la brosse principale",
            "resetRollingBrushMessage": "La brosse principale a-t-elle été remplacée avec une nouvelle?",
            "resetSlidBrushTitle": "Réinitialiser le temps d'utilisation de la brosse latérale",
            "resetSlidBrushMessage": "La brosse latérale a-t-elle été remplacée avec une nouvelle?",
            "deveiceName": "Nom de l'apppareil",
            "deviceShare": "Partage sur dispositif",
            "locationManager": "Gestion de la localisation",
            "otaCheck": "Mise à jour du micrologiciel",
            "deleteDevice": "Supprimer l'appareil",
            "addDesktop": "Ajouter un raccourci vers l'écran d'accueil",
            "feedback": "Commentaires",
            "useTerms": "Informations légales",
            "loading": "Chargement des données...",
            "pause": "Suspendre",
            "timingStart": "Activer",
            "selectArea": "Sélectionnez une zone",
            "selectAreaDesc": "Ce nettoyage programmé sera invalide lorsque la carte change.",
            "confirm": "OK",
            "autoClean": "Nettoyage complet",
            "deleteMsg": "Supprimer ce programme",
            "upgradeErr1": "Impossible de télécharger le micrologiciel",
            "upgradeErr5": "Mise à jour du micrologiciel impossible",
            "upgradeErr7": "Impossible de mettre à jour lorsque le niveau de batterie est faible",
            "upgradeErr8": "L'aspirateur laveur ne peut être mis à jour pendant la charge",
            "networkTimeout": "Demande expirée",
            "remoteTips": "L'aspirateur laveur et le téléphone ne sont pas connectés au même réseau WiFi. Veuillez connecter les deux au même réseau afin d'utiliser la fonctionnalité de la télécommande.",
            "remoteTip2": "Vérifiez le micrologiciel et le statut du réseau",
            "areaEditTip1": "Il est recommandé de régler les zones en fonction la disposition actuelle de la maison.",
            "areaEditTip2": "Veuillez sélectionner deux zones adjacentes pour fusionner",
            "areaEditTip3": "Veuillez sélectionner la zone que vous souhaitez renommer.",
            "areaEditTip4": "Veuillez sélectionner une zone pour renommer",
            "areaNames": ["Sous-sol ", "Grenier", "Salle de presse", "Salle à manger", "Balcon", "Salle d'activités", "Séjour", "Chambre", "Salle de bain", "Cuisine"],
            "defaultArea": "Pièce par défaut",
            "addArea": "Ajouter",
            "areaTipTitle": "Veuillez effectuer le partitionnement avant l'utilisation",
            "areaTipMessage": "Le partitionnement automatique : l'aspirateur laveur démarre depuis la station de charge. Après le nettoyage et la recharge automatique réussie, la carte sera automatiquement sauvegardée et partitionnée en zones.",
            "areaTipButton": "OK",
            "use": "Utiliser",
            "used": "Courant",
            "netErr": "Erreur de réseau",
            "voiceDownloadErr": "Impossible de télécharger le pack vocal",
            "voiceTip": "Téléchargement du pack vocal en cours, veuillez essayer plus tard",
            "warnInfoTitle": "Détails d'erreur",
            "totalTime": "Temps total",
            "totalArea": "Zone totale",
            "totalTimes": "Nombre total",
            "spotTips": "Nettoyer une zone de 1,5 m × 1,5 m autour du point de coordonnée",
            "timingNumTip": "Le nettoyage programmé maximal a été atteint, impossible d'ajouter un nettoyage programmé.",
            "resetFail": "Échec de la réinitialisation",
            "syncSuccess": "Synchronisation réussie",
            "cleanTip": "Terminer le nettoyage actuel, et retourner à la station pour charger?",
            "licenseTitle": "Contrat d'utilisation",
            "policyTitle": "Politique de confidentialité",
            "removeWaterBoxTitle": "Retirer le tableau du laveur",
            "removeWaterBoxMessage": "Pour commencer la charge, bien vouloir retirer le tableau de lavage",
            "keepSweeperTitle": "Reprendre le nettoyage",
            "keepSweeperMessage": "L'aspirateur laveur reprendra automatiquement les tâches de nettoyage non achevées après que sa batterie a chargé à 80%.",
            "emptyLog": "L'historique est vide",
            "disturbTip": "Impossible d'être le même que le temps de démarrage, veuillez initialiser à nouveau.",
            "otatitle": "Vérifier les mises à jour du micrologiciel",
            "otaChecking": "Vérification en cours…",
            "currentVersion": "Version actuelle",
            "latestVersion": "Dernière version",
            "isLatestVersion": "La version en cours est la plus récente",
            "back": "Revenir en arrière",
            "checkVersionFailed": "Impossible de vérifier les mises à jour du micrologiciel",
            "retry": "Réessayez",
            "updateNow": "Mettre à jour maintenant",
            "updateTip": "Placez l'aspirateur laveur sur la station de charge avant de mettre à jour et rassurez-vous que le niveau de batterie est supérieur à 15 %.",
            "upgradeErr": "Mise à jour impossible",
            "updating": "Mise à jour en cours…",
            "updateTip2": "Mise à jour en cours, n'éteignez pas ou n'utilisez pas l'aspirateur laveur avant que la mise à jour ne se soit terminée.",
            "installing": "Installation des mises à jour en cours...",
            "installtip": "Le processus d'installation exige de redémarrer l'aspirateur laveur. Ceci peut prendre un moment, veuillez patienter.",
            "updatesuccess": "Mise à jour réussie",
            "warnInfo": {
                "1": {
                    "title": "Les roues sont suspendues",
                    "desc": "Veuillez repositionner l'aspirateur laveur et recommencer.",
                    "warninfo": "Les roués sont suspendues, veuillez repositionner l'aspirateur laveur et recommencer."
                },
                "2": {
                    "title": "Erreur du capteur d'obstacles",
                    "desc": "Veuillez nettoyer le capteur d'obstacles et commencez le nettoyage loin des obstacles.",
                    "warninfo": "Les roues de l'aspirateur laveur sont suspendues. Essayez de le déplacer à un nouvel emplacement. Lorsque le capteur d'obstacles est trop sale, les erreurs de ce genre peuvent survenir. Veuillez nettoyer le capteur d'obstacles et réessayez."
                },
                "3": {
                    "title": "Le capteur de collision est coincé",
                    "desc": "Veuillez nettoyer et tapoter doucement le capteur de collision.",
                    "warninfo": "Lorsque le pare-chocs est coincé, essayez de le tapoter plusieurs fois pour dégager tout objet qui y serait pris. Lorsqu'il n'est pas coincé, essayez de déplacer l'aspirateur laveur à un nouvel emplacement et recommencez."
                },
                "4": {
                    "title": "L'aspirateur est incliné",
                    "desc": "Veuillez déplacer l'aspirateur laveur sur une surface plane et recommencez.",
                    "warninfo": "Veuillez déplacer l'aspirateur laveur sur une surface plane et recommencez."
                },
                "5": {
                    "title": "Le capteur de collision est coincé",
                    "desc": "Veuillez nettoyer et tapoter doucement le capteur de collision.",
                    "warninfo": "Lorsque le pare-chocs est coincé, essayez de le tapoter plusieurs fois pour dégager tout objet qui y serait pris. Lorsqu'il n'est pas coincé, essayez de déplacer l'aspirateur laveur à un nouvel emplacement et recommencez."
                },
                "6": {
                    "title": "Les roues sont suspendues",
                    "desc": "Veuillez repositionner l'aspirateur laveur et recommencer.",
                    "warninfo": "Les roués sont suspendues, veuillez repositionner l'aspirateur laveur et recommencer."
                },
                "7": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "8": {
                    "title": "Le compartiment n'a pas été installé.",
                    "desc": "Veuillez installer le compartiment à poussière et le filtre.",
                    "warninfo": "Veuillez correctement installer le compartiment à poussière et le filtre. S'il se produit une erreur, essayez de remplacer le filtre."
                },
                "11": {
                    "title": "Le filtre peut ne pas être sec ou peut être bloqué.",
                    "desc": "Veuillez vérifier si le filtre a séché ou s'il doit être nettoyé.",
                    "warninfo": "Lorsque le filtre n'est pas sec, veuillez le laisser sécher pendant au moins 24 heures. Lorsque le filtre est bloqué, veuillez le nettoyer. Si le problème persiste, veuillez remplacer le filtre."
                },
                "12": {
                    "title": "Certains objets peuvent être enroulés la brosse principale.",
                    "desc": "Veuillez retirer la brosse principale et nettoyer les soies et les roulements.",
                    "warninfo": "Certains objets peuvent être enroulés autour de la brosse principale, veuillez retirer la brosse principale pour nettoyer les soies et les roulements."
                },
                "13": {
                    "title": "Certains objets peuvent être enroulés autour de la brosse latérale.",
                    "desc": "Veuillez retirer et nettoyer la brosse latérale.",
                    "warninfo": "Certains objets peuvent être enroulés autour de la brosse latérale, veuillez retirer la brosse latérale pour nettoyer les soies."
                },
                "14": {
                    "title": "Le filtre peut ne pas être sec ou peut être bloqué.",
                    "desc": "Veuillez vérifier si le filtre a séché ou s'il doit être nettoyé.",
                    "warninfo": "Lorsque le filtre n'est pas sec, veuillez le laisser sécher pendant au moins 24 heures. Lorsque le filtre est bloqué, veuillez le nettoyer. Si le problème persiste, veuillez remplacer le filtre."
                },
                "15": {
                    "title": "L'aspirateur laveur est coincé, ou que ses roues peuvent être bloquées par un objet.",
                    "desc": "Vérifiez si les roues sont bloquées par un objet. Veuillez pivoter les roues pour les dégager, puis déplacez l'aspirateur laveur à un nouvel emplacement pour recommencer.",
                    "warninfo": "Les roues peuvent être bloquées par un objet, veuillez pivoter les roues pour les dégager, puis réessayez."
                },
                "16": {
                    "title": "L'aspirateur laveur est coincé, ou que ses roues peuvent être bloquées par un objet.",
                    "desc": "Vérifiez si les roues sont bloquées par un objet. Veuillez pivoter les roues pour les dégager, puis déplacez l'aspirateur laveur à un nouvel emplacement pour recommencer.",
                    "warninfo": "Les roues peuvent être bloquées par un objet, veuillez pivoter les roues pour les dégager, puis réessayez."
                },
                "17": {
                    "title": "L'aspirateur laveur peut être bloqué ou coincé.",
                    "desc": "Veuillez dégager les obstacles environnants",
                    "warninfo": "L'aspirateur laveur peut être bloqué ou coincé, veuillez dégager les obstacles environnants."
                },
                "18": {
                    "title": "L'aspirateur laveur peut être bloqué ou coincé.",
                    "desc": "Veuillez dégager les obstacles environnants",
                    "warninfo": "L'aspirateur laveur peut être bloqué ou coincé, veuillez dégager les obstacles environnants."
                },
                "20": {
                    "title": "Batterie faible",
                    "desc": "Le niveau de batterie est trop bas, veuillez recharger.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Erreur de charge",
                    "desc": "Erreur de charge, veuillez essayer de charger la zone de contact de charge.",
                    "warninfo": "Veuillez nettoyer les contacts de charge sur la station et sur l'aspirateur laveur à l'aide d'un tissu."
                },
                "23": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "24": {
                    "title": "Erreur du capteur de positionnement visuel",
                    "desc": "Veuillez nettoyer le capteur de positionnement visuel.",
                    "warninfo": "Veuillez nettoyer le capteur de positionnement visuel, puis recommencer."
                },
                "25": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "29": {
                    "title": "Erreur de batterie",
                    "desc": "Erreur de batterie",
                    "warninfo": "La température de la batterie est trop élevée ou trop basse, veuillez attendre jusqu'à ce que la température de la batterie revienne à la normale."
                },
                "30": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "31": {
                    "title": "L'aspirateur laveur est coincé, ou que ses roues peuvent être bloquées par un objet.",
                    "desc": "Vérifiez si les roues sont bloquées par un objet. Veuillez pivoter les roues pour les dégager, puis déplacez l'aspirateur laveur à un nouvel emplacement pour recommencer.",
                    "warninfo": "Les roues peuvent être bloquées par un objet, veuillez pivoter les roues pour les dégager, puis réessayez."
                },
                "32": {
                    "title": "L'aspirateur laveur est coincé, ou que ses roues peuvent être bloquées par un objet.",
                    "desc": "Vérifiez si les roues sont bloquées par un objet. Veuillez pivoter les roues pour les dégager, puis déplacez l'aspirateur laveur à un nouvel emplacement pour recommencer.",
                    "warninfo": "Les roues peuvent être bloquées par un objet, veuillez pivoter les roues pour les dégager, puis réessayez."
                },
                "33": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "34": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "35": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "36": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "37": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "38": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "39": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "40": {
                    "title": "Erreur interne",
                    "desc": "Veuillez essayer de réinitialiser le système.",
                    "warninfo": "Erreur interne détectée, impossible de poursuivre le fonctionnement, veuillez essayer de réinitialiser du système."
                },
                "41": {
                    "title": "Fort champ magnétique détecté.",
                    "desc": "Fort champ magnétique détecté, veuillez rester éloigné du mur virtuel.",
                    "warninfo": "L'aspirateur laveur est trop proche du mur virtuel au démarrage, veuillez le déplacer à un autre emplacement pour commencer."
                }
            },
            "slidBrushWarnTipTitle1": "La brosse latérale nécessite un remplacement imminent",
            "slidBrushWarnTipMsg1": "La brosse latérale est presque usée. Veuillez la remplacer aussitôt que possible.",
            "slidBrushWarnTipTitle2": "La brosse latérale doit être remplacée",
            "slidBrushWarnTipMsg2": "La brosse latérale est use, veuillez la remplacer.",
            "rollingBrushWarnTitle1": "La brosse principale doit être remplacée bientôt",
            "rollingBrushWarnMsg1": "La brosse principale est presque usée. Veuillez la remplacer aussitôt que possible.",
            "rollingBrushWarnTitle2": "La brosse principale doit être remplacée",
            "rollingBrushWarnMsg2": "La brosse principale est usée, veuillez la replacer.",
            "heapWarnTitle1": "Le filtre est presque épuisé",
            "heapWarnMsg1": "Le filtre est presque épuisé, veuillez le remplacer aussitôt que possible.",
            "heapWarnTitle2": "Le filtre est épuisé",
            "heapWarnMsg2": "Le filtre est épuisé, veuillez le remplacer.",
            "updateDialogTip": "Mise à jour du firmware ({version}) disponible. Mettre à jour maintenant ?",
            "logDate": "{day}/{month} {hour}:{minute}"
        },
        "es": {
            "IntelligentScene": "Escenas inteligentes",
            "cleaning": "Limpiando...",
            "mop": "Fregando...",
            "customClean": "Limpieza zonificada",
            "cleaned": "Limpiado",
            "cleantime": "Tiempo de limp.",
            "surplusPower": "Batería",
            "charge": "Acoplar",
            "chargePause": "Pausar",
            "cleanPause": "Pausar",
            "cleanStart": "Comenzar \nlimpieza",
            "areaClean": "Área de limpieza",
            "remoteClean": "Limpieza de mando a distancia",
            "localClean": "Limpieza parcial",
            "chargingBtnText": "Cargando",
            "charging": "Cargando...",
            "completedCharge": "Carga completa",
            "completedChargeBtnText": "Carga \ncompleta",
            "cleanMode": "Modo de limpieza",
            "modeQuiet": "Silencioso",
            "modeStandard": "Normal",
            "modeMedium": "Medio",
            "modeStrong": "Turbo",
            "cleanTiming": "Limpieza programada",
            "cleanTimingStart": "Comienza en {hour, plural,=0 {}other {# h y }}{minute} min",
            "cleanTimingEmpty": "No hay tareas de limpieza programada",
            "areaEdit": "Editor de área",
            "robotVoice": "Alertas de voz",
            "prompt": "Notificaciones",
            "waiting": "En espera",
            "gocharging": "Volviendo a la base de carga...",
            "areaSlect": "Áreas seleccionadas: {areaNum}",
            "areaMerge": "Unir",
            "areaSplit": "Dividir",
            "areaRename": "Renombrar",
            "spot": "Limpiar allí",
            "setting": "Ajustes",
            "robotSetting": "Configuración del dispositivo",
            "msgSwitch": "Notificaciones",
            "cleanLog": "Historial de limpieza",
            "materialTime": "Calendario de servicio",
            "remoteControl": "Mando a distancia",
            "productGuide": "Ayuda",
            "functionSetting": "Más ajustes",
            "generalSetting": "Ajustes generales",
            "securitySetting": "Ajustes de seguridad",
            "moreSetting": "Ajustes adicionales",
            "locationRobot": "Localizar mi aspirador",
            "timeZone": "Zona horaria del aspirador",
            "volume": "Ajustes de volumen",
            "disturbTime": "Modo DND",
            "noTiming": "Sin horario programado",
            "repeat": "Repetir",
            "once": "Una vez",
            "everyDay": "Diariamente",
            "workDay": "Días laborables (lunes a viernes)",
            "weekend": "Fines de semana",
            "custom": "Personalizado",
            "Sunday": "Dom",
            "Monday": "Lun",
            "Tuesday": "Mar",
            "Wednesday": "Mié",
            "Thursday": "Jue",
            "Friday": "Vie",
            "Saturday": "Sáb",
            "startTime": "Hora de inicio",
            "sure": "Aceptar",
            "cancle": "Cancelar",
            "heap": "Filtro",
            "heapDesc": "El filtro está hecho de fibras de polímero para impedir que el polvo escape del compartimento. Con el tiempo, lentamente se bloqueará, perdiendo su efectividad. Por lo tanto, es recomendable reemplazar el filtro al menos cada {time} horas de funcionamiento.",
            "slidBrush": "Cepillo lateral",
            "slidBrushDesc": "El cepillo lateral dirige suciedad y basura desde las esquinas hacia el cepillo principal. Con el tiempo, se desgastará por el uso y perderá su efectividad. Por lo tanto, es recomendable reemplazar el cepillo lateral al menos cada {time} horas de funcionamiento.",
            "rollingBrush": "Cepillo principal",
            "rollingBrushDesc": "El cepillo principal dirige suciedad y basura al compartimento de polvo del aspirador. Con el tiempo, se desgastará por el uso y perderá su efectividad. Por lo tanto, es recomendable reemplazar el cepillo principal al menos cada {time} horas de funcionamiento.",
            "brushExpireDesc": "Reemplazar aproximadamente después de {time} horas",
            "buy": "Compre ahora",
            "timezoneTip1": "Puede sincronizar la zona horaria de su teléfono con su aspirador, para asegurarse de que ambos estén en la misma zona horaria.",
            "timezoneTip2": "* Cuando la zona horaria del aspirador es inexacta, las limpiezas calendarizadas y el modo DND (no molestar) pueden no funcionar como se espera.",
            "syncTimeZone": "Sincronizar ahora",
            "volumeTip": "El volumen de la alerta de voz del aspirador se puede ajustar moviendo el control deslizante hacia arriba y abajo. Pulse el botón de volumen de prueba para probar.",
            "listen": "Escuche",
            "nodistrubTip": "Mientras está habilitado, el aspirador no reanudará automáticamente las limpiezas durante el período especificado. Sin embargo, las limpiezas programadas se llevarán a cabo durante el período DND.",
            "endTime": "Hora de finalización",
            "remain": "Restante",
            "remainDay": "Vida útil restante: Aproximadamente {hour} horas",
            "materialReset": "Restablecer {name}",
            "resetHeapTitle": "Reinicia tpo. de uso del filtro",
            "resetHeapMessage": "¿Se ha reemplazado el filtro por uno nuevo?",
            "resetRollingBrushTitle": "Reinicia tpo. de uso del cepillo principal",
            "resetRollingBrushMessage": "¿Se ha reemplazado el cepillo principal por uno nuevo?",
            "resetSlidBrushTitle": "Reinicia tpo. de uso del cepillo lateral",
            "resetSlidBrushMessage": "¿Se ha reemplazado el cepillo lateral por uno nuevo?",
            "deveiceName": "Nombre del dispositivo",
            "deviceShare": "Uso compartido de dispositivos",
            "locationManager": "Gestión de localización",
            "otaCheck": "Actualización de firmware",
            "deleteDevice": "Eliminar el dispositivo",
            "addDesktop": "Añadir acceso directo a la pantalla de inicio",
            "feedback": "Comentarios",
            "useTerms": "Información legal",
            "loading": "Cargando datos...",
            "pause": "Pausado",
            "timingStart": "Activar",
            "selectArea": "Seleccione área",
            "selectAreaDesc": "Esta limpieza calendarizada no será válida cuando cambie el mapa.",
            "confirm": "Aceptar",
            "autoClean": "Limpieza completa",
            "deleteMsg": "Borrar esta programación",
            "upgradeErr1": "No se ha podido descargar el firmware",
            "upgradeErr5": "No se ha podido actualizar el firmware",
            "upgradeErr7": "No se puede actualizar cuando el nivel de batería es demasiado bajo",
            "upgradeErr8": "El aspirador no se puede actualizar cuando no tenga carga",
            "networkTimeout": "La solicitud ha superado el tiempo de espera",
            "remoteTips": "El aspirador y el teléfono no están conectados a la misma red wifi. Conéctelos a la misma red para usar la funcionalidad de mando a distancia.",
            "remoteTip2": "Compruebe el firmware y el estado de la red",
            "areaEditTip1": "Es recomendable ajustar las áreas de acuerdo con el diseño real de la casa.",
            "areaEditTip2": "Seleccione dos áreas adyacentes para fusionarlas",
            "areaEditTip3": "Seleccione el área que desea renombrar",
            "areaEditTip4": "Seleccione un área para renombrar",
            "areaNames": ["Sótano", "Ático", "Sala Multimedia", "Comedor", "Balcón", "Sala de Actividades", "Sala de Estar", "Dormitorio", "Baño", "Cocina"],
            "defaultArea": "Habitación predeterminada",
            "addArea": "Añadir",
            "areaTipTitle": "Haga la división automática antes de usar",
            "areaTipMessage": "División automática: El aspirador comienza desde el acoplador de carga. Después de limpiar y lograr recargar automáticamente, el mapa se dividirá en áreas y se guardará automáticamente.",
            "areaTipButton": "Aceptar",
            "use": "Uso",
            "used": "Actual",
            "netErr": "Error de red",
            "voiceDownloadErr": "No se ha podido descargar el paquete de voz",
            "voiceTip": "Descargando paquete de voz, intente nuevamente más tarde",
            "warnInfoTitle": "Detalles de error",
            "totalTime": "Tiempo total",
            "totalArea": "Área total",
            "totalTimes": "Veces totales",
            "spotTips": "Limpie un área de 1,5 m por 1,5 m alrededor de la coordenada",
            "timingNumTip": "Se ha alcanzado el máximo de limpiezas programadas, no se puede calendarizar otra más.",
            "resetFail": "No se ha podido restablecer.",
            "syncSuccess": "Sincronizado con éxito",
            "cleanTip": "¿Finalizar la limpieza actual y volver al acoplador para cargar?",
            "licenseTitle": "Acuerdo de usuario",
            "policyTitle": "Política de privacidad",
            "removeWaterBoxTitle": "Desacople el compartimiento de limpieza",
            "removeWaterBoxMessage": "Desacople el compartimiento de limpieza mientras carga la bateria",
            "keepSweeperTitle": "Reanudar la limpieza",
            "keepSweeperMessage": "El aspirador reanudará automáticamente las tareas de limpieza sin terminar después de cargar su batería al 80%.",
            "emptyLog": "El histórico está vacío",
            "disturbTip": "No puede ser la misma que la hora de inicio, vuelva a configurar.",
            "otatitle": "Buscar actualizaciones del firmware",
            "otaChecking": "Comprobando…",
            "currentVersion": "Versión actual",
            "latestVersion": "Última versión",
            "isLatestVersion": "La versión actual es la última existente.",
            "back": "Volver",
            "checkVersionFailed": "No se pudo verificar las actualizaciones de firmware",
            "retry": "Vuelva a intentarlo",
            "updateNow": "Actualizar ahora",
            "updateTip": "Coloque el aspirador en el acoplador de recarga antes de actualizar y asegúrese de que el nivel de la batería sea superior al 15%.",
            "upgradeErr": "No se pudo actualizar",
            "updating": "Actualizando…",
            "updateTip2": "Al actualizar, no apague ni use el aspirador antes de que se complete la actualización.",
            "installing": "Instalando actualización…",
            "installtip": "El proceso de instalación requiere reiniciar el aspirador. Esto puede tomar un rato, sea paciente.",
            "updatesuccess": "Se ha actualizado correctamente",
            "warnInfo": {
                "1": {
                    "title": "Las ruedas están suspendidas",
                    "desc": "Reposicione el aspirador y comience de nuevo.",
                    "warninfo": "Las ruedas están suspendidas, reposicione el aspirador y comience de nuevo."
                },
                "2": {
                    "title": "Error del sensor de obstáculos",
                    "desc": "Limpie con un trapo el sensor de obstáculos y comience la limpieza lejos de cualquier obstáculo.",
                    "warninfo": "Las ruedas del aspirador están suspendidas, intente moverlo a una nueva ubicación. Este tipo de error también puede ocurrir cuando el sensor está demasiado sucio. Limpie el sensor de obstáculos y vuelva a intentarlo."
                },
                "3": {
                    "title": "El sensor de colisión está atascado",
                    "desc": "Limpie y pulse suavemente el sensor de colisión.",
                    "warninfo": "Cuando el parachoques está atascado, intente pulsarlo varias veces para despejar los objetos atrapados. Cuando no esté atascado, intente mover el aspirador a una nueva ubicación y comience de nuevo."
                },
                "4": {
                    "title": "El aspirador está inclinado.",
                    "desc": "Mueva el aspirador una superficie plana y comience nuevamente.",
                    "warninfo": "Mueva el aspirador una superficie plana y comience nuevamente."
                },
                "5": {
                    "title": "El sensor de colisión está atascado",
                    "desc": "Limpie y pulse suavemente el sensor de colisión.",
                    "warninfo": "Cuando el parachoques está atascado, intente pulsarlo varias veces para despejar los objetos atrapados. Cuando no esté atascado, intente mover el aspirador a una nueva ubicación y comience de nuevo."
                },
                "6": {
                    "title": "Las ruedas están suspendidas",
                    "desc": "Reposicione el aspirador y comience de nuevo.",
                    "warninfo": "Las ruedas están suspendidas, reposicione el aspirador y comience de nuevo."
                },
                "7": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "8": {
                    "title": "El compartimento para polvo no se ha instalado.",
                    "desc": "Instale el compartimento para polvo y el filtro.",
                    "warninfo": "Instale correctamente el compartimento para polvo y el filtro. Si el error persiste, intente reemplazar el filtro."
                },
                "11": {
                    "title": "El filtro puede no estar seco o estar bloqueado.",
                    "desc": "Verifique si el filtro se ha secado o si necesita ser limpiado.",
                    "warninfo": "Cuando el filtro no esté seco, déjelo secar durante por lo menos 24 horas. Cuando el filtro está bloqueado, límpielo. Si el problema no se resuelve, reemplace el filtro."
                },
                "12": {
                    "title": "Algún objeto puede estar enrollado alrededor del cepillo principal.",
                    "desc": "Retire el cepillo principal y limpie las cerdas y los cojinetes.",
                    "warninfo": "Algún objeto puede estar enrollado alrededor del cepillo principal, retire el cepillo para limpiar las cerdas y los cojinetes."
                },
                "13": {
                    "title": "Algún objeto puede estar enrollado alrededor del cepillo lateral.",
                    "desc": "Retire y limpie el cepillo lateral.",
                    "warninfo": "Algún objeto puede estar enrollado alrededor del cepillo lateral, retire el cepillo para limpiar las cerdas."
                },
                "14": {
                    "title": "El filtro puede no estar seco o estar bloqueado.",
                    "desc": "Verifique si el filtro se ha secado o si necesita ser limpiado.",
                    "warninfo": "Cuando el filtro no esté seco, déjelo secar durante por lo menos 24 horas. Cuando el filtro está bloqueado, límpielo. Si el problema no se resuelve, reemplace el filtro."
                },
                "15": {
                    "title": "El aspirador está atascado y sus ruedas podrían estar bloqueadas por un objeto.",
                    "desc": "Compruebe si las ruedas están bloqueadas por un objeto, gírelas para limpiarlas y mueva el aspirador a una nueva ubicación para comenzar de nuevo.",
                    "warninfo": "Las ruedas pueden estar bloqueadas por un objeto, gírelas para limpiarlas y comience nuevamente."
                },
                "16": {
                    "title": "El aspirador está atascado y sus ruedas podrían estar bloqueadas por un objeto.",
                    "desc": "Compruebe si las ruedas están bloqueadas por un objeto, gírelas para limpiarlas y mueva el aspirador a una nueva ubicación para comenzar de nuevo.",
                    "warninfo": "Las ruedas pueden estar bloqueadas por un objeto, gírelas para limpiarlas y comience nuevamente."
                },
                "17": {
                    "title": "El aspirador puede estar bloqueado o atascado.",
                    "desc": "Elimine los obstáculos en el área circundante",
                    "warninfo": "El aspirador puede estar bloqueado o atascado, elimine los obstáculos en el área circundante."
                },
                "18": {
                    "title": "El aspirador puede estar bloqueado o atascado.",
                    "desc": "Elimine los obstáculos en el área circundante",
                    "warninfo": "El aspirador puede estar bloqueado o atascado, elimine los obstáculos en el área circundante."
                },
                "20": {
                    "title": "Batería baja",
                    "desc": "El nivel de la batería está demasiado bajo, recárguela.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Error al recargar",
                    "desc": "Error al recargar, intente limpiar el área de contacto de recarga.",
                    "warninfo": "Limpie con un paño seco los contactos de recarga tanto en el acoplador como en el aspirador."
                },
                "23": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "24": {
                    "title": "Error del sensor de posicionamiento visual",
                    "desc": "Limpie el sensor de posicionamiento visual.",
                    "warninfo": "Limpie el sensor de posicionamiento visual y vuelva a empezar."
                },
                "25": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "29": {
                    "title": "Error de la batería",
                    "desc": "Error de la batería",
                    "warninfo": "La temperatura de la batería está demasiado alta o baja, espere hasta que la temperatura de la batería vuelva a ser normal."
                },
                "30": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "31": {
                    "title": "El aspirador está atascado y sus ruedas podrían estar bloqueadas por un objeto.",
                    "desc": "Compruebe si las ruedas están bloqueadas por un objeto, gírelas para limpiarlas y mueva el aspirador a una nueva ubicación para comenzar de nuevo.",
                    "warninfo": "Las ruedas pueden estar bloqueadas por un objeto, gírelas para limpiarlas y comience nuevamente."
                },
                "32": {
                    "title": "El aspirador está atascado y sus ruedas podrían estar bloqueadas por un objeto.",
                    "desc": "Compruebe si las ruedas están bloqueadas por un objeto, gírelas para limpiarlas y mueva el aspirador a una nueva ubicación para comenzar de nuevo.",
                    "warninfo": "Las ruedas pueden estar bloqueadas por un objeto, gírelas para limpiarlas y comience nuevamente."
                },
                "33": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "34": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "35": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "36": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "37": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "38": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "39": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "40": {
                    "title": "Error interno",
                    "desc": "Intente reiniciar el sistema.",
                    "warninfo": "Se ha detectado un error interno, no puede continuar funcionando, intente reiniciar el sistema."
                },
                "41": {
                    "title": "Se detectó un fuerte campo magnético.",
                    "desc": "Se detectó un fuerte campo magnético, no acercarse a la pared virtual.",
                    "warninfo": "El aspirador está al inicio demasiado cerca del muro virtual, muévalo a otra ubicación para comenzar."
                }
            },
            "slidBrushWarnTipTitle1": "El cepillo lateral necesita ser reemplazado pronto",
            "slidBrushWarnTipMsg1": "El cepillo lateral está casi desgastado, reemplácelo lo antes posible.",
            "slidBrushWarnTipTitle2": "El cepillo lateral necesita ser reemplazado",
            "slidBrushWarnTipMsg2": "El cepillo lateral está gastado, reemplácelo.",
            "rollingBrushWarnTitle1": "El cepillo principal necesita ser reemplazado pronto",
            "rollingBrushWarnMsg1": "El cepillo principal está casi desgastado, reemplácelo lo antes posible.",
            "rollingBrushWarnTitle2": "El cepillo principal necesita ser reemplazado",
            "rollingBrushWarnMsg2": "El cepillo principal está gastado, reemplácelo.",
            "heapWarnTitle1": "El filtro está casi agotado",
            "heapWarnMsg1": "El filtro está casi agotado, reemplácelo lo antes posible.",
            "heapWarnTitle2": "El filtro está agotado",
            "heapWarnMsg2": "El filtro está agotado, reemplácelo.",
            "updateDialogTip": "Hay una actualización ({version}) de firmware ¿Actualizar ahora?",
            "logDate": "{day}/{month} {hour}:{minute}"
        },
        "de": {
            "IntelligentScene": "Intelligente Szenen",
            "cleaning": "Reinigung",
            "mop": "Wischen",
            "customClean": "Zonen-Reinigung",
            "cleaned": "Gereinigt",
            "cleantime": "Reinigungszeit",
            "surplusPower": "Batterie",
            "charge": "Ladestation",
            "chargePause": "Pause",
            "cleanPause": "Pause",
            "cleanStart": "Start der \nReinigung",
            "areaClean": "Flächenreinigung",
            "remoteClean": "Reinigung mit der Fernbedienung",
            "localClean": "Teilreinigung",
            "chargingBtnText": "Laden",
            "charging": "Laden",
            "completedCharge": "Laden beendet",
            "completedChargeBtnText": "Laden \nbeendet",
            "cleanMode": "Reinigungs-Modus",
            "modeQuiet": "Leicht",
            "modeStandard": "Standard",
            "modeMedium": "Mittel",
            "modeStrong": "Turbo",
            "cleanTiming": "Geplante Reinigung",
            "cleanTimingStart": "Startet in {hour, plural,=0 {}other {# Std. }}und {minute} Min.",
            "cleanTimingEmpty": "Keine geplanten Reinigungsaufgaben",
            "areaEdit": "Flächenbearbeiter",
            "robotVoice": "Sprachalarme",
            "prompt": "Benachrichtigungen",
            "waiting": "In Bereitschaft",
            "gocharging": "Rückkehr zur Ladestation zum Aufladen",
            "areaSlect": "Flächen ausgewählt: {areaNum}",
            "areaMerge": "Zusammenführen",
            "areaSplit": "Teilen",
            "areaRename": "Umbenennen",
            "spot": "Dort reinigen",
            "setting": "Einstellungen",
            "robotSetting": "Geräteeinstellungen",
            "msgSwitch": "Benachrichtigungen",
            "cleanLog": "Reinigungsverlauf",
            "materialTime": "Serviceplan",
            "remoteControl": "Fernbedienung",
            "productGuide": "Hilfe",
            "functionSetting": "Weitere Einstellungen",
            "generalSetting": "Allgemeine Einstellungen",
            "securitySetting": "Sicherheitseinstellungen",
            "moreSetting": "Zusätzliche Einstellungen",
            "locationRobot": "Aufsuchen meines Staubsauger-Wischers",
            "timeZone": "Die Zeitzone des Staubsauger-Wischers",
            "volume": "Lautstärke-Einstellungen",
            "disturbTime": "DND-Modus",
            "noTiming": "Keine Pläne",
            "repeat": "Wiederholen",
            "once": "Einmal",
            "everyDay": "Täglich",
            "workDay": "Arbeitstage (Mo-Fr)",
            "weekend": "Wochenenden",
            "custom": "Angepasst",
            "Sunday": "So.",
            "Monday": "Mo.",
            "Tuesday": "Di.",
            "Wednesday": "Mi.",
            "Thursday": "Do.",
            "Friday": "Fr.",
            "Saturday": "Sa.",
            "startTime": "Startzeit",
            "sure": "OK",
            "cancle": "Abbrechen",
            "heap": "Filter",
            "heapDesc": "Der Filter besteht aus Polymerfasern, um zu verhindern, dass Staub aus dem Staubbehälter entkommt. Mit der Zeit verstopft er sich langsam und verliert seine Wirksamkeit. Daher empfehlen wir, den Filter alle {time} Betriebsstunden oder früher auszutauschen.",
            "slidBrush": "Seitenbürste",
            "slidBrushDesc": "Die Seitenbürste leitet Schmutz und Verunreinigungen aus den Ecken zur Hauptbürste. Mit der Zeit nutzt sie sich ab und verliert ihre Wirksamkeit. Daher empfehlen wir, die Seitenbürste alle {time} Betriebsstunden oder früher auszutauschen.",
            "rollingBrush": "Hauptbürste",
            "rollingBrushDesc": "Die Hauptbürste leitet Schmutz und Verunreinigungen in den Staubbehälter des Staubsauger-Wischers. Mit der Zeit nutzt sie sich ab und verliert ihre Wirksamkeit. Daher empfehlen wir, die Hauptbürste alle {time} Betriebsstunden oder früher auszutauschen.",
            "brushExpireDesc": "Austauschen in ca. {time} Stunden",
            "buy": "Jetzt kaufen",
            "timezoneTip1": "Sie können die Zeitzone Ihres Telefons mit Ihrem Staubsauger-Wischer synchronisieren, um sicherzustellen, dass sich beide in der gleichen Zeitzone befinden.",
            "timezoneTip2": "* Wenn die Zeitzone des Staubsauger-Wischers nicht richtig eingestellt ist, funktionieren geplante Reinigungsarbeiten und der DND-Modus möglicherweise nicht wie erwartet.",
            "syncTimeZone": "Jetzt synchronisieren",
            "volumeTip": "Die Lautstärke des Sprachalarms des Staubsauger-Wischers kann durch Bewegen des Schiebereglers nach oben/unten eingestellt werden. Tippen Sie zum Ausprobieren auf die Taste Testlautstärke.",
            "listen": "Anhören",
            "nodistrubTip": "Wenn diese Option aktiviert ist, setzt der Staubsauger-Wischer die Reinigungen während des angegebenen Zeitraums nicht automatisch fort. Geplante Reinigungen werden jedoch weiterhin während der DND-Periode durchgeführt.",
            "endTime": "Endzeit",
            "remain": "Verbleibend",
            "remainDay": "Verbleibende Lebensdauer: ca. {hour} Stunden",
            "materialReset": "{name} Zurücksetzen",
            "resetHeapTitle": "Filter-Nutzungsdauer zurücksetzen",
            "resetHeapMessage": "Wurde der Filter durch einen neuen ersetzt?",
            "resetRollingBrushTitle": "Hauptbürste-Nutzungsdauer zurücksetzen",
            "resetRollingBrushMessage": "Wurde die Hauptbürste durch eine neue ersetzt?",
            "resetSlidBrushTitle": "Seitenbürsten-Nutzungsdauer zurücksetzen",
            "resetSlidBrushMessage": "Wurde die Seitenbürste durch eine neue ersetzt?",
            "deveiceName": "Gerätename",
            "deviceShare": "Gerät freigeben",
            "locationManager": "Standortverwaltung",
            "otaCheck": "Firmware-Aktualisierung",
            "deleteDevice": "Gerät löschen",
            "addDesktop": "Verknüpfung für Startseite hinzufügen",
            "feedback": "Feedback",
            "useTerms": "Rechtliche Hinweise",
            "loading": "Daten werden geladen...",
            "pause": "Pause",
            "timingStart": "Aktivieren",
            "selectArea": "Fläche auswählen",
            "selectAreaDesc": "Diese geplante Reinigung ist ungültig, wenn sich die Karte ändert.",
            "confirm": "OK",
            "autoClean": "Vollständige Reinigung",
            "deleteMsg": "Löschen Sie diesen Zeitplan",
            "upgradeErr1": "Konnte die Firmware nicht herunterladen",
            "upgradeErr5": "Firmware konnte nicht aktualisiert werden.",
            "upgradeErr7": "Kann nicht aktualisiert werden, wenn der Akkustand zu niedrig ist",
            "upgradeErr8": "Der Staubsauger-Wischer kann nicht aktualisiert werden, wenn er nicht geladen ist",
            "networkTimeout": "Zeitüberschreitung der Anforderung",
            "remoteTips": "Der Staubsauger-Wischer und das Telefon sind nicht mit demselben Wi-Fi-Netz verbunden. Bitte verbinden Sie beide Geräte mit dem gleichen Netz, um die Fernsteuerungsfunktionalität zu nutzen.",
            "remoteTip2": "Überprüfen Sie die Firmware und den Netzstatus",
            "areaEditTip1": "Wir empfehlen, die Flächen an das tatsächliche Layout des Hauses anzupassen.",
            "areaEditTip2": "Bitte wählen Sie zwei benachbarte Bereiche aus, um sie zusammenzulegen",
            "areaEditTip3": "Bitte wählen Sie die Fläche aus, die Sie umbenennen möchten",
            "areaEditTip4": "Bitte wählen Sie eine Fläche zur Umbenennung aus",
            "areaNames": ["Untergeschoss", "Dachgeschoss", "Medienraum", "Esszimmer", "Balkon", "Aktivitätsraum", "Wohnzimmer", "Schlafzimmer", "Bad", "Küche"],
            "defaultArea": "Standardraum",
            "addArea": "Hinzufügen",
            "areaTipTitle": "Bitte führen Sie vor dem Gebrauch eine automatische Aufteilung durch",
            "areaTipMessage": "Automatische Aufteilung: Der Staubsauger-Wischer beginnt an der Ladestation. Nach der Reinigung und dem erfolgreichen automatischen Aufladen wird die Karte automatisch gespeichert und in Flächen aufgeteilt.",
            "areaTipButton": "O. K.",
            "use": "Verwenden",
            "used": "Strom",
            "netErr": "Netzwerkfehler",
            "voiceDownloadErr": "Das Sprachpaket konnte nicht heruntergeladen werden",
            "voiceTip": "Das Sprachpaket herunterladen, bitte versuchen Sie es später noch einmal",
            "warnInfoTitle": "Fehlerdetails",
            "totalTime": "Gesamtzeit",
            "totalArea": "Gesamtfläche",
            "totalTimes": "Gesamtzeiten",
            "spotTips": "Reinigen Sie die 1,5 m × 1,5 m große Fläche um den Koordinatenpunkt herum",
            "timingNumTip": "Die maximale Anzahl der geplanten Reinigungen ist erreicht, eine weitere geplante Reinigung kann nicht hinzugefügt werden.",
            "resetFail": "Konnte nicht zurückgesetzt werden",
            "syncSuccess": "Erfolgreiche Synchronisation",
            "cleanTip": "Die aktuelle Reinigung beenden und zum Aufladen zur Ladestation zurückkehren?",
            "licenseTitle": "Nutzungsvereinbarung",
            "policyTitle": "Datenschutzerklärung",
            "removeWaterBoxTitle": "Entfernen Sie das Brett des Wischers",
            "removeWaterBoxMessage": "Um mit dem Aufladen zu beginnen, entfernen Sie bitte das Brett des Wischers",
            "keepSweeperTitle": "Reinigung fortsetzen",
            "keepSweeperMessage": "Der Staubsauger-Wischer nimmt nach dem Aufladen des Akkus auf 80 % automatisch die noch offenen Reinigungsaufgaben wieder auf.",
            "emptyLog": "Die Historie ist leer",
            "disturbTip": "Kann nicht identisch mit der Startzeit sein, bitte erneut einstellen.",
            "otatitle": "Nach Firmware-Aktualisierungen suchen",
            "otaChecking": "Wird überprüft…",
            "currentVersion": "Aktuelle Version",
            "latestVersion": "Neueste Version",
            "isLatestVersion": "Aktuelle Version ist die neueste",
            "back": "Zurück",
            "checkVersionFailed": "Konnte Firmware-Aktualisierungen nicht suchen",
            "retry": "Erneut versuchen",
            "updateNow": "Jetzt aktualisieren",
            "updateTip": "Stellen Sie den Staubsauger-Wischer vor dem Aktualisieren in die Ladestation und stellen Sie sicher, dass der Akkustand mehr als 15 % beträgt.",
            "upgradeErr": "Aktualisieren nicht möglich",
            "updating": "Aktualisierung wird ausgeführt…",
            "updateTip2": "Aktualisierung, nicht ausschalten oder den Staubsauger-Wischer verwenden, bevor die Aktualisierung abgeschlossen ist.",
            "installing": "Aktualisierungen werden installiert...",
            "installtip": "Der Installationsprozess erfordert einen Neustart des Staubsauger-Wischers. Dies kann eine Weile dauern, bitte haben Sie Geduld.",
            "updatesuccess": "Erfolgreich aktualisiert",
            "warnInfo": {
                "1": {
                    "title": "Räder sind aufgehängt",
                    "desc": "Bitte stellen Sie den Staubsauger-Wischer neu auf und starten Sie erneut.",
                    "warninfo": "Die Räder sind aufgehängt, bitte den Staubsauger-Wischer neu positionieren und neu starten."
                },
                "2": {
                    "title": "Hindernissensorfehler",
                    "desc": "Bitte wischen Sie den Hindernissensor ab und starten Sie die Reinigung von eventuellen Hindernissen entfernt.",
                    "warninfo": "Die Räder des Staubsauger-Wischers sind aufgehängt, versuchen Sie, ihn an einen anderen Ort zu bringen. Wenn der Hindernissensor zu verschmutzt ist, kann auch dieser Fehler auftreten. Bitte wischen Sie den Hindernissensor sauber und versuchen Sie es erneut."
                },
                "3": {
                    "title": "Kollisionssensor klemmt",
                    "desc": "Bitte reinigen und vorsichtig auf den Kollisionssensor klopfen.",
                    "warninfo": "Wenn die Stoßstange festsitzt, versuchen Sie mehrmals darauf zu klopfen, um eingeschlossene Fremdkörper zu entfernen. Wenn er nicht klemmt, versuchen Sie, den Staubsauger-Wischer an einen neuen Ort zu bringen und beginnen Sie erneut."
                },
                "4": {
                    "title": "Der Staubsauger-Wischer ist gekippt",
                    "desc": "Bitte bewegen Sie den Staubsauger-Wischer auf eine ebene Fläche und starten Sie erneut.",
                    "warninfo": "Bitte bewegen Sie den Staubsauger-Wischer auf eine ebene Fläche und starten Sie erneut."
                },
                "5": {
                    "title": "Kollisionssensor klemmt",
                    "desc": "Bitte reinigen und vorsichtig auf den Kollisionssensor klopfen.",
                    "warninfo": "Wenn die Stoßstange festsitzt, versuchen Sie mehrmals darauf zu klopfen, um eingeschlossene Fremdkörper zu entfernen. Wenn er nicht klemmt, versuchen Sie, den Staubsauger-Wischer an einen neuen Ort zu bringen und beginnen Sie erneut."
                },
                "6": {
                    "title": "Räder sind aufgehängt",
                    "desc": "Bitte stellen Sie den Staubsauger-Wischer neu auf und starten Sie erneut.",
                    "warninfo": "Die Räder sind aufgehängt, bitte den Staubsauger-Wischer neu positionieren und neu starten."
                },
                "7": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "8": {
                    "title": "Der Staubbehälter ist nicht installiert.",
                    "desc": "Bitte installieren Sie den Staubbehälter und den Filter.",
                    "warninfo": "Bitte installieren Sie sowohl den Staubbehälter als auch den Filter korrekt. Wenn der Fehler weiterhin auftritt, versuchen Sie, den Filter zu ersetzen."
                },
                "11": {
                    "title": "Der Filter ist möglicherweise nicht trocken oder blockiert.",
                    "desc": "Bitte prüfen Sie, ob der Filter getrocknet ist oder gereinigt werden muss.",
                    "warninfo": "Wenn der Filter nicht trocken ist, lassen Sie ihn bitte mindestens 24 Stunden trocknen. Wenn der Filter blockiert ist, reinigen Sie ihn bitte. Wenn das Problem nicht behoben werden kann, ersetzen Sie bitte den Filter."
                },
                "12": {
                    "title": "Ein Fremdkörper kann sich um die Hauptbürste gewickelt haben.",
                    "desc": "Entfernen Sie die Hauptbürste und reinigen Sie ihre Borsten und Lager.",
                    "warninfo": "Ein Fremdkörper kann sich um die Hauptbürste gewickelt haben, bitte entfernen Sie die Hauptbürste, um die Borsten und Lager zu reinigen."
                },
                "13": {
                    "title": "Ein Fremdkörper kann sich um die Seitenbürste gewickelt haben.",
                    "desc": "Entfernen und reinigen Sie die Seitenbürste.",
                    "warninfo": "Ein Fremdkörper kann sich um die Seitenbürste gewickelt haben, bitte entfernen Sie die Seitenbürste, um die Borsten zu reinigen."
                },
                "14": {
                    "title": "Der Filter ist möglicherweise nicht trocken oder blockiert.",
                    "desc": "Bitte prüfen Sie, ob der Filter getrocknet ist oder gereinigt werden muss.",
                    "warninfo": "Wenn der Filter nicht trocken ist, lassen Sie ihn bitte mindestens 24 Stunden trocknen. Wenn der Filter blockiert ist, reinigen Sie ihn bitte. Wenn das Problem nicht behoben werden kann, ersetzen Sie bitte den Filter."
                },
                "15": {
                    "title": "Der Staubsauger-Wischer, oder seine Räder können durch einen Fremdkörper blockiert sein.",
                    "desc": "Überprüfen Sie, ob die Räder durch einen Fremdkörper blockiert sind, drehen Sie bitte die Räder, um sie zu reinigen, und bewegen Sie den Staubsauger-Wischer an einen neuen Ort, um neu zu starten.",
                    "warninfo": "Die Räder können durch einen Fremdkörper blockiert sein, bitte drehen Sie die Räder, um sie zu reinigen, und starten Sie erneut."
                },
                "16": {
                    "title": "Der Staubsauger-Wischer, oder seine Räder können durch einen Fremdkörper blockiert sein.",
                    "desc": "Überprüfen Sie, ob die Räder durch einen Fremdkörper blockiert sind, drehen Sie bitte die Räder, um sie zu reinigen, und bewegen Sie den Staubsauger-Wischer an einen neuen Ort, um neu zu starten.",
                    "warninfo": "Die Räder können durch einen Fremdkörper blockiert sein, bitte drehen Sie die Räder, um sie zu reinigen, und starten Sie erneut."
                },
                "17": {
                    "title": "Der Staubsauger-Wischer kann blockiert oder verklemmt sein.",
                    "desc": "Beseitigen Sie bitte die umliegenden Hindernisse",
                    "warninfo": "Der Staubsauger-Wischer kann blockiert oder verklemmt sein, bitte entfernen Sie die umliegenden Hindernisse."
                },
                "18": {
                    "title": "Der Staubsauger-Wischer kann blockiert oder verklemmt sein.",
                    "desc": "Beseitigen Sie bitte die umliegenden Hindernisse",
                    "warninfo": "Der Staubsauger-Wischer kann blockiert oder verklemmt sein, bitte entfernen Sie die umliegenden Hindernisse."
                },
                "20": {
                    "title": "Niedriger Akkuladestand",
                    "desc": "Akkuladezustand ist zu niedrig, bitte aufladen.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Ladefehler",
                    "desc": "Ladefehler, bitte versuchen Sie, die Ladekontaktfläche zu reinigen.",
                    "warninfo": "Bitte wischen Sie die Ladekontakte sowohl an der Ladestation als auch am Staubsauger-Wischer mit einem trockenen Tuch ab."
                },
                "23": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "24": {
                    "title": "Fehler des optischen Positionierungssensors",
                    "desc": "Bitte reinigen Sie den optischen Positionierungssensor.",
                    "warninfo": "Bitte wischen Sie den optischen Positionierungssensor sauber und starten Sie ihn neu."
                },
                "25": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "29": {
                    "title": "Akkufehler",
                    "desc": "Akkufehler",
                    "warninfo": "Die Akkutemperatur ist zu hoch oder zu niedrig, bitte warten Sie, bis die Akkutemperatur wieder normal ist."
                },
                "30": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "31": {
                    "title": "Der Staubsauger-Wischer, oder seine Räder können durch einen Fremdkörper blockiert sein.",
                    "desc": "Überprüfen Sie, ob die Räder durch einen Fremdkörper blockiert sind, drehen Sie bitte die Räder, um sie zu reinigen, und bewegen Sie den Staubsauger-Wischer an einen neuen Ort, um neu zu starten.",
                    "warninfo": "Die Räder können durch einen Fremdkörper blockiert sein, bitte drehen Sie die Räder, um sie zu reinigen, und starten Sie erneut."
                },
                "32": {
                    "title": "Der Staubsauger-Wischer, oder seine Räder können durch einen Fremdkörper blockiert sein.",
                    "desc": "Überprüfen Sie, ob die Räder durch einen Fremdkörper blockiert sind, drehen Sie bitte die Räder, um sie zu reinigen, und bewegen Sie den Staubsauger-Wischer an einen neuen Ort, um neu zu starten.",
                    "warninfo": "Die Räder können durch einen Fremdkörper blockiert sein, bitte drehen Sie die Räder, um sie zu reinigen, und starten Sie erneut."
                },
                "33": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "34": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "35": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "36": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "37": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "38": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "39": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "40": {
                    "title": "Interner Fehler",
                    "desc": "Bitte versuchen Sie, das System zurückzusetzen.",
                    "warninfo": "Interner Fehler erkannt, kann nicht weiterarbeiten, bitte versuchen Sie, das System zurückzusetzen."
                },
                "41": {
                    "title": "Starkes Magnetfeld erkannt",
                    "desc": "Starkes Magnetfeld erkannt, bitte halten Sie sich von der virtuellen Wand fern.",
                    "warninfo": "Der Staubsauger-Wischer ist beim Start zu nah an der virtuellen Wand, bitte bewegen Sie ihn zum Starten an einen anderen Ort."
                }
            },
            "slidBrushWarnTipTitle1": "Die Seitenbürste muss bald ausgetauscht werden",
            "slidBrushWarnTipMsg1": "Die Seitenbürste ist fast abgenutzt, bitte ersetzen Sie sie so schnell wie möglich.",
            "slidBrushWarnTipTitle2": "Die Seitenbürste muss bald ausgetauscht werden",
            "slidBrushWarnTipMsg2": "Die Seitenbürste ist abgenutzt, bitte ersetzen Sie sie.",
            "rollingBrushWarnTitle1": "Die Hauptbürste muss bald ausgetauscht werden",
            "rollingBrushWarnMsg1": "Die Hauptbürste ist fast abgenutzt, bitte ersetzen Sie sie so schnell wie möglich.",
            "rollingBrushWarnTitle2": "Die Hauptbürste muss ausgetauscht werden",
            "rollingBrushWarnMsg2": "Die Hauptbürste ist abgenutzt, bitte ersetzen Sie sie.",
            "heapWarnTitle1": "Der Filter ist fast verbraucht",
            "heapWarnMsg1": "Der Filter ist fast verbraucht, bitte ersetzen Sie ihn so schnell wie möglich.",
            "heapWarnTitle2": "Der Filter ist verbraucht",
            "heapWarnMsg2": "Der Filter ist verbraucht, bitte ersetzen Sie ihn.",
            "updateDialogTip": "Firmware-Aktualisierung ({version}) verfügbar. Jetzt aktualisieren?",
            "logDate": "{day}/{month} {hour}:{minute}"
        },
        "ru": {
            "IntelligentScene": "Умные сценарии",
            "cleaning": "Очистка",
            "mop": "Влажная уборка",
            "customClean": "Зонированная уборка",
            "cleaned": "Очищено",
            "cleantime": "Время уборки",
            "surplusPower": "Аккумулятор",
            "charge": "Док-\nстанция",
            "chargePause": "Пауза",
            "cleanPause": "Пауза",
            "cleanStart": "Начать \nуборку",
            "areaClean": "Уборка области",
            "remoteClean": "Дистанционное управление уборкой",
            "localClean": "Частичная уборка",
            "chargingBtnText": "Зарядка",
            "charging": "Зарядка",
            "completedCharge": "Зарядка завершена",
            "completedChargeBtnText": "Зарядка \nзавершена",
            "cleanMode": "Режим уборки",
            "modeQuiet": "Бесшум.",
            "modeStandard": "Станд.",
            "modeMedium": "Средний",
            "modeStrong": "Турбо",
            "cleanTiming": "Плановая уборка",
            "cleanTimingStart": "Начало через {hour, plural,=0 { }other {# ч и }}{minute} мин.",
            "cleanTimingEmpty": "Нет запланированных операций по уборке",
            "areaEdit": "Редактор области",
            "robotVoice": "Голосовые оповещения",
            "prompt": "Уведомления",
            "waiting": "Режим ожидания",
            "gocharging": "Возврат на док-станцию для зарядки",
            "areaSlect": "Выбранные области: {areaNum}",
            "areaMerge": "Объединить",
            "areaSplit": "Разделить",
            "areaRename": "Переименовать",
            "spot": "Убирать там",
            "setting": "Настройки",
            "robotSetting": "Настройки устройства",
            "msgSwitch": "Уведомления",
            "cleanLog": "История уборок",
            "materialTime": "График обслуживания",
            "remoteControl": "Пульт ДУ",
            "productGuide": "Справка",
            "functionSetting": "Дополнительные настройки",
            "generalSetting": "Общие настройки",
            "securitySetting": "Настройки безопасности",
            "moreSetting": "Дополнительные настройки",
            "locationRobot": "Найти местонахождение робота-пылесоса с функцией влажной уборки",
            "timeZone": "Часовой пояс робота-пылесоса с функцией влажной уборки",
            "volume": "Настройки громкости",
            "disturbTime": "Режим \"Не беспокоить\"",
            "noTiming": "Графиков нет",
            "repeat": "Повтор",
            "once": "Один раз",
            "everyDay": "Ежедневно",
            "workDay": "Рабочие дни (пн–пт)",
            "weekend": "Выходные",
            "custom": "Пользовательский",
            "Sunday": "Вс",
            "Monday": "Пн",
            "Tuesday": "Вт",
            "Wednesday": "Ср",
            "Thursday": "Чт",
            "Friday": "Пт",
            "Saturday": "Сб",
            "startTime": "Время начала",
            "sure": "ОК",
            "cancle": "Отмена",
            "heap": "Фильтр",
            "heapDesc": "Фильтр изготовлен из полимерного волокна для предотвращения выброса пыли из контейнера для мусора. Со временем он будет забиваться и терять свою эффективность. Поэтому рекомендуется заменять фильтр после каждых {time} ч работы или раньше.",
            "slidBrush": "Боковая щетка",
            "slidBrushDesc": "Боковая щетка направляет грязь и мусор из углов в направлении основной щетки. Со временем ее эффективность будет снижаться ввиду износа. Поэтому рекомендуется заменять боковую щетку после {time} ч работы или раньше.",
            "rollingBrush": "Основная щетка",
            "rollingBrushDesc": "Основная щетка направляет грязь и мусор в контейнер для мусора робота-пылесоса с функцией влажной уборки. Со временем ее эффективность будет снижаться ввиду износа. Поэтому рекомендуется заменять основную щетку после {time} ч работы или раньше.",
            "brushExpireDesc": "Замените примерно через {time} ч",
            "buy": "Купить сейчас",
            "timezoneTip1": "Чтобы убедиться, что они находятся в одном часовом поясе, вы можете синхронизировать часовой пояс своего телефона с роботом-пылесосом с функцией влажной уборки.",
            "timezoneTip2": "* Если настройки часового пояса робота-пылесоса с функцией влажной уборки неточные, запланированная уборка и режим \"Не беспокоить\" могут работать не так, как ожидалось.",
            "syncTimeZone": "Синхронизировать",
            "volumeTip": "Громкость голосовых оповещений робота-пылесоса с функцией влажной уборки можно регулировать, перемещая ползунок вверх и вниз. Для проверки нажмите кнопку тестирования громкости.",
            "listen": "Прослушать",
            "nodistrubTip": "При включении робот-пылесос с функцией влажной уборки не будет автоматически возобновлять уборку в течение указанного периода. Тем не менее, запланированная уборка по-прежнему будут проводиться в течение периода \"Не беспокоить\".",
            "endTime": "Время окончания",
            "remain": "Осталось",
            "remainDay": "Оставшийся срок службы: прибл. {hour} ч",
            "materialReset": "Сбросить {name}",
            "resetHeapTitle": "Сброс времени исп. фильтра",
            "resetHeapMessage": "Был ли фильтр заменен новым?",
            "resetRollingBrushTitle": "Сброс времени исп. осн. щетки",
            "resetRollingBrushMessage": "Была ли основная щетка заменена новой?",
            "resetSlidBrushTitle": "Сброс времени исп. бок. Щетки",
            "resetSlidBrushMessage": "Была ли боковая щетка заменена новой?",
            "deveiceName": "Имя устройства",
            "deviceShare": "Предоставление доступа к устройству",
            "locationManager": "Управление местоположением",
            "otaCheck": "Обновление прошивки",
            "deleteDevice": "Удалить устройство",
            "addDesktop": "Добавить ярлык на главный экран",
            "feedback": "Отчет",
            "useTerms": "Юридическая информация",
            "loading": "Загрузка данных…",
            "pause": "Пауза",
            "timingStart": "Включить",
            "selectArea": "Выбор области",
            "selectAreaDesc": "Эта запланированная уборка будет недействительной при изменении карты.",
            "confirm": "OK",
            "autoClean": "Полная уборка",
            "deleteMsg": "Удалить это расписание",
            "upgradeErr1": "Не удалось загрузить прошивку",
            "upgradeErr5": "Не удалось обновить прошивку",
            "upgradeErr7": "Невозможно обновить, пока уровень заряда аккумулятора слишком низкий",
            "upgradeErr8": "Обновление робота-пылесоса с функцией влажной уборки не может быть выполнено, если он не на зарядке",
            "networkTimeout": "Время ожидания запроса истекло",
            "remoteTips": "Робот-пылесос с функцией влажной уборки и телефон не подключены к одной и той же сети Wi-Fi. Подключите оба устройства к одной сети для использования функции дистанционного управления.",
            "remoteTip2": "Проверьте встроенное ПО и состояние сети",
            "areaEditTip1": "Рекомендуется настроить области в соответствии с фактической планировкой дома.",
            "areaEditTip2": "Выберите две смежные области для объединения",
            "areaEditTip3": "Выберите область, которую вы желаете переименовать",
            "areaEditTip4": "Выберите одну область, чтобы переименовать",
            "areaNames": ["Подвал", "Чердак", "Медиа-зал", "Столовая", "Балкон", "Комната для занятий", "Гостиная", "Спальня", "Ванная комната", "Кухня"],
            "defaultArea": "Комната по умолчанию",
            "addArea": "Добавить",
            "areaTipTitle": "Выполните автоматическое разделение перед использованием",
            "areaTipMessage": "Автоматическое разделение: робот-пылесос с функцией влажной уборки находится на док-станции. После уборки и автоматической зарядки карта будет автоматически сохранена и разбита на области.",
            "areaTipButton": "OK",
            "use": "Использовать",
            "used": "Текущая",
            "netErr": "Ошибка сети",
            "voiceDownloadErr": "Не удалось загрузить голосовой пакет",
            "voiceTip": "Идет загрузка голосового пакета, повторите попытку позже",
            "warnInfoTitle": "Сведения об ошибке",
            "totalTime": "Общее время",
            "totalArea": "Общая площадь",
            "totalTimes": "Общее время",
            "spotTips": "Уборка области 1,5 × 1,5 м вокруг точки координат",
            "timingNumTip": "Достигнуто макс. количество запланированных уборок, невозможно добавить запланированную уборку.",
            "resetFail": "Не удалось сбросить",
            "syncSuccess": "Синхронизировано успешно",
            "cleanTip": "Завершить текущую уборку и вернуться к док-станции?",
            "licenseTitle": "Пользовательское соглашение",
            "policyTitle": "Политика конфиденциальности",
            "removeWaterBoxTitle": "Извлеките щит робота-пылесоса",
            "removeWaterBoxMessage": "Чтобы начать зарядку, извлеките щит робота-пылесоса",
            "keepSweeperTitle": "Возобновить уборку",
            "keepSweeperMessage": "Робот-пылесос с функцией влажной уборки автоматически возобновит незавершенные операции по уборке после того, как уровень заряда аккумулятора достигнет 80%.",
            "emptyLog": "Нет истории",
            "disturbTip": "Значение не может быть таким же, что и время начала. Установите заново.",
            "otatitle": "Проверка наличия обновлений встроенного ПО",
            "otaChecking": "Проверка…",
            "currentVersion": "Текущая версия",
            "latestVersion": "Последняя версия",
            "isLatestVersion": "Установлена последняя версия",
            "back": "Вернуться",
            "checkVersionFailed": "Не удалось проверить наличие обновлений прошивки",
            "retry": "Повторить попытку",
            "updateNow": "Обновить",
            "updateTip": "Перед обновлением установите робот-пылесос с функцией влажной уборки на док-станцию и убедитесь, что уровень заряда аккумулятора превышает 15%.",
            "upgradeErr": "Не удалось обновить",
            "updating": "Обновление…",
            "updateTip2": "Происходит обновление. Не выключайте и не используйте робот-пылесос с функцией влажной уборки до завершения обновления.",
            "installing": "Установка обновления…",
            "installtip": "В процессе установки требуется перезапуск робота-пылесоса с функцией влажной уборки. Это может занять некоторое время, подождите.",
            "updatesuccess": "Обновлено",
            "warnInfo": {
                "1": {
                    "title": "Колеса находятся на весу",
                    "desc": "Измените положение робота-пылесоса с функцией влажной уборки и снова запустите.",
                    "warninfo": "Колеса находятся на весу, измените положение робота-пылесоса с функцией влажной уборки и снова запустите."
                },
                "2": {
                    "title": "Ошибка датчика препятствий",
                    "desc": "Вытрите датчик препятствий и начните уборку вдали от препятствий.",
                    "warninfo": "Колеса робота-пылесоса с функцией влажной уборки находятся на весу, попробуйте переместить его на новое место. Такая ошибка может также произойти, если датчик препятствий слишком загрязнен. Протрите датчик препятствий и попробуйте снова."
                },
                "3": {
                    "title": "Датчик столкновений застрял",
                    "desc": "Очистите датчик столкновений и слегка постучите по нему.",
                    "warninfo": "Если бампер застрял, попробуйте постучать по нему несколько раз, чтобы устранить любые застрявшие предметы. Если он не застрял, попробуйте переместить робот-пылесос с функцией влажной уборки в новое место и снова запустите."
                },
                "4": {
                    "title": "Робот-пылесос наклонен",
                    "desc": "Переместите робот-пылесос с функцией влажной уборки на ровную поверхность и снова запустите.",
                    "warninfo": "Переместите робот-пылесос с функцией влажной уборки на ровную поверхность и снова запустите."
                },
                "5": {
                    "title": "Датчик столкновений застрял",
                    "desc": "Очистите датчик столкновений и слегка постучите по нему.",
                    "warninfo": "Если бампер застрял, попробуйте постучать по нему несколько раз, чтобы устранить любые застрявшие предметы. Если он не застрял, попробуйте переместить робот-пылесос с функцией влажной уборки в новое место и снова запустите."
                },
                "6": {
                    "title": "Колеса находятся на весу",
                    "desc": "Измените положение робота-пылесоса с функцией влажной уборки и снова запустите.",
                    "warninfo": "Колеса находятся на весу, измените положение робота-пылесоса с функцией влажной уборки и снова запустите."
                },
                "7": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "8": {
                    "title": "Не установлен контейнер для мусора.",
                    "desc": "Установите контейнер для мусора и фильтр.",
                    "warninfo": "Правильно установите контейнер для мусора и фильтр. Если это не устранит ошибку, попробуйте заменить фильтр."
                },
                "11": {
                    "title": "Возможно, фильтр не сухой или забитый.",
                    "desc": "Проверьте, высох ли фильтр и не нуждается ли он в очистке.",
                    "warninfo": "Если фильтр не сухой, дайте ему высохнуть в течение не менее 24 часов. Если фильтр забит, очистите его. Если проблему не удается решить, замените фильтр."
                },
                "12": {
                    "title": "Возможно, что-то намоталось на основную щетку.",
                    "desc": "Отсоедините основную щетку и очистите ее щетинки и подшипники.",
                    "warninfo": "Возможно, что-то намоталось на основную щетку. Отсоедините основную щетку, чтобы почистить щетинки и подшипники."
                },
                "13": {
                    "title": "Возможно, что-то намоталось на боковую щетку.",
                    "desc": "Отсоедините и очистите боковую щетку.",
                    "warninfo": "Возможно, что-то намоталось на боковую щетку. Отсоедините боковую щетку, чтобы почистить щетинки и подшипники."
                },
                "14": {
                    "title": "Возможно, фильтр не сухой или забитый.",
                    "desc": "Проверьте, высох ли фильтр и не нуждается ли он в очистке.",
                    "warninfo": "Если фильтр не сухой, дайте ему высохнуть в течение не менее 24 часов. Если фильтр забит, очистите его. Если проблему не удается решить, замените фильтр."
                },
                "15": {
                    "title": "Робот-пылесос с функцией влажной уборки застрял или его колеса заблокированы каким-либо предметом.",
                    "desc": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и переместите робот-пылесос с функцией влажной уборки в другое место для повторного запуска.",
                    "warninfo": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и запустите снова."
                },
                "16": {
                    "title": "Робот-пылесос с функцией влажной уборки застрял или его колеса заблокированы каким-либо предметом.",
                    "desc": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и переместите робот-пылесос с функцией влажной уборки в другое место для повторного запуска.",
                    "warninfo": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и запустите снова."
                },
                "17": {
                    "title": "Возможно, робот-пылесос с функцией влажной уборки заблокирован или застрял.",
                    "desc": "Устраните окружающие препятствия",
                    "warninfo": "Возможно, Робот-пылесос с функцией влажной уборки заблокирован или застрял. Устраните окружающие препятствия."
                },
                "18": {
                    "title": "Возможно, робот-пылесос с функцией влажной уборки заблокирован или застрял.",
                    "desc": "Устраните окружающие препятствия",
                    "warninfo": "Возможно, Робот-пылесос с функцией влажной уборки заблокирован или застрял. Устраните окружающие препятствия."
                },
                "20": {
                    "title": "Низкий уровень заряда аккумулятора",
                    "desc": "Уровень заряда аккумулятора слишком низкий. Зарядите его.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Ошибка зарядки",
                    "desc": "Ошибка зарядки. Попробуйте очистить зарядные контакты.",
                    "warninfo": "Протрите зарядные контакты на док-станции и роботе-пылесосе с функцией влажной уборки сухой тканью."
                },
                "23": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "24": {
                    "title": "Ошибка датчика визуального позиционирования",
                    "desc": "Очистите датчик визуального позиционирования.",
                    "warninfo": "Протрите датчик визуального позиционирования и выполните перезапуск."
                },
                "25": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "29": {
                    "title": "Ошибка аккумулятора",
                    "desc": "Ошибка аккумулятора",
                    "warninfo": "Температура аккумулятора слишком высокая или низкая. Подождите, пока она не нормализуется."
                },
                "30": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "31": {
                    "title": "Робот-пылесос с функцией влажной уборки застрял или его колеса заблокированы каким-либо предметом.",
                    "desc": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и переместите робот-пылесос с функцией влажной уборки в другое место для повторного запуска.",
                    "warninfo": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и запустите снова."
                },
                "32": {
                    "title": "Робот-пылесос с функцией влажной уборки застрял или его колеса заблокированы каким-либо предметом.",
                    "desc": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и переместите робот-пылесос с функцией влажной уборки в другое место для повторного запуска.",
                    "warninfo": "Возможно, какой-то предмет заблокировал колеса. Проверните колеса для очистки и запустите снова."
                },
                "33": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "34": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "35": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "36": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "37": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "38": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "39": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "40": {
                    "title": "Внутренняя ошибка",
                    "desc": "Сбросьте параметры системы.",
                    "warninfo": "Обнаружена внутренняя ошибка. Невозможно продолжить работу. Сбросьте параметры системы."
                },
                "41": {
                    "title": "Выявлено сильное магнитное поле",
                    "desc": "Выявлено сильное магнитное поле, держитесь подальше от виртуальной стены.",
                    "warninfo": "Робот-пылесос с функцией влажной уборки находится слишком близко к виртуальной стене во время запуска. Переместите его в другое место для запуска."
                }
            },
            "slidBrushWarnTipTitle1": "Боковую щетку необходимо скоро заменить",
            "slidBrushWarnTipMsg1": "Боковая щетка достигает предельной степени износа, замените ее как можно скорее.",
            "slidBrushWarnTipTitle2": "Необходимо заменить боковую щетку",
            "slidBrushWarnTipMsg2": "Боковая щетка изношена, замените ее.",
            "rollingBrushWarnTitle1": "Основную щетку необходимо скоро заменить",
            "rollingBrushWarnMsg1": "Основная щетка достигает предельной степени износа, замените ее как можно скорее.",
            "rollingBrushWarnTitle2": "Необходимо заменить основную щетку",
            "rollingBrushWarnMsg2": "Основная щетка изношена, замените ее.",
            "heapWarnTitle1": "Срок службы фильтра почти закончился",
            "heapWarnMsg1": "Срок службы фильтра почти закончился, замените его как можно скорее.",
            "heapWarnTitle2": "Срок службы фильтра закончился",
            "heapWarnMsg2": "Срок службы фильтра закончился, замените его.",
            "updateDialogTip": "Доступно обновление встроенного ПО ({version}). Обновить сейчас?",
            "logDate": "{day}.{month} {hour}:{minute}",
            "areaUnit": "м²",
            "minute": "мин"
        },
        "pl": {
            "IntelligentScene": "Inteligentne sceny",
            "cleaning": "Czyszczenie",
            "mop": "Mopowanie",
            "customClean": "Czyszczenie strefowe",
            "cleaned": "Wyczyszczone",
            "cleantime": "Czas czyszczenia",
            "surplusPower": "Akumulator",
            "charge": "Stacja \nładująca",
            "chargePause": "Wstrzymaj",
            "cleanPause": "Wstrzymaj",
            "cleanStart": "Początek \nsprzątania",
            "areaClean": "Czyszczenie obszarów",
            "remoteClean": "Czyszczenie zdalne",
            "localClean": "Czyszczenie częściowe",
            "chargingBtnText": "Ładowanie",
            "charging": "Ładowanie",
            "completedCharge": "Ładowanie zak",
            "completedChargeBtnText": "Ładowanie \nzak",
            "cleanMode": "Tryb czyszczenia",
            "modeQuiet": "Cichy",
            "modeStandard": "Normalny",
            "modeMedium": "Średni",
            "modeStrong": "Turbo",
            "cleanTiming": "Zaplanowane czyszczenie",
            "cleanTimingStart": "Rozpocznie się za {hour, plural,=0 {}other {# godz. i }}{minute} min",
            "cleanTimingEmpty": "Brak zaplanowanych zadań",
            "areaEdit": "Edytor obszarów",
            "robotVoice": "Alerty głosowe",
            "prompt": "Powiadomienia",
            "waiting": "Czuwanie",
            "gocharging": "Trwa powrót do stacji w celu ładowania",
            "areaSlect": "Wybrane obszary: {areaNum}",
            "areaMerge": "Połącz",
            "areaSplit": "Podziel",
            "areaRename": "Zmień nazwę",
            "spot": "Czyść w tamtym miejscu",
            "setting": "Ustawienia",
            "robotSetting": "Ustawienia urządzenia",
            "msgSwitch": "Powiadomienia",
            "cleanLog": "Historia czyszczenia",
            "materialTime": "Harmonogram usług",
            "remoteControl": "Zdalne sterowanie",
            "productGuide": "Pomoc",
            "functionSetting": "Więcej ustawień",
            "generalSetting": "Ustawienia ogólne",
            "securitySetting": "Ustawienia bezpieczeństwa",
            "moreSetting": "Dodatkowe ustawienia",
            "locationRobot": "Zlokalizuj mój odkurzacz z mopem",
            "timeZone": "Strefa czasowa odkurzacza z mopem",
            "volume": "Ustawienia głośności",
            "disturbTime": "Tryb DND",
            "noTiming": "Brak harmonogramów",
            "repeat": "Powtórz",
            "once": "Raz",
            "everyDay": "Codziennie",
            "workDay": "Dni robocze (pon. – pt.)",
            "weekend": "Dni wolne",
            "custom": "Niestandardowe",
            "Sunday": "Niedz.",
            "Monday": "Pon.",
            "Tuesday": "Wt.",
            "Wednesday": "Śr.",
            "Thursday": "Czw.",
            "Friday": "Pt.",
            "Saturday": "Sob.",
            "startTime": "Czas rozpoczęcia",
            "sure": "OK",
            "cancle": "Anuluj",
            "heap": "Filtr",
            "heapDesc": "Filtr zbudowany jest z włókien polimerowych i zapobiega wydostawaniu się kurzu z komory. Z czasem zaczyna się blokować, a jego wydolność ulega zmniejszeniu. Z tego powodu należy wymieniać filtr co {time} godzin roboczych lub częściej.",
            "slidBrush": "Szczotka kątowa",
            "slidBrushDesc": "Szczotka kątowa kieruje kurz i śmieci z narożników do szczotki głównej. Z czasem ulega zużyciu, rozdziera się i traci skuteczność. Z tego powodu należy wymieniać ją co {time} godzin roboczych lub częściej.",
            "rollingBrush": "Szczotka główna",
            "rollingBrushDesc": "Szczotka główna kieruje kurz i śmieci z narożników do komory odkurzacza z mopem. Z czasem ulega zużyciu, rozdziera się i traci skuteczność. Z tego powodu należy wymieniać ją co {time} godzin roboczych lub częściej.",
            "brushExpireDesc": "Wymień za około {time} godzin",
            "buy": "Kup już teraz",
            "timezoneTip1": "Możesz zsynchronizować strefę czasową swojego telefonu z odkurzaczem z mopem, aby zapewnić tę samą strefę czasową dla obu urządzeń.",
            "timezoneTip2": "* Jeśli strefa czasowa odkurzacza z mopem jest niewłaściwa, funkcja zaplanowanego czyszczenia i tryb DND mogą działać nieprawidłowo.",
            "syncTimeZone": "Synchronizuj teraz",
            "volumeTip": "Głośność alertów głosowych odkurzacza z mopem można ustawić za pomocą suwaka poruszanego w górę/dół. Kliknij przycisk próby głośności, aby sprawdzić ustawienia.",
            "listen": "Słuchaj",
            "nodistrubTip": "Po uruchomieniu tej funkcji odkurzacz z mopem nie będzie wznawiał czyszczenia automatycznie przez określony okres. Zaplanowane czyszczenia nadal będzie się odbywać w okresie DND.",
            "endTime": "Czas zakończenia",
            "remain": "Pozostało",
            "remainDay": "Pozostały okres eksploatacji: ok. {hour} godzin",
            "materialReset": "Zresetuj {name}",
            "resetHeapTitle": "Resetuj czas użyt. filtra",
            "resetHeapMessage": "Czy filtr wymieniono na nowy?",
            "resetRollingBrushTitle": "Resetuj czas użyt. szczotki gł",
            "resetRollingBrushMessage": "Czy szczotkę główną wymieniono na nową?",
            "resetSlidBrushTitle": "Resetuj czas użyt. szczotki kąt",
            "resetSlidBrushMessage": "Czy szczotkę kątową wymieniono na nową?",
            "deveiceName": "Nazwa urządzenia",
            "deviceShare": "Udostępnianie urządzenia",
            "locationManager": "Zarządzanie lokalizacją",
            "otaCheck": "Aktualizacja oprogramowania układowego",
            "deleteDevice": "Usuń urządzenie",
            "addDesktop": "Dodaj skrót do ekranu głównego",
            "feedback": "Opinia",
            "useTerms": "Informacje prawne",
            "loading": "Wczytywanie danych...",
            "pause": "Wstrzymaj",
            "timingStart": "Włącz",
            "selectArea": "Wybierz obszar",
            "selectAreaDesc": "Zaplanowane czyszczenie zostanie zdezaktualizowane po zmianie mapy.",
            "confirm": "OK",
            "autoClean": "Pełne czyszczenie",
            "deleteMsg": "Czy usunąć harmonogram",
            "upgradeErr1": "Nie udało się pobrać oprogramowania układowego",
            "upgradeErr5": "Nie można zaktualizować oprogramowania układowego",
            "upgradeErr7": "Urządzenia nie można zaktualizować przy zbyt niskim poziomie baterii",
            "upgradeErr8": "Odkurzacza z mopem nie można zaktualizować bez podłączenia go do ładowania",
            "networkTimeout": "Przekroczenie czasu żądania",
            "remoteTips": "Odkurzacz z mopem i telefon nie są podłączone do tej samej sieci Wi-Fi. Podłącz oba urządzenia do tej samej sieci, aby skorzystać z funkcji zdalnego sterowania.",
            "remoteTip2": "Sprawdź oprogramowanie układowe i stan sieci",
            "areaEditTip1": "Zaleca się dostosowanie obszarów do rzeczywistego planu domu.",
            "areaEditTip2": "Wybierz dwa sąsiadujące obszary, które chcesz połączyć",
            "areaEditTip3": "Wybierz obszar, którego nazwę chcesz zmienić",
            "areaEditTip4": "Wybierz jeden obszar, którego nazwę chcesz zmienić",
            "areaNames": ["Piwnica", "Strych", "Pomieszczenie medialne", "Jadalnia", "Balkon", "Pokój zabaw", "Salon", "Sypialnia", "Łazienka", "Kuchnia"],
            "defaultArea": "Domyślne pomieszczenie",
            "addArea": "Dodaj",
            "areaTipTitle": "Przed użyciem wykonaj automatyczny podział",
            "areaTipMessage": "Automatyczny podział: odkurzacz z mopem zacznie od stacji ładowania. Po czyszczeniu i pomyślnym ładowaniu mapa zostanie zapisana automatycznie i podzielona na obszary.",
            "areaTipButton": "OK",
            "use": "Użyj",
            "used": "Bieżący",
            "netErr": "Błąd sieci",
            "voiceDownloadErr": "Nie udało się pobrać pakietu głosowego",
            "voiceTip": "Trwa pobieranie pakietu głosowego, spróbuj ponownie później",
            "warnInfoTitle": "Szczegóły błędu",
            "totalTime": "Całkowity czas",
            "totalArea": "Całkowita powierzchnia",
            "totalTimes": "Całkowita liczba razy",
            "spotTips": "Wyczyść obszar 1,5 × 1,5 m dookoła współrzędnej",
            "timingNumTip": "Osiągnięto maks. obszar planowanego czyszczenia; nie można dodać zaplanowanego czyszczenia.",
            "resetFail": "Reset nie powiódł się",
            "syncSuccess": "Synchronizacja powiodła się",
            "cleanTip": "Zakończyć aktualne czyszczenie i wrócić do stacji w celu ładowania?",
            "licenseTitle": "Umowa użytkownika",
            "policyTitle": "Polityka prywatności",
            "removeWaterBoxTitle": "Zdejmij listwę mopa",
            "removeWaterBoxMessage": "Aby rozpocząć ładowanie, zdejmij listwę mopa",
            "keepSweeperTitle": "Wznowienie czyszczenia",
            "keepSweeperMessage": "Odkurzacz z mopem automatycznie wznawia nieukończone zadania po naładowaniu baterii w 80%.",
            "emptyLog": "Historia jest pusta",
            "disturbTip": "Nie może być taki sam, jak czas rozpoczęcia; ustaw go ponownie.",
            "otatitle": "Sprawdź aktualizacje oprogramowania układowego",
            "otaChecking": "Sprawdzanie…",
            "currentVersion": "Bieżąca wersja",
            "latestVersion": "Najnowsza wersja",
            "isLatestVersion": "Bieżąca wersja jest najnowsza",
            "back": "Wróć",
            "checkVersionFailed": "Nie można sprawdzić aktualizacji oprogramowania układowego",
            "retry": "Spróbuj ponownie",
            "updateNow": "Aktualizuj teraz",
            "updateTip": "Przed przystąpieniem do aktualizacji umieść odkurzacz z mopem w stacji ładowania i upewnij się, że poziom naładowania baterii jest większy niż 15%.",
            "upgradeErr": "Nie można zaktualizować",
            "updating": "Aktualizowanie…",
            "updateTip2": "Trwa aktualizowanie; nie wyłączaj i nie używaj odkurzacza z mopem przed ukończeniem aktualizacji.",
            "installing": "Instalowanie aktualizacji...",
            "installtip": "Proces instalacji wymaga zrestartowania odkurzacza z mopem. To może potrwać chwilę, prosimy o cierpliwość.",
            "updatesuccess": "Zaktualizowano pomyślnie",
            "warnInfo": {
                "1": {
                    "title": "Koła są zawieszone",
                    "desc": "Ustaw odkurzacz z mopem w innym miejscu, a następnie uruchom ponownie.",
                    "warninfo": "Koła są zawieszone, ustaw odkurzacz z mopem w innym miejscu, a następnie uruchom ponownie."
                },
                "2": {
                    "title": "Błąd czujnika przeszkód",
                    "desc": "Przetrzyj czujnik przeszkód i rozpocznij odkurzanie z dala od przeszkód.",
                    "warninfo": "Koła odkurzacza z mopem są zawieszone, spróbuj umieścić go w innym miejscu. Ten błąd może wystąpić również wtedy, gdy czujnik kurzu jest zabrudzony. Przetrzyj czujnik przeszkód i spróbuj ponownie."
                },
                "3": {
                    "title": "Czujnik zderzeń jest zablokowany",
                    "desc": "Oczyść i delikatnie stuknij czujnik zderzeń.",
                    "warninfo": "Po zablokowaniu zderzaka spróbuj stuknąć go kilka razy, aby usunąć uwięzione przedmioty. Jeśli zderzak nie jest zablokowany, spróbuj umieścić odkurzacz z mopem w innym miejscu, a następnie uruchom ponownie."
                },
                "4": {
                    "title": "Odkurzacz jest przechylony",
                    "desc": "Przenieś odkurzacz z mopem na płaską powierzchnię, a następnie uruchom ponownie.",
                    "warninfo": "Przenieś odkurzacz z mopem na płaską powierzchnię, a następnie uruchom ponownie."
                },
                "5": {
                    "title": "Czujnik zderzeń jest zablokowany",
                    "desc": "Oczyść i delikatnie stuknij czujnik zderzeń.",
                    "warninfo": "Po zablokowaniu zderzaka spróbuj stuknąć go kilka razy, aby usunąć uwięzione przedmioty. Jeśli zderzak nie jest zablokowany, spróbuj umieścić odkurzacz z mopem w innym miejscu, a następnie uruchom ponownie."
                },
                "6": {
                    "title": "Koła są zawieszone",
                    "desc": "Ustaw odkurzacz z mopem w innym miejscu, a następnie uruchom ponownie.",
                    "warninfo": "Koła są zawieszone, ustaw odkurzacz z mopem w innym miejscu, a następnie uruchom ponownie."
                },
                "7": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "8": {
                    "title": "Nie zamontowano pojemnika na kurz.",
                    "desc": "Zamontuj filtr i pojemnik na kurz.",
                    "warninfo": "Zamontuj poprawnie komorę kurzu i filtr. Jeśli błąd nadal występuje, spróbuj wymienić filtr."
                },
                "11": {
                    "title": "Filtr może być wilgotny lub zablokowany.",
                    "desc": "Sprawdź, czy filtr jest suchy i czy wymaga czyszczenia.",
                    "warninfo": "Jeśli filtr nie jest suchy, pozostaw go do wysuszenia na co najmniej 24 godziny. Jeśli filtr jest zablokowany, wyczyść go. Jeśli błąd nadal się pojawia, wymień filtr."
                },
                "12": {
                    "title": "Coś mogło nawinąć się na szczotkę główną.",
                    "desc": "Wyjmij szczotkę główną, aby wyczyścić szczecinę i łożyska.",
                    "warninfo": "Coś mogło się zawinąć wokół szczotki głównej. Wyjmij szczotkę, a następnie wyczyść szczecinę i łożyska."
                },
                "13": {
                    "title": "Coś mogło się nawinąć na szczotkę kątową.",
                    "desc": "Wyjmij i oczyść szczotkę kątową.",
                    "warninfo": "Coś mogło się zawinąć wokół szczotki kątowej. Wyjmij szczotkę, a następnie wyczyść szczecinę."
                },
                "14": {
                    "title": "Filtr może być wilgotny lub zablokowany.",
                    "desc": "Sprawdź, czy filtr jest suchy i czy wymaga czyszczenia.",
                    "warninfo": "Jeśli filtr nie jest suchy, pozostaw go do wysuszenia na co najmniej 24 godziny. Jeśli filtr jest zablokowany, wyczyść go. Jeśli błąd nadal się pojawia, wymień filtr."
                },
                "15": {
                    "title": "Odkurzacz z mopem jest zablokowany albo jego koła zablokował jakiś przedmiot.",
                    "desc": "Sprawdź, czy koła są zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne przenieś odkurzacz z mopem w inne miejsce i uruchom ponownie.",
                    "warninfo": "Koła mogą być zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne uruchom odkurzacz ponownie."
                },
                "16": {
                    "title": "Odkurzacz z mopem jest zablokowany albo jego koła zablokował jakiś przedmiot.",
                    "desc": "Sprawdź, czy koła są zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne przenieś odkurzacz z mopem w inne miejsce i uruchom ponownie.",
                    "warninfo": "Koła mogą być zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne uruchom odkurzacz ponownie."
                },
                "17": {
                    "title": "Odkurzacz z mopem mógł zostać zablokowany lub zatrzymany.",
                    "desc": "Usuń otaczające go przeszkody",
                    "warninfo": "Odkurzacz z mopem może być zablokowany lub zatrzymany; usuń przeszkody znajdujące się w pobliżu."
                },
                "18": {
                    "title": "Odkurzacz z mopem mógł zostać zablokowany lub zatrzymany.",
                    "desc": "Usuń otaczające go przeszkody",
                    "warninfo": "Odkurzacz z mopem może być zablokowany lub zatrzymany; usuń przeszkody znajdujące się w pobliżu."
                },
                "20": {
                    "title": "Niski poziom naładowania",
                    "desc": "Poziom naładowania baterii jest zbyt niski; naładuj ją.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Błąd ładowania",
                    "desc": "Błąd podczas ładowania; spróbuj wyczyścić styki ładowania.",
                    "warninfo": "Przetrzyj styki ładowania odkurzacza z mopem i stacji ładującej suchą ściereczką."
                },
                "23": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "24": {
                    "title": "Błąd czujnika pozycjonowania wizualnego",
                    "desc": "Wyczyść czujnik pozycjonowania wizualnego.",
                    "warninfo": "Przetrzyj czujnik pozycjonowania wizualnego i uruchom ponownie."
                },
                "25": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "29": {
                    "title": "Błąd akumulatora",
                    "desc": "Błąd akumulatora",
                    "warninfo": "Temperatura akumulatora jest zbyt wysoka lub niska, zaczekaj, aż się unormuje."
                },
                "30": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "31": {
                    "title": "Odkurzacz z mopem jest zablokowany albo jego koła zablokował jakiś przedmiot.",
                    "desc": "Sprawdź, czy koła są zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne przenieś odkurzacz z mopem w inne miejsce i uruchom ponownie.",
                    "warninfo": "Koła mogą być zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne uruchom odkurzacz ponownie."
                },
                "32": {
                    "title": "Odkurzacz z mopem jest zablokowany albo jego koła zablokował jakiś przedmiot.",
                    "desc": "Sprawdź, czy koła są zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne przenieś odkurzacz z mopem w inne miejsce i uruchom ponownie.",
                    "warninfo": "Koła mogą być zablokowane przez jakiś obiekt; obróć koła i wyczyść je, a następne uruchom odkurzacz ponownie."
                },
                "33": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "34": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "35": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "36": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "37": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "38": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "39": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "40": {
                    "title": "Błąd wewnętrzny",
                    "desc": "Spróbuj zresetować system",
                    "warninfo": "Wykryto błąd wewnętrzny, dalsze działanie niemożliwe, zrestartuj system."
                },
                "41": {
                    "title": "Wykryto silne pole magnetyczne",
                    "desc": "Wykryto silne pole magnetyczne, trzymaj się z dala od ściany wirtualnej.",
                    "warninfo": "Uruchamiany odkurzacz z mopem znajduje się zbyt blisko ściany wirtualnej; umieść go w innym miejscu, a następnie uruchom ponownie."
                }
            },
            "slidBrushWarnTipTitle1": "Szczotkę kątową należy wkrótce wymienić",
            "slidBrushWarnTipMsg1": "Szczotka kątowa jest bliska zużycia, wymień ją jak najszybciej.",
            "slidBrushWarnTipTitle2": "Szczotkę kątową należy wymienić",
            "slidBrushWarnTipMsg2": "Szczotka kątowa jest zużyta, wymień ją.",
            "rollingBrushWarnTitle1": "Szczotkę główną należy wkrótce wymienić",
            "rollingBrushWarnMsg1": "Szczotka główna jest bliska zużycia, wymień ją jak najszybciej.",
            "rollingBrushWarnTitle2": "Szczotkę główną należy wymienić",
            "rollingBrushWarnMsg2": "Szczotka główna jest zużyta, wymień ją.",
            "heapWarnTitle1": "Filtr jest bliski zużycia",
            "heapWarnMsg1": "Filtr jest bliski zużycia, wymień go jak najszybciej.",
            "heapWarnTitle2": "Filtr jest zużyty",
            "heapWarnMsg2": "Filtr jest zużyty, wymień go.",
            "updateDialogTip": "Jest dostępna aktualizacja oprogramowania układowego ({version}). Czy zaktualizować teraz?",
            "logDate": "{day}/{month} {hour}:{minute}"
        },
        "th": {
            "IntelligentScene": "ฉากอัจฉริยะ",
            "cleaning": "การทำความสะอาด",
            "mop": "ถูพื้น",
            "customClean": "การทำความสะอาดทีละบริเวณ",
            "cleaned": "ทำความ\nสะอาดแล้ว",
            "cleantime": "เวลาทำ\nความสะอาด",
            "surplusPower": "แบตเตอรี่",
            "charge": "แท่นชาร์จ",
            "chargePause": "หยุดชั่วคราว",
            "cleanPause": "หยุดชั่วคราว",
            "cleanStart": "เริ่มการทำ\nความสะอาด",
            "areaClean": "ทำความสะอาดพื้นที่",
            "remoteClean": "ทำความสะอาดโดยการควบคุมระยะไกล",
            "localClean": "ทำความสะอาดบางส่วน",
            "chargingBtnText": "กำลังชาร์จ",
            "charging": "กำลังชาร์จ",
            "completedCharge": "ชาร์จเสร็จแล้ว",
            "completedChargeBtnText": "ชาร์จ\nเสร็จแล้ว",
            "cleanMode": "โหมดทำความสะอาด",
            "modeQuiet": "เงียบ",
            "modeStandard": "มาตรฐาน",
            "modeMedium": "ปานกลาง",
            "modeStrong": "เทอร์โบ",
            "cleanTiming": "ตั้งเวลาทำความสะอาด",
            "cleanTimingStart": "เริ่มในเวลา {hour, plural,=0 {}other {# ชั่วโมง }}{minute} นาที",
            "cleanTimingEmpty": "ไม่มีค่ากำหนดเวลาทำความสะอาด",
            "areaEdit": "แก้ไขพื้นที่",
            "robotVoice": "แจ้งเตือนด้วยเสียง",
            "prompt": "การแจ้งเตือน",
            "waiting": "สแตนด์บาย",
            "gocharging": "กลับสู่แท่นเพื่อชาร์ท",
            "areaSlect": "พื้นที่เลือกแล้ว {areaNum}",
            "areaMerge": "รวมกัน",
            "areaSplit": "แยกกัน",
            "areaRename": "ตั้งชื่อใหม่",
            "spot": "ทำความสะอาดส่วนนั้น",
            "setting": "การตั้งค่า",
            "robotSetting": "การตั้งค่าอุปกรณ์",
            "msgSwitch": "การแจ้งเตือน",
            "cleanLog": "ประวัติการทำความสะอาด",
            "materialTime": "กำหนดการให้บริการ",
            "remoteControl": "รีโมทคอนโทรล",
            "productGuide": "ความช่วยเหลือ",
            "functionSetting": "การตั้งค่าเพิ่มเติม",
            "generalSetting": "การตั้งค่าทั่วไป",
            "securitySetting": "การตั้งค่าความปลอดภัย",
            "moreSetting": "การตั้งค่าเพิ่มเติม",
            "locationRobot": "ระบุตำแหน่งหุ่นยนต์ดูดฝุ่น-ถูพื้นของฉัน",
            "timeZone": "เขตเวลาของหุ่นยนต์ดูดฝุ่น-ถูพื้น",
            "volume": "ตั้งค่าระดับเสียง",
            "disturbTime": "โหมด DND",
            "noTiming": "ไม่มีกำหนดการ",
            "repeat": "ทำซ้ำ",
            "once": "ครั้งเดียว",
            "everyDay": "ทุกวัน",
            "workDay": "วันธรรมดา (จ.-ศ.)",
            "weekend": "สุดสัปดาห์",
            "custom": "กำหนดเอง",
            "Sunday": "อา.",
            "Monday": "จ.",
            "Tuesday": "อ.",
            "Wednesday": "พ.",
            "Thursday": "พฤ.",
            "Friday": "ศ.",
            "Saturday": "ส.",
            "startTime": "เวลาที่เริ่ม",
            "sure": "ตกลง",
            "cancle": "ยกเลิก",
            "heap": "ตัวกรอง",
            "heapDesc": "แผ่นกรองนี้ผลิตด้วยเส้นใยโพลิเมอร์ป้องกันการรั่วจากถังเก็บ เมื่อเวลาผ่านไป การอุดตันจะทำให้ประสิทธิภาพลดลง เราจึงแนะนำให้เปลี่ยนแผ่นกรองทุกช่วงเวลาใช้งาน {time} ชั่วโมง หรือน้อยกว่า",
            "slidBrush": "แปรงด้านข้าง",
            "slidBrushDesc": "แปรงด้านข้างทำความสะอาดคราบสกปรกและฝุ่นผงโดยตรงจากมุมไปถึงแปรงหลัก เมื่อเวลาผ่านไป แปรงจะมีการสึกหรอ ทำให้มีประสิทธิภาพลดลง เราจึงแนะนำให้เปลี่ยนแผ่นกรองทุกช่วงเวลาใช้งาน {time} ชั่วโมง หรือน้อยกว่า",
            "rollingBrush": "แปรงหลัก",
            "rollingBrushDesc": "แปรงหลักทำความสะอาดคราบสกปรกและฝุ่นผงโดยตรง แล้วส่งเข้าไปยังถังเก็บฝุ่นของหุ่นยนต์ดูดฝุ่น-ถูพื้น เมื่อเวลาผ่านไป แปรงจะเกิดการสึกหรอ ทำให้มีประสิทธิภาพลดลง เราจึงแนะนำให้เปลี่ยนแผ่นกรองทุกช่วงเวลาใช้งาน {time} ชั่วโมง หรือน้อยกว่า",
            "brushExpireDesc": "เปลี่ยนในเวลา {time} ชั่วโมง",
            "buy": "จัดซื้อตอนนี้",
            "timezoneTip1": "คุณสามารถตั้งค่าหุ่นยนต์ดูดฝุ่น-ถูพื้นให้เหมือนกับเวลาของโทรศัพท์ของคุณ เพื่อให้อุปกรณ์ทั้งสองอยู่ในเขตเวลาเดียวกัน",
            "timezoneTip2": "* หากการตั้งค่าเขตเวลาของหุ่นยนต์ดูดฝุ่น-ถูพื้นไม่ถูกต้อง กำหนดเวลาทำความสะอาด และโหมด DND อาจจะทำงานไม่ตรงตามความคาดหมาย",
            "syncTimeZone": "ตั้งค่าให้พร้อมกันตอนนี้",
            "volumeTip": "ระดับเสียงการแจ้งเตือนของหุ่นยนต์ดูดฝุ่น-ถูพื้นสามารถปรับได้โดยการเลื่อนปุ่มขึ้นลง กดปุ่มทดลองเพื่อตรวจสอบการใช้งาน",
            "listen": "ฟัง",
            "nodistrubTip": "เมื่อมีการตั้งค่าไว้ หุ่นยนต์ดูดฝุ่น-ถูพื้นจะไม่ทำความสะอาดระหว่างช่วงเวลาที่กำหนด อย่างไรก็ตาม การทำความสะอาดตามเวลาที่กำหนดจะยังคงทำงานในช่วงเวลา DND",
            "endTime": "เวลาสิ้นสุด",
            "remain": "เวลาคงเหลือ",
            "remainDay": "ระยะเวลาการใช้งานคงเหลือ ประมาณ {hour} ชั่วโมง",
            "materialReset": "กลับสู่ค่าเริ่มต้น {name}",
            "resetHeapTitle": "ตั้งค่าแผ่นกรองกลับสู่ค่าเริ่มต้น",
            "resetHeapMessage": "ทำการเปลี่ยนแผ่นกรองใหม่แล้วหรือยัง",
            "resetRollingBrushTitle": "ตั้งค่าแปรงหลักกลับสู่ค่าเริ่มต้น",
            "resetRollingBrushMessage": "ทำการเปลี่ยนแปรงหลักใหม่แล้วหรือยัง",
            "resetSlidBrushTitle": "ตั้งค่าแปรงด้านข้างกลับสู่ค่าเริ่มต้น",
            "resetSlidBrushMessage": "ทำการเปลี่ยนแปรงด้านข้างใหม่แล้วหรือยัง",
            "deveiceName": "ชื่ออุปกรณ์",
            "deviceShare": "กำลังแชร์อุปกรณ์",
            "locationManager": "การจัดการตำแหน่งที่ตั้ง",
            "otaCheck": "อัปเดตเฟิร์มแวร์",
            "deleteDevice": "ลบอุปกรณ์",
            "addDesktop": "เพิ่มทางลัดหน้าโฮม",
            "feedback": "คำติชม",
            "useTerms": "ข้อมูลตามกฎหมาย",
            "loading": "กำลังโหลดข้อมูล…",
            "pause": "หยุดชั่วคราว",
            "timingStart": "เปิดใช้งาน",
            "selectArea": "เลือกพื้นที่",
            "selectAreaDesc": "กำหนดการทำความสะอาดจะไม่มีผลหากแผนที่เปลี่ยนไป",
            "confirm": "ตกลง",
            "autoClean": "ทำความสะอาดทั้งหมด",
            "deleteMsg": "ลบค่ากำหนดการนี้",
            "upgradeErr1": "ไม่สามารถดาวน์โหลดเฟิร์มแวร์ได้",
            "upgradeErr5": "ไม่สามารถอัปเดตเฟิร์มแวร์ได้",
            "upgradeErr7": "ไม่สามารถอัปเดตได้เมื่อระดับแบตเตอร์รี่ต่ำเกินไป",
            "upgradeErr8": "หุ่นยนต์ดูดฝุ่น-ถูพื้นอัปเดตไม่ได้หากไม่อยู่ระหว่างการชาร์จ",
            "networkTimeout": "คำขอหมดเวลา",
            "remoteTips": "หุ่นยนต์ดูดฝุ่น-ถูพื้นและโทรศัพท์ไม่มีการเชื่อมต่อในเครือข่ายไวไฟเดียวกัน กรุณาเชื่อมต่อภายในเครือข่ายเดียวกัน เพื่อใช้งานฟังก์ชันการควบคุมระยะไกล",
            "remoteTip2": "ตรวจสอบเฟิร์มแวร์และสถานะเครือข่าย",
            "areaEditTip1": "เราขอแนะนำให้ปรับพื้นที่ตามแผนผังบ้านที่แท้จริง",
            "areaEditTip2": "กรุณาเลือกพื้นที่ติดกันสองจุดเพื่อรวมกัน",
            "areaEditTip3": "กรุณาเลือกพื้นที่ซึ่งคุณต้องการเปลี่ยนชื่อ",
            "areaEditTip4": "กรุณาเลือกพื้นที่เดียวเพื่อทำการเปลี่ยนชื่อ",
            "areaNames": ["ชั้นล่าง", "ห้องใต้หลังคา", "ห้องสื่อบันเทิง", "ห้องอาหาร", "ระเบียง", "ห้องกิจกรรม", "ห้องนั่งเล่น", "ห้องนอน", "ห้องน้ำ", "ห้องครัว"],
            "defaultArea": "ห้องตามค่าเริ่มต้น",
            "addArea": "เพิ่ม",
            "areaTipTitle": "กรุณาทำการแยกส่วนอัตโนมัติก่อนการใช้งาน",
            "areaTipMessage": "การแยกส่วนอัตโนมัติ คือ การที่หุ่นยนต์ดูดฝุ่น-ถูพื้นเริ่มทำงานจากแท่นชาร์จ หลังจากทำความสะอาดแล้วกลับไปชาร์จโดยอัตโนมัติอีกครั้งอย่างสมบูรณ์ แผนที่จะมีการบันทึกและแยกเป็นส่วนแต่ละพื้นที่โดยอัตโนมัติ",
            "areaTipButton": "ตกลง",
            "use": "ใช้",
            "used": "ปัจจุบัน",
            "netErr": "ข้อผิดพลาดเกี่ยวกับเครือข่าย",
            "voiceDownloadErr": "ไม่สามารถดาวน์โหลดชุดเสียงได้",
            "voiceTip": "กำลังดาวน์โหลดชุดเสียง โปรดลองอีกครั้งในภายหลัง…",
            "warnInfoTitle": "รายละเอียดข้อผิดพลาด",
            "totalTime": "เวลารวมทั้งหมด",
            "totalArea": "พื้นที่รวมทั้งหมด",
            "totalTimes": "จำนวนครั้งทั้งหมด",
            "spotTips": "ทำความสะอาดสูงสุด 1.5 ม. × 1.5 ม. ภายในพื้นที่เดียวกัน",
            "timingNumTip": "รายการทำความสะอาดระบุถึงจำนวนสูงสุดแล้ว ไม่สามารถเพิ่มกำหนดเวลาได้อีก",
            "resetFail": "ไม่สามารถกลับสู่ค่าเริ่มต้นได้",
            "syncSuccess": "ตั้งค่าให้พร้อมกันสำเร็จแล้ว",
            "cleanTip": "สิ้นสุดการทำความสะอาดตอนนี้ และกลับไปสู่แท่นเพื่อทำการชาร์จใช่หรือไม่",
            "licenseTitle": "ข้อตกลงผู้ใช้",
            "policyTitle": "นโยบายความเป็นส่วนตัว",
            "removeWaterBoxTitle": "ถอดแผ่นถูพื้น",
            "removeWaterBoxMessage": "เพื่อเริ่มชาร์จแบตเตอรี่ กรุณาถอดแผ่นถูพื้นออก",
            "keepSweeperTitle": "กลับไปทำความสะอาดต่อ",
            "keepSweeperMessage": "หุ่นยนต์ดูดฝุ่น-ถูพื้นจะกลับไปทำความสะอาดส่วนที่ยังไม่เสร็จเมื่อชาร์จแบตเตอรี่ถึง 80%",
            "emptyLog": "ไม่มีประวัติการทำความสะอาด",
            "disturbTip": "ไม่สามารถระบุเป็นเวลาเดียวกับเวลาเริ่มใช้งานได้ กรุณาตั้งค่าอีกครั้ง",
            "otatitle": "ตรวจสอบหาการอัปเดตเฟิร์มแวร์",
            "otaChecking": "กำลังตรวจสอบ…",
            "currentVersion": "เวอร์ชั่นปัจจุบัน",
            "latestVersion": "เวอร์ชั่นล่าสุด",
            "isLatestVersion": "เวอร์ชั่นปัจจุบันคือเวอร์ชั่นล่าสุด",
            "back": "กลับไป",
            "checkVersionFailed": "ไม่สามารถตรวจสอบหาการอัปเดตเฟิร์มแวร์ได้",
            "retry": "ลองอีกครั้ง",
            "updateNow": "อัปเดตตอนนี้",
            "updateTip": "วางหุ่นยนต์ดูดฝุ่น-ถูพื้นที่แท่นชาร์จก่อนทำการอัพเดท และตรวจสอบให้แน่ใจว่าระดับแบตเตอรี่สูงกว่า 15%",
            "upgradeErr": "ไม่สามารถอัปเดตได้",
            "updating": "กำลังอัปเดต…",
            "updateTip2": "กำลังทำการอัปเดต อย่าปิดเครื่องหรือใช้งานหุ่นยนต์ดูดฝุ่น-ถูพื้นก่อนการอัปเดตเสร็จสมบูรณ์",
            "installing": "กำลังติดตั้งอัปเดต...",
            "installtip": "กระบวนการติดตั้งจำเป็นต้องเริ่มการทำงานของหุ่นยนต์ดูดฝุ่น-ถูพื้นใหม่ อาจใช้เวลานาน กรุณารอสักครู่",
            "updatesuccess": "อัปเดตเรียบร้อยแล้ว",
            "warnInfo": {
                "1": {
                    "title": "ล้อถูกระงับการใช้งานชั่วคราว",
                    "desc": "กรุณาเลื่อนตำแหน่งหุ่นยนต์ดูดฝุ่น-ถูพื้น แล้วเริ่มอีกครั้ง",
                    "warninfo": "ล้อถูกระงับการใช้งานชั่วคราว กรุณาเลื่อนตำแหน่งหุ่นยนต์ดูดฝุ่น-ถูพื้น แล้วเริ่มอีกครั้ง"
                },
                "2": {
                    "title": "เซนเซอร์ตรวจจับสิ่งกีดขวางมีข้อผิดพลาด",
                    "desc": "กรุณาเช็ดเซนเซอร์และเริ่มทำความสะอาดในพื้นที่ซึ่งไม่มีสิ่งกีดขวาง",
                    "warninfo": "ล้อของหุ่นยนต์ดูดฝุ่น-ถูพื้นระงับการใช้งานชั่วคราว โปรดย้ายไปตำแหน่งอื่น เมื่อเซนเซอร์ตรวจจับสิ่งกีดขวางสกปรกเกินไป มักจะทำให้เกิดข้อผิดพลาดนี้ กรุณาทำความสะอาดเซนเซอร์ตรวจจับสิ่งกีดขวาง แล้วลองอีกครั้ง"
                },
                "3": {
                    "title": "เซนเซอร์การปะทะมีการติดขัด",
                    "desc": "กรุณาทำความสะอาดแล้วเคาะเซนเซอร์การปะทะเบาๆ",
                    "warninfo": "เมื่อส่วนกันชนเกิดการติดขัด ลองเคาะเบาๆหลายๆครั้ง เพื่อให้วัตถุปนเปื้อนหลุดออก หากไม่มีการติดขัด ลองย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปตำแหน่งอื่น แล้วเริ่มอีกครั้ง"
                },
                "4": {
                    "title": "เครื่องดูดฝุ่นเอียง",
                    "desc": "กรุณาย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังพื้นที่ราบแล้วเริ่มอีกครั้ง",
                    "warninfo": "กรุณาย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังพื้นที่ราบแล้วเริ่มอีกครั้ง"
                },
                "5": {
                    "title": "เซนเซอร์การปะทะมีการติดขัด",
                    "desc": "กรุณาทำความสะอาดแล้วเคาะเซนเซอร์การปะทะเบาๆ",
                    "warninfo": "เมื่อส่วนกันชนเกิดการติดขัด ลองเคาะเบาๆหลายๆครั้ง เพื่อให้วัตถุปนเปื้อนหลุดออก หากไม่มีการติดขัด ลองย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปตำแหน่งอื่น แล้วเริ่มอีกครั้ง"
                },
                "6": {
                    "title": "ล้อถูกระงับการใช้งานชั่วคราว",
                    "desc": "กรุณาเลื่อนตำแหน่งหุ่นยนต์ดูดฝุ่น-ถูพื้น แล้วเริ่มอีกครั้ง",
                    "warninfo": "ล้อถูกระงับการใช้งานชั่วคราว กรุณาเลื่อนตำแหน่งหุ่นยนต์ดูดฝุ่น-ถูพื้น แล้วเริ่มอีกครั้ง"
                },
                "7": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "8": {
                    "title": "ถังเก็บฝุ่นยังไม่มีการติดตั้ง",
                    "desc": "กรุณาติดตั้งถังเก็บฝุ่นและแผ่นกรอง",
                    "warninfo": "กรุณาติดตั้งทั้งถังเก็บฝุ่นและแผ่นกรองอย่างถูกต้อง หากข้อผิดพลาดนี้ยังคงอยู่ กรุณาเปลี่ยนแผ่นกรอง"
                },
                "11": {
                    "title": "แผ่นกรองอาจไม่แห้งหรือเกิดการอุดตัน",
                    "desc": "กรุณาตรวจสอบให้แน่ใจว่าแผ่นกรองแห้งหรือต้องทำความสะอาดไหม",
                    "warninfo": "หากแผ่นกรองไม่แห้ง กรุณาปล่อยให้แห้งอย่างน้อย 24 ชั่วโมง หากแผ่นกรองอุดตัน กรุณาทำความสะอาด หากปัญหายังคงอยู่ กรุณาเปลี่ยนแผ่นกรองใหม่"
                },
                "12": {
                    "title": "อาจมีวัตถุแปลกปลอมปกคลุมแปรงหลัก",
                    "desc": "กรุณาถอดแปรงหลักออก ทำความสะอาดขนแปรง และฐานแปรง",
                    "warninfo": "อาจมีวัตถุแปลกปลอมปกคลุมแปรงหลัก กรุณาถอดแปรงหลักออก ทำความสะอาดขนแปรง และฐานแปรง"
                },
                "13": {
                    "title": "อาจมีวัตถุแปลกปลอมคลุมแปรงด้านข้าง",
                    "desc": "กรุณาถอดและทำความสะอาดแปรงด้านข้าง",
                    "warninfo": "อาจมีวัตถุแปลกปลอมแปรงด้านข้าง กรุณาถอดและทำความสะอาดแปรงด้านข้าง"
                },
                "14": {
                    "title": "แผ่นกรองอาจไม่แห้งหรือเกิดการอุดตัน",
                    "desc": "กรุณาตรวจสอบให้แน่ใจว่าแผ่นกรองแห้งหรือต้องทำความสะอาดไหม",
                    "warninfo": "หากแผ่นกรองไม่แห้ง กรุณาปล่อยให้แห้งอย่างน้อย 24 ชั่วโมง หากแผ่นกรองอุดตัน กรุณาทำความสะอาด หากปัญหายังคงอยู่ กรุณาเปลี่ยนแผ่นกรองใหม่"
                },
                "15": {
                    "title": "หุ่นยนต์ดูดฝุ่น-ถูพื้นเกิดการติดขัด หรือล้ออาจจะติดวัตถุบางอย่าง",
                    "desc": "ตรวจสอบว่าล้อติดวัตถุหรือไม่ กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง",
                    "warninfo": "ล้ออาจจะติดที่วัตถุบางอย่าง กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง"
                },
                "16": {
                    "title": "หุ่นยนต์ดูดฝุ่น-ถูพื้นเกิดการติดขัด หรือล้ออาจจะติดวัตถุบางอย่าง",
                    "desc": "ตรวจสอบว่าล้อติดวัตถุหรือไม่ กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง",
                    "warninfo": "ล้ออาจจะติดที่วัตถุบางอย่าง กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง"
                },
                "17": {
                    "title": "หุ่นยนต์ดูดฝุ่น-ถูพื้นอาจจะติดขัดหรือค้าง",
                    "desc": "โปรดกำจัดสิ่งกีดขวางโดยรอบ",
                    "warninfo": "หุ่นยนต์ดูดฝุ่น-ถูพื้นอาจจะติดขัดหรือค้าง โปรดกำจัดสิ่งกีดขวางโดยรอบ"
                },
                "18": {
                    "title": "หุ่นยนต์ดูดฝุ่น-ถูพื้นอาจจะติดขัดหรือค้าง",
                    "desc": "โปรดกำจัดสิ่งกีดขวางโดยรอบ",
                    "warninfo": "หุ่นยนต์ดูดฝุ่น-ถูพื้นอาจจะติดขัดหรือค้าง โปรดกำจัดสิ่งกีดขวางโดยรอบ"
                },
                "20": {
                    "title": "แบตเตอรี่ต่ำ",
                    "desc": "ระดับแบตเตอรี่ต่ำเกินไป กรุณาชาร์จ",
                    "warninfo": ""
                },
                "21": {
                    "title": "การชาร์จมีความผิดพลาด",
                    "desc": "การชาร์จมีความผิดพลาด กรุณาลองทำความสะอาดจุดเชื่อมต่อของการชาร์จ",
                    "warninfo": "โปรดเช็ดจุดเชื่อมต่อการชาร์จทั้งที่แท่นชาร์จและหุ่นยนต์ดูดฝุ่น-ถูพื้นด้วยผ้าแห้ง"
                },
                "23": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "24": {
                    "title": "เซนเซอร์ตรวจจับตำแหน่งด้วยภาพเกิดการผิดพลาด",
                    "desc": "กรุณาทำความสะอาดเซนเซอร์ตรวจจับตำแหน่งด้วยภาพ",
                    "warninfo": "กรุณาเช็ดเซนเซอร์ตรวจจับตำแหน่งด้วยภาพให้สะอาด แล้วเริ่มใหม่"
                },
                "25": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "29": {
                    "title": "ข้อผิดพลาดแบตเตอรี่",
                    "desc": "ข้อผิดพลาดแบตเตอรี่",
                    "warninfo": "อุณหภูมิของแบตเตอรี่สูงหรือต่ำเกินไป กรุณาคอยให้อุณหภูมิแบตเตอรี่กลับสู่ปกติอีกครั้ง"
                },
                "30": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "31": {
                    "title": "หุ่นยนต์ดูดฝุ่น-ถูพื้นเกิดการติดขัด หรือล้ออาจจะติดวัตถุบางอย่าง",
                    "desc": "ตรวจสอบว่าล้อติดวัตถุหรือไม่ กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง",
                    "warninfo": "ล้ออาจจะติดที่วัตถุบางอย่าง กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง"
                },
                "32": {
                    "title": "หุ่นยนต์ดูดฝุ่น-ถูพื้นเกิดการติดขัด หรือล้ออาจจะติดวัตถุบางอย่าง",
                    "desc": "ตรวจสอบว่าล้อติดวัตถุหรือไม่ กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง",
                    "warninfo": "ล้ออาจจะติดที่วัตถุบางอย่าง กรุณาหมุนล้อเพื่อทำความสะอาด แล้วย้ายหุ่นยนต์ดูดฝุ่น-ถูพื้นไปยังตำแหน่งอื่น แล้วเริ่มอีกครั้ง"
                },
                "33": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "34": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "35": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "36": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "37": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "38": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "39": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "40": {
                    "title": "ข้อผิดพลาดภายใน",
                    "desc": "กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น",
                    "warninfo": "พบข้อผิดพลาดภายใน ไม่สามารถใช้งานได้ กรุณาปรับระบบให้กลับไปยังค่าเริ่มต้น"
                },
                "41": {
                    "title": "พบพื้นที่สนามแม่เหล็กระดับสูง",
                    "desc": "พบพื้นที่สนามแม่เหล็กระดับสูง กรุณาอยู่ห่างจากผนังเสมือน",
                    "warninfo": "หุ่นยนต์ดูดฝุ่น-ถูพื้นอยู่ใกล้ผนังเสมือนมากเกินไปเมื่อทำการเริ่มใช้งาน กรุณาย้ายไปตำแหน่งอื่นเพื่อเริ่มใช้งาน"
                }
            },
            "slidBrushWarnTipTitle1": "แปรงด้านข้างต้องเปลี่ยนในไม่ช้า",
            "slidBrushWarnTipMsg1": "แปรงด้านข้างใกล้จะสึกหรอแล้ว กรุณาเปลี่ยนใหม่โดยเร็วที่สุด",
            "slidBrushWarnTipTitle2": "แปรงด้านข้างต้องเปลี่ยนแล้ว",
            "slidBrushWarnTipMsg2": "แปรงด้านข้างสึกหรอแล้ว กรุณาเปลี่ยนใหม่",
            "rollingBrushWarnTitle1": "แปรงหลักต้องเปลี่ยนในไม่ช้า",
            "rollingBrushWarnMsg1": "แปรงหลักใกล้จะสึกหรอแล้ว กรุณาเปลี่ยนใหม่โดยเร็วที่สุด",
            "rollingBrushWarnTitle2": "แปรงหลักต้องเปลี่ยนแล้ว",
            "rollingBrushWarnMsg2": "แปรงหลักสึกหรอแล้ว กรุณาเปลี่ยนใหม่",
            "heapWarnTitle1": "แผ่นกรองใกล้จะหมดสมรรถภาพการใช้งานแล้ว",
            "heapWarnMsg1": "แผ่นกรองใกล้จะหมดสมรรถภาพการใช้งานแล้ว กรุณาเปลี่ยนใหม่โดยเร็วที่สุด",
            "heapWarnTitle2": "แผ่นกรองใช้งานไม่ได้แล้ว",
            "heapWarnMsg2": "แผ่นกรองใช้งานไม่ได้แล้ว กรุณาเปลี่ยนใหม่",
            "updateDialogTip": "มีการอัปเดตเฟิร์มแวร์ ({version}) อัปเดตเลยตอนนี้หรือไม่",
            "logDate": "{day}/{month} {hour}:{minute}",
            "areaUnit": "ตร.ม.",
            "minute": "น."
        },
        "pt": {
            "IntelligentScene": "Cenas inteligentes",
            "cleaning": "Limpando",
            "mop": "Vaporizando",
            "customClean": "Limpeza de área",
            "cleaned": "Terminado",
            "cleantime": "Tempo de limpeza",
            "surplusPower": "Bateria",
            "charge": "Estação \nde carga",
            "chargePause": "Pausar",
            "cleanPause": "Pausar",
            "cleanStart": "Começar \nlimpeza",
            "areaClean": "Limpar área",
            "remoteClean": "Limpeza com controle remoto",
            "localClean": "Limpeza parcial",
            "chargingBtnText": "Carregar",
            "charging": "Carregar",
            "completedCharge": "Carga concluída",
            "completedChargeBtnText": "Carga \nconcluída",
            "cleanMode": "Modo limpeza",
            "modeQuiet": "Silencioso",
            "modeStandard": "Padrão",
            "modeMedium": "Média",
            "modeStrong": "Turbo",
            "cleanTiming": "Limpeza agendada",
            "cleanTimingStart": "Começa em {hour, plural,=0 {}other {# h e }}{minute} min",
            "cleanTimingEmpty": "Nenhuma tarefa de limpeza agendada",
            "areaEdit": "Alterar área",
            "robotVoice": "Alertas de voz",
            "prompt": "Notificações",
            "waiting": "Espera",
            "gocharging": "Voltando à estação para carregar",
            "areaSlect": "Áreas selecionadas: {areaNum}",
            "areaMerge": "Mesclar",
            "areaSplit": "Dividir",
            "areaRename": "Renomear",
            "spot": "Limpar ali",
            "setting": "Configurações",
            "robotSetting": "Configurações do dispositivo",
            "msgSwitch": "Notificações",
            "cleanLog": "Histórico de limpeza",
            "materialTime": "Agendamento de limpeza",
            "remoteControl": "Controle remoto",
            "productGuide": "Ajuda",
            "functionSetting": "Mais configurações",
            "generalSetting": "Configurações gerais",
            "securitySetting": "Configurações de segurança",
            "moreSetting": "Configurações adicionais",
            "locationRobot": "Localizar Aspirador",
            "timeZone": "Fuso horário do Aspirador",
            "volume": "Configurações de volume",
            "disturbTime": "Modo DND",
            "noTiming": "Não há agendamentos",
            "repeat": "Repetir",
            "once": "Uma vez",
            "everyDay": "Diariamente",
            "workDay": "Dias úteis (seg. à sexta)",
            "weekend": "Finais de semana",
            "custom": "Personalizar",
            "Sunday": "Dom",
            "Monday": "Seg.",
            "Tuesday": "Ter.",
            "Wednesday": "Qua.",
            "Thursday": "Qui.",
            "Friday": "Sex.",
            "Saturday": "Sáb.",
            "startTime": "Hora de início",
            "sure": "OK",
            "cancle": "Cancelar",
            "heap": "Filtrar",
            "heapDesc": "O filtro é feito com fibras de polímero para impedir que a poeira escape do compartimento. Com o tempo, o filtro fica obstruído, e começa a perder a eficácia. Portanto, recomendamos substituir o filtro a cada {time} horas de operação ou menos.",
            "slidBrush": "Escova lateral",
            "slidBrushDesc": "Direciona a sujeira e detritos dos cantos à escova principal. Com o tempo, ela começa a se desgastar e perder sua eficácia. Recomendamos substituir a escova lateral a cada {time} horas de operação ou menos.",
            "rollingBrush": "Escova principal",
            "rollingBrushDesc": "Direciona a sujeira e detritos para o compartimento de pó do Aspirador. Com o tempo, ela começa a se desgastar e perder sua eficácia. Recomendamos substituir a escova principal a cada {time} horas de operação ou menos.",
            "brushExpireDesc": "Substitua daqui a {time} horas",
            "buy": "Comprar agora",
            "timezoneTip1": "Você pode sincronizar o fuso horário do seu telefone com o Aspirador para garantir que os dois estejam no mesmo fuso horário.",
            "timezoneTip2": "* Se o fuso horário do Aspirador estiver incorreto, as limpezas agendadas e o Modo DND podem não funcionar como esperado.",
            "syncTimeZone": "Sincronizar agora",
            "volumeTip": "O volume do alerta de voz do Aspirador pode ser ajustado ao apertar os botões para cima ou para baixo. Toque no botão de volume de teste e veja.",
            "listen": "Ouvir",
            "nodistrubTip": "Quando a função está ativada, o Aspirador não continuará automaticamente com as tarefas de limpeza durante o período especificado. No entanto, as limpezas agendadas ainda serão realizadas durante o período em que o Modo DND estiver ativado.",
            "endTime": "Hora de término",
            "remain": "Restante",
            "remainDay": "Vida útil restante: cerca de {hour} horas",
            "materialReset": "Redefinir {name}",
            "resetHeapTitle": "Redefinir tempo de uso do filtro",
            "resetHeapMessage": "O filtro foi substituído por um novo?",
            "resetRollingBrushTitle": "Redefinir o tempo de uso da escova principal",
            "resetRollingBrushMessage": "A escova principal foi substituída por uma nova?",
            "resetSlidBrushTitle": "Redefinir o tempo de uso da escova lateral",
            "resetSlidBrushMessage": "A escova lateral foi substituída por uma nova?",
            "deveiceName": "Nome do dispositivo",
            "deviceShare": "Compartilhamento de dispositivo",
            "locationManager": "Gerenciamento de localização",
            "otaCheck": "Atualização de firmware",
            "deleteDevice": "Excluir dispositivo",
            "addDesktop": "Adicionar atalho da tela de início",
            "feedback": "Feedback",
            "useTerms": "Informações jurídicas",
            "loading": "Carregando dados...",
            "pause": "Pausar",
            "timingStart": "Habilitar",
            "selectArea": "Selecionar área",
            "selectAreaDesc": "A limpeza agendada será invalidada quando o mapa for alterado.",
            "confirm": "OK",
            "autoClean": "Limpeza terminada",
            "deleteMsg": "Excluir este agendamento",
            "upgradeErr1": "Não foi possível baixar o firmware",
            "upgradeErr5": "Não foi possível atualizar firmware",
            "upgradeErr7": "Não é possível atualizar se a bateria estiver muito baixa",
            "upgradeErr8": "O Aspirador não pode ser atualizado se não estiver carregando",
            "networkTimeout": "Limite de tempo atingido para a solicitação",
            "remoteTips": "O Aspirador e o telefone não estão conectados à mesma rede Wi-Fi. Conecte ambos à mesma rede para usar a função de controle remoto.",
            "remoteTip2": "Verifique o firmware e o status da rede",
            "areaEditTip1": "Recomenda-se ajustar as áreas de acordo com os cômodos da casa.",
            "areaEditTip2": "Selecione duas áreas adjacentes para combinar",
            "areaEditTip3": "Selecione a área que deseja renomear",
            "areaEditTip4": "Selecione uma área para renomear",
            "areaNames": ["Porão", "Sótão", "Sala de mídia", "Sala de jantar", "Varanda", "Sala de lazer", "Sala de estar", "Quarto", "Banheiro", "Cozinha"],
            "defaultArea": "Cômodo padrão",
            "addArea": "Adicionar",
            "areaTipTitle": "Por favor, execute a divisão automática antes de usar",
            "areaTipMessage": "Divisão automática: o Aspirador começa na estação de carregamento. Depois de limpar o cômodo, quando a recarga for concluída com sucesso, o mapa será salvo automaticamente e divido em áreas.",
            "areaTipButton": "OK",
            "use": "Usar",
            "used": "Atual",
            "netErr": "Erro de rede",
            "voiceDownloadErr": "Não foi possível baixar o pacote de voz",
            "voiceTip": "Baixando o pacote de voz. Tente novamente mais tarde.",
            "warnInfoTitle": "Detalhes do erro",
            "totalTime": "Tempo total",
            "totalArea": "Área total",
            "totalTimes": "Total de vezes",
            "spotTips": "Limpar área de 1,5 m × 1,5 m em torno da coordenada",
            "timingNumTip": "O número máximo de limpezas agendadas foi atingido. Impossível adicionar limpeza agendada.",
            "resetFail": "Não foi possível redefinir",
            "syncSuccess": "Sincronia bem-sucedida",
            "cleanTip": "Terminar a limpeza atual e voltar para à estação de carregamento para carregar?",
            "licenseTitle": "Acordo do Usuário",
            "policyTitle": "Política de Privacidade",
            "removeWaterBoxTitle": "Remova a tábua do aspirador",
            "removeWaterBoxMessage": "Para começar a carregar, remova a tábua do aspirador",
            "keepSweeperTitle": "Retomar a limpeza",
            "keepSweeperMessage": "O Aspirador a vapor continuará automaticamente com as tarefas de limpeza não concluídas após carregar a bateria em 80%.",
            "emptyLog": "O histórico está vazio",
            "disturbTip": "O horário não pode ser o mesmo da hora de início. Defina-o novamente.",
            "otatitle": "Verificar se há atualizações de firmware",
            "otaChecking": "Verificando...",
            "currentVersion": "Versão atual",
            "latestVersion": "Última versão",
            "isLatestVersion": "A versão atual é a mais recente",
            "back": "Voltar",
            "checkVersionFailed": "Não foi possível verificar se há atualizações de firmware",
            "retry": "Tentar de novo",
            "updateNow": "Atualizar agora",
            "updateTip": "Coloque o Aspirador na estação de carga antes de atualizar. Verifique se o nível da bateria está em mais de 15% antes de prosseguir.",
            "upgradeErr": "Não foi possível atualizar",
            "updating": "Atualizando…",
            "updateTip2": "Atualizando. Não desligue ou use o Aspirador antes que a atualização seja concluída.",
            "installing": "Instalando atualização...",
            "installtip": "É necessário reiniciar o Aspirador antes de continuar com o processo de instalação. Isso pode demorar um pouco. Por favor, seja paciente.",
            "updatesuccess": "Atualização concluída",
            "warnInfo": {
                "1": {
                    "title": "Rodas suspensas",
                    "desc": "Reposicione o Aspirador e comece de novo.",
                    "warninfo": "As rodas estão suspensas. Reposicione o Aspirador e comece de novo."
                },
                "2": {
                    "title": "Erro no sensor de obstáculo",
                    "desc": "Limpe o sensor de obstáculos e comece a limpeza longe de qualquer obstáculo.",
                    "warninfo": "As rodas do Aspirador estão suspensas. Tente movê-lo para um novo local. Quando o sensor de obstáculos fica muito sujo, esse tipo de erro também pode ocorrer. Limpe o sensor de obstáculo e tente novamente."
                },
                "3": {
                    "title": "Sensor de colisão obstruído",
                    "desc": "Limpe o sensor de colisão e toque nele suavemente.",
                    "warninfo": "Se o amortecedor estiver obstruído, tente tocar várias vezes nele para limpar os objetos presos. Se o amortecedor não estiver obstruído, tente mover o Aspirador para um novo local e comece de novo."
                },
                "4": {
                    "title": "Aspirador inclinado",
                    "desc": "Mova o Aspirador para uma superfície nivelada e comece de novo.",
                    "warninfo": "Mova o Aspirador para uma superfície nivelada e comece de novo."
                },
                "5": {
                    "title": "Sensor de colisão obstruído",
                    "desc": "Limpe o sensor de colisão e toque nele suavemente.",
                    "warninfo": "Se o amortecedor estiver obstruído, tente tocar várias vezes nele para limpar os objetos presos. Se o amortecedor não estiver obstruído, tente mover o Aspirador para um novo local e comece de novo."
                },
                "6": {
                    "title": "Rodas suspensas",
                    "desc": "Reposicione o Aspirador e comece de novo.",
                    "warninfo": "As rodas estão suspensas. Reposicione o Aspirador e comece de novo."
                },
                "7": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "8": {
                    "title": "O compartimento de poeira não foi instalado.",
                    "desc": "Instale o compartimento de poeira e o filtro.",
                    "warninfo": "Instale corretamente o compartimento de poeira e o filtro. Se o erro ainda ocorrer, tente substituir o filtro."
                },
                "11": {
                    "title": "O filtro pode não estar seco ou pode estar obstruído.",
                    "desc": "Verifique se o filtro secou ou precisa ser limpo.",
                    "warninfo": "Se o filtro não estiver seco, deixe-o secar por pelo menos 24 horas. Quando o filtro estiver obstruído, limpe-o. Caso não consiga resolver o problema, substitua o filtro."
                },
                "12": {
                    "title": "Alguns objetos podem estar enrolados na escova principal.",
                    "desc": "Remova-a e limpe suas cerdas e rolamentos.",
                    "warninfo": "Alguns objetos podem ser agarrados em torno da escova principal. Remova a escova principal para limpar as cerdas e os rolamentos."
                },
                "13": {
                    "title": "Alguns objetos podem estar agarrados na escova lateral.",
                    "desc": "Se isso ocorrer, remova e limpe a escova lateral.",
                    "warninfo": "Alguns objetos podem estar enrolados na escova lateral. Remova-a para limpar as cerdas."
                },
                "14": {
                    "title": "O filtro pode não estar seco ou pode estar obstruído.",
                    "desc": "Verifique se o filtro secou ou precisa ser limpo.",
                    "warninfo": "Se o filtro não estiver seco, deixe-o secar por pelo menos 24 horas. Quando o filtro estiver obstruído, limpe-o. Caso não consiga resolver o problema, substitua o filtro."
                },
                "15": {
                    "title": "O Aspirador está preso ou suas rodas podem estar bloqueadas por um objeto.",
                    "desc": "Verifique se as rodas estão bloqueadas por um objeto. Em seguida, gire-as para limpá-las e leve o Aspirador a um novo local antes de continuar com o processo.",
                    "warninfo": "As rodas podem estar bloqueadas por um objeto. Gire-as para limpá-las e tente novamente."
                },
                "16": {
                    "title": "O Aspirador está preso ou suas rodas podem estar bloqueadas por um objeto.",
                    "desc": "Verifique se as rodas estão bloqueadas por um objeto. Em seguida, gire-as para limpá-las e leve o Aspirador a um novo local antes de continuar com o processo.",
                    "warninfo": "As rodas podem estar bloqueadas por um objeto. Gire-as para limpá-las e tente novamente."
                },
                "17": {
                    "title": "O Aspirador pode estar bloqueado ou preso.",
                    "desc": "Por favor, limpe os obstáculos ao redor",
                    "warninfo": "O Aspirador pode estar bloqueado ou preso. Limpe os obstáculos ao redor."
                },
                "18": {
                    "title": "O Aspirador pode estar bloqueado ou preso.",
                    "desc": "Por favor, limpe os obstáculos ao redor",
                    "warninfo": "O Aspirador pode estar bloqueado ou preso. Limpe os obstáculos ao redor."
                },
                "20": {
                    "title": "Bateria fraca",
                    "desc": "O nível da bateria está muito baixo. Recarregue a bateria.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Erro de carregamento",
                    "desc": "Erro de carregamento. Tente limpar os contados da peça da estação de carregamento.",
                    "warninfo": "Limpe os contatos de carga no encaixe e no Aspirador com um pano seco."
                },
                "23": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "24": {
                    "title": "Erro do sensor de posicionamento visual",
                    "desc": "Limpe o sensor de posicionamento visual.",
                    "warninfo": "Limpe o sensor de posicionamento visual limpo e reinicie o processo."
                },
                "25": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "29": {
                    "title": "Erro da bateria",
                    "desc": "Erro da bateria",
                    "warninfo": "A temperatura da bateria está muito alta ou muito baixa. Aguarde até que a temperatura da bateria esteja normal novamente."
                },
                "30": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "31": {
                    "title": "O Aspirador está preso ou suas rodas podem estar bloqueadas por um objeto.",
                    "desc": "Verifique se as rodas estão bloqueadas por um objeto. Em seguida, gire-as para limpá-las e leve o Aspirador a um novo local antes de continuar com o processo.",
                    "warninfo": "As rodas podem estar bloqueadas por um objeto. Gire-as para limpá-las e tente novamente."
                },
                "32": {
                    "title": "O Aspirador está preso ou suas rodas podem estar bloqueadas por um objeto.",
                    "desc": "Verifique se as rodas estão bloqueadas por um objeto. Em seguida, gire-as para limpá-las e leve o Aspirador a um novo local antes de continuar com o processo.",
                    "warninfo": "As rodas podem estar bloqueadas por um objeto. Gire-as para limpá-las e tente novamente."
                },
                "33": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "34": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "35": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "36": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "37": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "38": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "39": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "40": {
                    "title": "Erro interno",
                    "desc": "Por favor, tente reiniciar o sistema.",
                    "warninfo": "Erro interno detectado. Não é impossível continuar com a operação. Tente reiniciar o sistema."
                },
                "41": {
                    "title": "Forte campo magnético detectado",
                    "desc": "Foi detectado um forte campo magnético. Por favor, fique longe da parede virtual.",
                    "warninfo": "O Aspirador está muito próximo da parede virtual na inicialização. Mova-o para outro local para iniciar."
                }
            },
            "slidBrushWarnTipTitle1": "A escova lateral precisa ser trocada em breve",
            "slidBrushWarnTipMsg1": "A escova lateral está quase gasta. Substitua-a o mais rápido possível.",
            "slidBrushWarnTipTitle2": "A escova lateral precisa ser substituída.",
            "slidBrushWarnTipMsg2": "A escova lateral está gasta. Por favor, substitua-a.",
            "rollingBrushWarnTitle1": "A escova principal precisa ser substituída em breve.",
            "rollingBrushWarnMsg1": "A escova principal está quase completamente desgastada. Por favor, substitua-a o mais rápido possível.",
            "rollingBrushWarnTitle2": "Escova principal precisa ser substituída.",
            "rollingBrushWarnMsg2": "A escova principal está desgastada. Por favor, substitua-a.",
            "heapWarnTitle1": "O filtro está quase vencido.",
            "heapWarnMsg1": "O filtro está quase vencido. Por favor, substitua-o o mais rápido possível.",
            "heapWarnTitle2": "O filtro está vencido.",
            "heapWarnMsg2": "O filtro está vencido. Por favor, substitua-o.",
            "updateDialogTip": "Atualização de firmware ({version}) disponível. Atualizar agora?",
            "logDate": "{day}/{month} {hour}:{minute}"
        },
        "zh-tw": {
            "IntelligentScene": "智慧場景",
            "cleaning": "正在清掃",
            "mop": "拖地",
            "customClean": "劃區清掃",
            "cleaned": "已清掃",
            "cleantime": "清掃時間",
            "surplusPower": "電量",
            "charge": "回充",
            "chargePause": "暫停回充",
            "cleanPause": "暫停清掃",
            "cleanStart": "開始清掃",
            "areaClean": "區域清掃",
            "remoteClean": "遙控清掃",
            "localClean": "局部清掃",
            "chargingBtnText": "正在充電",
            "charging": "正在充電",
            "completedCharge": "充電完成",
            "completedChargeBtnText": "充電完成",
            "cleanMode": "清掃模式",
            "modeQuiet": "安靜",
            "modeStandard": "標準",
            "modeMedium": "中檔",
            "modeStrong": "強力",
            "cleanTiming": "定時清掃",
            "cleanTimingStart": "{hour, plural,=0 { }other {#小時}}{minute}分鐘後開始",
            "cleanTimingEmpty": "暫無定時任務",
            "areaEdit": "區域編輯",
            "robotVoice": "機器人語音",
            "prompt": "提示",
            "waiting": "待機",
            "gocharging": "回充中",
            "areaSlect": "已選擇 {areaNum} 個區域",
            "areaMerge": "合併",
            "areaSplit": "分割",
            "areaRename": "重命名",
            "spot": "指哪掃哪",
            "setting": "設定",
            "robotSetting": "裝置設定",
            "msgSwitch": "訊息提醒開關",
            "cleanLog": "清掃記錄",
            "materialTime": "耗材計時",
            "remoteControl": "遙控器",
            "productGuide": "使用說明",
            "functionSetting": "功能設定",
            "generalSetting": "通用設定",
            "securitySetting": "安全設定",
            "moreSetting": "更多設定",
            "locationRobot": "定位我的裝置",
            "timeZone": "裝置所在時區",
            "volume": "音量設定",
            "disturbTime": "勿擾模式",
            "noTiming": "定時為空",
            "repeat": "重複",
            "once": "執行一次",
            "everyDay": "每天",
            "workDay": "工作日（週一到週五）",
            "weekend": "週末",
            "custom": "自訂",
            "Sunday": "週日",
            "Monday": "週一",
            "Tuesday": "週二",
            "Wednesday": "週三",
            "Thursday": "週四",
            "Friday": "週五",
            "Saturday": "週六",
            "startTime": "開啟時間",
            "sure": "確認",
            "cancle": "取消",
            "heap": "濾網",
            "heapDesc": "濾網由高分子纖維組成，用於防止吸入塵盒的灰塵逸出。隨工作時間的增長，會緩慢堵塞失效。建議工作 {time} 小時或更短時間更換一次。",
            "slidBrush": "邊刷",
            "slidBrushDesc": "邊刷用於清掃牆角垃圾，將垃圾送入主刷。隨工作時間的增長會有磨損，影響清掃效果。建議工作 {time} 小時或更短時間更換一次。",
            "rollingBrush": "主刷",
            "rollingBrushDesc": "主刷是主要清掃部件，它以高速旋轉卷起垃圾進入塵盒。隨工作時間的增長主刷會有磨損。建議工作 {time} 小時或更短時間更換一次。",
            "brushExpireDesc": "預計剩餘 {time} 小時更換",
            "buy": "立即購買",
            "timezoneTip1": "可以將手機所在時區同步到裝置，請確保手機和裝置處在同一時區",
            "timezoneTip2": "*裝置時區不準確，可能造成定時清掃和勿擾模式時間紊亂",
            "syncTimeZone": "現在同步",
            "volumeTip": "可拖動調節裝置語音音量大小，可點擊試聽按鈕試聽",
            "listen": "試聽",
            "nodistrubTip": "開啟後，設定時間內不會自動續掃。勿擾時間段內會執行已設定的預約工作。",
            "endTime": "結束時間",
            "remain": "剩餘",
            "remainDay": "預計還可使用 {hour} 小時",
            "materialReset": "{name}復位",
            "resetHeapTitle": "重設濾芯使用時間",
            "resetHeapMessage": "已更換新的濾芯?",
            "resetRollingBrushTitle": "重設主刷使用時間",
            "resetRollingBrushMessage": "已更換新的主刷?",
            "resetSlidBrushTitle": "重設邊刷使用時間",
            "resetSlidBrushMessage": "已更換新的邊刷?",
            "deveiceName": "裝置名稱",
            "deviceShare": "裝置共用",
            "locationManager": "位置管理",
            "otaCheck": "韌體升級",
            "deleteDevice": "刪除裝置",
            "addDesktop": "新增桌面快捷方式",
            "feedback": "反饋問題",
            "useTerms": "法律資訊",
            "loading": "資料載入中...",
            "pause": "暫停",
            "timingStart": "啟用",
            "selectArea": "選擇區域",
            "selectAreaDesc": "若地圖發生變化，則該定時無效",
            "confirm": "確認",
            "autoClean": "全域清掃",
            "deleteMsg": "刪除此項定時設定",
            "upgradeErr1": "韌體下載失敗",
            "upgradeErr5": "韌體更新失敗",
            "upgradeErr7": "電量過低，無法升級",
            "upgradeErr8": "主機未在充電狀態，無法升級",
            "networkTimeout": "請求逾時",
            "remoteTips": "裝置與手機不在同一區域網路內，請連接在同一區域網路後使用遙控器",
            "remoteTip2": "檢查韌體和網路狀況",
            "areaEditTip1": "建議按照真實房屋型態調整區域",
            "areaEditTip2": "請選擇兩個相鄰可達區域進行合併",
            "areaEditTip3": "請選擇需要命名的區域",
            "areaEditTip4": "請選擇單個區域進行重命名",
            "areaNames": ["地下室", "閣樓", "媒體房", "餐廳", "陽台", "活動室", "客廳", "臥室", "衛生間", "廚房"],
            "defaultArea": "預設房間",
            "addArea": "新增",
            "areaTipTitle": "請自動分區後使用",
            "areaTipMessage": "如何自動分區: 裝置從充電座出發，清掃完成並自動回充成功後，將自動儲存地圖並分區",
            "areaTipButton": "確定",
            "use": "使用",
            "used": "使用中",
            "netErr": "網路異常",
            "voiceDownloadErr": "語音包下載失敗",
            "voiceTip": "目前有語音包正在下載中，請稍後再試",
            "warnInfoTitle": "故障詳情",
            "totalTime": "累計時長",
            "totalArea": "累計面積",
            "totalTimes": "累計次數",
            "spotTips": "清掃座標點周邊 1.5×1.5 米的方形區域",
            "timingNumTip": "預約任務已到達上限，無法新增任務",
            "resetFail": "重設失敗",
            "syncSuccess": "同步成功",
            "cleanTip": "結束目前清掃，開始回充?",
            "licenseTitle": "使用者合約",
            "policyTitle": "隱私權政策",
            "removeWaterBoxTitle": "取下抹布支架",
            "removeWaterBoxMessage": "開始充電，請取下抹布支架",
            "keepSweeperTitle": "斷點續掃",
            "keepSweeperMessage": "主機將在充電達到 80% 以後自動開始未完成的清掃工作",
            "emptyLog": "記錄為空",
            "disturbTip": "設定的起始時間相同，請重新設定",
            "otatitle": "檢查韌體更新",
            "otaChecking": "正在偵測...",
            "currentVersion": "目前版本",
            "latestVersion": "最新版本",
            "isLatestVersion": "目前已是最新版本",
            "back": "返回",
            "checkVersionFailed": "偵測可更新韌體失敗",
            "retry": "再試一次",
            "updateNow": "立即更新",
            "updateTip": "升級前請將裝置置於充電座，並保持電量 15% 以上",
            "upgradeErr": "升級失敗",
            "updating": "正在升級...",
            "updateTip2": "升級中，請勿斷電，等待升級完成後再使用",
            "installing": "安裝更新中...",
            "installtip": "在安裝過程中需要重啟裝置，可能耗時較長，請耐心等待",
            "updatesuccess": "更新成功",
            "warnInfo": {
                "1": {
                    "title": "輪子懸空",
                    "desc": "請將主機移動到新位置啟動",
                    "warninfo": "輪子懸空，請移到新位置啟動。"
                },
                "2": {
                    "title": "懸崖感應器異常",
                    "desc": "請擦拭懸崖感應器並遠離懸崖後啟動",
                    "warninfo": "主機懸空，請移到新位置啟動；懸崖感應器太髒也可能導致該故障，請擦拭懸崖感應器排除。"
                },
                "3": {
                    "title": "碰撞感應器被卡住",
                    "desc": "請清理並輕拍碰撞感應器",
                    "warninfo": "碰撞緩衝器被卡住，請清除異物；如無異物，請移到新位置啟動。"
                },
                "4": {
                    "title": "主機傾斜",
                    "desc": "請將主機放置到水平地面啟動。",
                    "warninfo": "請將主機放置到水平地面啟動。"
                },
                "5": {
                    "title": "碰撞感應器被卡住",
                    "desc": "請清理並輕拍碰撞感應器",
                    "warninfo": "碰撞緩衝器被卡住，請清除異物；如無異物，請移到新位置啟動。"
                },
                "6": {
                    "title": "輪子懸空",
                    "desc": "請將主機移動到新位置啟動",
                    "warninfo": "輪子懸空，請移到新位置啟動。"
                },
                "7": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "8": {
                    "title": "塵盒未裝回",
                    "desc": "請裝回塵盒及濾網",
                    "warninfo": "請裝回塵盒及濾網並確認安裝到位；若仍報錯，請嘗試更換濾網。"
                },
                "11": {
                    "title": "濾網可能未晾乾或被堵塞",
                    "desc": "請確認濾網已晾乾或清理濾網",
                    "warninfo": "濾網未乾透，請晾曬至少 24 小時；濾網可能被堵塞，請清理濾網；如無法解決，請更換濾網。"
                },
                "12": {
                    "title": "主刷可能纏繞異物",
                    "desc": "請取下主刷，清理刷毛及軸承",
                    "warninfo": "主刷可能纏繞異物，請取下主刷及軸承並清理。"
                },
                "13": {
                    "title": "邊刷可能纏繞異物",
                    "desc": "請拆卸並清理邊刷",
                    "warninfo": "邊刷可能纏繞異物，請拆卸邊刷並清理。"
                },
                "14": {
                    "title": "濾網可能未晾乾或被堵塞",
                    "desc": "請確認濾網已晾乾或清理濾網",
                    "warninfo": "濾網未乾透，請晾曬至少 24 小時；濾網可能被堵塞，請清理濾網；如無法解決，請更換濾網。"
                },
                "15": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "16": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "17": {
                    "title": "可能被卡住或者困住了",
                    "desc": "請清除主機周圍障礙物",
                    "warninfo": "主機可能被卡住或困住，請清除主機周圍障礙物。"
                },
                "18": {
                    "title": "可能被卡住或者困住了",
                    "desc": "請清除主機周圍障礙物",
                    "warninfo": "主機可能被卡住或困住，請清除主機周圍障礙物。"
                },
                "20": {
                    "title": "電量過低",
                    "desc": "電量過低，請充電",
                    "warninfo": ""
                },
                "21": {
                    "title": "充電異常",
                    "desc": "充電異常，請嘗試清理充電接觸區域",
                    "warninfo": "請用乾布擦拭主機充電觸片及充電座彈片。"
                },
                "23": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "24": {
                    "title": "視覺定位感應器異常",
                    "desc": "請清理視覺定位感應器",
                    "warninfo": "請擦拭視覺定位感應器後重新啟動。"
                },
                "25": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "29": {
                    "title": "電池異常",
                    "desc": "電池異常",
                    "warninfo": "電池溫度過高或過低，請等待電池溫度正常後再使用。"
                },
                "30": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "31": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "32": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "33": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "34": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "35": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "36": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "37": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "38": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "39": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "40": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "41": {
                    "title": "偵測到強磁場",
                    "desc": "偵測到強磁場，請遠離虛擬牆啟動",
                    "warninfo": "啟動時主機太靠近虛擬牆，請移動到新位置啟動。"
                }
            },
            "slidBrushWarnTipTitle1": "邊刷即將到期",
            "slidBrushWarnTipMsg1": "邊刷即將到期，請及時更換",
            "slidBrushWarnTipTitle2": "邊刷已到期",
            "slidBrushWarnTipMsg2": "邊刷已到期，請更換",
            "rollingBrushWarnTitle1": "主刷即將到期",
            "rollingBrushWarnMsg1": "主刷即將到期，請及時更換",
            "rollingBrushWarnTitle2": "主刷已到期",
            "rollingBrushWarnMsg2": "主刷已到期，請更換",
            "heapWarnTitle1": "濾芯即將到期",
            "heapWarnMsg1": "濾芯即將到期，請及時更換",
            "heapWarnTitle2": "濾芯已到期",
            "heapWarnMsg2": "濾芯已到期，請更換",
            "updateDialogTip": "檢測到裝置有最新韌體版本{version}，是否升級？"
        },
        "zh-hk": {
            "IntelligentScene": "智慧场景",
            "cleaning": "正在清掃",
            "mop": "拖地",
            "customClean": "劃區清掃",
            "cleaned": "已清掃",
            "cleantime": "清掃時間",
            "surplusPower": "電量",
            "charge": "回充",
            "chargePause": "暫停回充",
            "cleanPause": "暫停清掃",
            "cleanStart": "開始清掃",
            "areaClean": "區域清掃",
            "remoteClean": "遙控清掃",
            "localClean": "局部清掃",
            "chargingBtnText": "正在充電",
            "charging": "正在充電",
            "completedCharge": "充電完成",
            "completedChargeBtnText": "充電完成",
            "cleanMode": "清掃模式",
            "modeQuiet": "安靜",
            "modeStandard": "標準",
            "modeMedium": "中檔",
            "modeStrong": "強力",
            "cleanTiming": "定時清掃",
            "cleanTimingStart": "{hour, plural,=0 { }other {#小時}}{minute}分鐘後開始",
            "cleanTimingEmpty": "暫無定時任務",
            "areaEdit": "區域編輯",
            "robotVoice": "機器人語音",
            "prompt": "提示",
            "waiting": "待機",
            "gocharging": "回充中",
            "areaSlect": "已選擇 {areaNum} 個區域",
            "areaMerge": "合併",
            "areaSplit": "分割",
            "areaRename": "重命名",
            "spot": "指哪掃哪",
            "setting": "設定",
            "robotSetting": "裝置設定",
            "msgSwitch": "訊息提醒開關",
            "cleanLog": "清掃記錄",
            "materialTime": "耗材計時",
            "remoteControl": "遙控器",
            "productGuide": "使用說明",
            "functionSetting": "功能設定",
            "generalSetting": "通用設定",
            "securitySetting": "安全設定",
            "moreSetting": "更多設定",
            "locationRobot": "定位我的裝置",
            "timeZone": "裝置所在時區",
            "volume": "音量設定",
            "disturbTime": "勿擾模式",
            "noTiming": "定時為空",
            "repeat": "重複",
            "once": "執行一次",
            "everyDay": "每天",
            "workDay": "工作日（週一到週五）",
            "weekend": "週末",
            "custom": "自訂",
            "Sunday": "週日",
            "Monday": "週一",
            "Tuesday": "週二",
            "Wednesday": "週三",
            "Thursday": "週四",
            "Friday": "週五",
            "Saturday": "週六",
            "startTime": "開啟時間",
            "sure": "確認",
            "cancle": "取消",
            "heap": "濾網",
            "heapDesc": "濾網由高分子纖維組成，用於防止吸入塵盒的灰塵逸出。隨工作時間的增長，會緩慢堵塞失效。建議工作 {time} 小時或更短時間更換一次。",
            "slidBrush": "邊刷",
            "slidBrushDesc": "邊刷用於清掃牆角垃圾，將垃圾送入主刷。隨工作時間的增長會有磨損，影響清掃效果。建議工作 {time} 小時或更短時間更換一次。",
            "rollingBrush": "主刷",
            "rollingBrushDesc": "主刷是主要清掃部件，它以高速旋轉卷起垃圾進入塵盒。隨工作時間的增長主刷會有磨損。建議工作 {time} 小時或更短時間更換一次。",
            "brushExpireDesc": "預計剩餘 {time} 小時更換",
            "buy": "立即購買",
            "timezoneTip1": "可以將手機所在時區同步到裝置，請確保手機和裝置處在同一時區",
            "timezoneTip2": "*裝置時區不準確，可能造成定時清掃和勿擾模式時間紊亂",
            "syncTimeZone": "現在同步",
            "volumeTip": "可拖動調節裝置語音音量大小，可點擊試聽按鈕試聽",
            "listen": "試聽",
            "nodistrubTip": "開啟後，設定時間內不會自動續掃。勿擾時間段內會執行已設定的預約工作。",
            "endTime": "結束時間",
            "remain": "剩餘",
            "remainDay": "預計還可使用 {hour} 小時",
            "materialReset": "{name}復位",
            "resetHeapTitle": "重設濾芯使用時間",
            "resetHeapMessage": "已更換新的濾芯?",
            "resetRollingBrushTitle": "重設主刷使用時間",
            "resetRollingBrushMessage": "已更換新的主刷?",
            "resetSlidBrushTitle": "重設邊刷使用時間",
            "resetSlidBrushMessage": "已更換新的邊刷?",
            "deveiceName": "裝置名稱",
            "deviceShare": "裝置共用",
            "locationManager": "位置管理",
            "otaCheck": "韌體升級",
            "deleteDevice": "刪除裝置",
            "addDesktop": "新增桌面快捷方式",
            "feedback": "反饋問題",
            "useTerms": "法律資訊",
            "loading": "資料載入中...",
            "pause": "暫停",
            "timingStart": "啟用",
            "selectArea": "選擇區域",
            "selectAreaDesc": "若地圖發生變化，則該定時無效",
            "confirm": "確認",
            "autoClean": "全域清掃",
            "deleteMsg": "刪除此項定時設定",
            "upgradeErr1": "韌體下載失敗",
            "upgradeErr5": "韌體更新失敗",
            "upgradeErr7": "電量過低，無法升級",
            "upgradeErr8": "主機未在充電狀態，無法升級",
            "networkTimeout": "請求逾時",
            "remoteTips": "裝置與手機不在同一區域網路內，請連接在同一區域網路後使用遙控器",
            "remoteTip2": "檢查韌體和網路狀況",
            "areaEditTip1": "建議按照真實房屋型態調整區域",
            "areaEditTip2": "請選擇兩個相鄰可達區域進行合併",
            "areaEditTip3": "請選擇需要命名的區域",
            "areaEditTip4": "請選擇單個區域進行重命名",
            "areaNames": ["地下室", "閣樓", "媒體房", "餐廳", "陽台", "活動室", "客廳", "臥室", "廁所", "廚房"],
            "defaultArea": "預設房間",
            "addArea": "新增",
            "areaTipTitle": "請自動分區後使用",
            "areaTipMessage": "如何自動分區: 裝置從充電座出發，清掃完成並自動回充成功後，將自動儲存地圖並分區",
            "areaTipButton": "確定",
            "use": "使用",
            "used": "使用中",
            "netErr": "網路異常",
            "voiceDownloadErr": "語音包下載失敗",
            "voiceTip": "目前有語音包正在下載中，請稍後再試",
            "warnInfoTitle": "故障詳情",
            "totalTime": "累計時長",
            "totalArea": "累計面積",
            "totalTimes": "累計次數",
            "spotTips": "清掃座標點周邊 1.5×1.5 米的方形區域",
            "timingNumTip": "預約任務已到達上限，無法新增任務",
            "resetFail": "重設失敗",
            "syncSuccess": "同步成功",
            "cleanTip": "結束目前清掃，開始回充?",
            "licenseTitle": "使用者合約",
            "policyTitle": "隱私權政策",
            "removeWaterBoxTitle": "取下抹布支架",
            "removeWaterBoxMessage": "開始充電，請取下抹布支架",
            "keepSweeperTitle": "斷點續掃",
            "keepSweeperMessage": "主機將在充電達到 80% 以後自動開始未完成的清掃工作",
            "emptyLog": "記錄為空",
            "disturbTip": "設定的起始時間相同，請重新設定",
            "otatitle": "檢查韌體更新",
            "otaChecking": "正在偵測...",
            "currentVersion": "目前版本",
            "latestVersion": "最新版本",
            "isLatestVersion": "目前已是最新版本",
            "back": "返回",
            "checkVersionFailed": "偵測可更新韌體失敗",
            "retry": "再試一次",
            "updateNow": "立即更新",
            "updateTip": "升級前請將裝置置於充電座，並保持電量 15% 以上",
            "upgradeErr": "升級失敗",
            "updating": "正在升級...",
            "updateTip2": "升級中，請勿斷電，等待升級完成後再使用",
            "installing": "安裝更新中...",
            "installtip": "在安裝過程中需要重啟裝置，可能耗時較長，請耐心等待",
            "updatesuccess": "更新成功",
            "warnInfo": {
                "1": {
                    "title": "輪子懸空",
                    "desc": "請將主機移動到新位置啟動",
                    "warninfo": "輪子懸空，請移到新位置啟動。"
                },
                "2": {
                    "title": "懸崖感應器異常",
                    "desc": "請擦拭懸崖感應器並遠離懸崖後啟動",
                    "warninfo": "主機懸空，請移到新位置啟動；懸崖感應器太髒也可能導致該故障，請擦拭懸崖感應器排除。"
                },
                "3": {
                    "title": "碰撞感應器被卡住",
                    "desc": "請清理並輕拍碰撞感應器",
                    "warninfo": "碰撞緩衝器被卡住，請清除異物；如無異物，請移到新位置啟動。"
                },
                "4": {
                    "title": "主機傾斜",
                    "desc": "請將主機放置到水平地面啟動。",
                    "warninfo": "請將主機放置到水平地面啟動。"
                },
                "5": {
                    "title": "碰撞感應器被卡住",
                    "desc": "請清理並輕拍碰撞感應器",
                    "warninfo": "碰撞緩衝器被卡住，請清除異物；如無異物，請移到新位置啟動。"
                },
                "6": {
                    "title": "輪子懸空",
                    "desc": "請將主機移動到新位置啟動",
                    "warninfo": "輪子懸空，請移到新位置啟動。"
                },
                "7": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "8": {
                    "title": "塵盒未裝回",
                    "desc": "請裝回塵盒及濾網",
                    "warninfo": "請裝回塵盒及濾網並確認安裝到位；若仍報錯，請嘗試更換濾網。"
                },
                "11": {
                    "title": "濾網可能未晾乾或被堵塞",
                    "desc": "請確認濾網已晾乾或清理濾網",
                    "warninfo": "濾網未乾透，請晾曬至少 24 小時；濾網可能被堵塞，請清理濾網；如無法解決，請更換濾網。"
                },
                "12": {
                    "title": "主刷可能纏繞異物",
                    "desc": "請取下主刷，清理刷毛及軸承",
                    "warninfo": "主刷可能纏繞異物，請取下主刷及軸承並清理。"
                },
                "13": {
                    "title": "邊刷可能纏繞異物",
                    "desc": "請拆卸並清理邊刷",
                    "warninfo": "邊刷可能纏繞異物，請拆卸邊刷並清理。"
                },
                "14": {
                    "title": "濾網可能未晾乾或被堵塞",
                    "desc": "請確認濾網已晾乾或清理濾網",
                    "warninfo": "濾網未乾透，請晾曬至少 24 小時；濾網可能被堵塞，請清理濾網；如無法解決，請更換濾網。"
                },
                "15": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "16": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "17": {
                    "title": "可能被卡住或者困住了",
                    "desc": "請清除主機周圍障礙物",
                    "warninfo": "主機可能被卡住或困住，請清除主機周圍障礙物。"
                },
                "18": {
                    "title": "可能被卡住或者困住了",
                    "desc": "請清除主機周圍障礙物",
                    "warninfo": "主機可能被卡住或困住，請清除主機周圍障礙物。"
                },
                "20": {
                    "title": "電量過低",
                    "desc": "電量過低，請充電",
                    "warninfo": ""
                },
                "21": {
                    "title": "充電異常",
                    "desc": "充電異常，請嘗試清理充電接觸區域",
                    "warninfo": "請用乾布擦拭主機充電觸片及充電座彈片。"
                },
                "23": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "24": {
                    "title": "視覺定位感應器異常",
                    "desc": "請清理視覺定位感應器",
                    "warninfo": "請擦拭視覺定位感應器後重新啟動。"
                },
                "25": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "29": {
                    "title": "電池異常",
                    "desc": "電池異常",
                    "warninfo": "電池溫度過高或過低，請等待電池溫度正常後再使用。"
                },
                "30": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "31": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "32": {
                    "title": "可能被卡住或主輪捲入異物",
                    "desc": "請檢查主輪是否卡入異物並移到新位置啟動",
                    "warninfo": "主輪可能纏繞異物，請清理後重新啟動。"
                },
                "33": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "34": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "35": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "36": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "37": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "38": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "39": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "40": {
                    "title": "內部錯誤",
                    "desc": "請嘗試重設系統",
                    "warninfo": "偵測到內部錯誤，無法繼續工作，請嘗試重設系統。"
                },
                "41": {
                    "title": "偵測到強磁場",
                    "desc": "偵測到強磁場，請遠離虛擬牆啟動",
                    "warninfo": "啟動時主機太靠近虛擬牆，請移動到新位置啟動。"
                }
            },
            "slidBrushWarnTipTitle1": "邊刷即將到期",
            "slidBrushWarnTipMsg1": "邊刷即將到期，請及時更換",
            "slidBrushWarnTipTitle2": "邊刷已到期",
            "slidBrushWarnTipMsg2": "邊刷已到期，請更換",
            "rollingBrushWarnTitle1": "主刷即將到期",
            "rollingBrushWarnMsg1": "主刷即將到期，請及時更換",
            "rollingBrushWarnTitle2": "主刷已到期",
            "rollingBrushWarnMsg2": "主刷已到期，請更換",
            "heapWarnTitle1": "濾芯即將到期",
            "heapWarnMsg1": "濾芯即將到期，請及時更換",
            "heapWarnTitle2": "濾芯已到期",
            "heapWarnMsg2": "濾芯已到期，請更換",
            "updateDialogTip": "檢測到設備有最新版本韌體{version}，是否升級？"
        },
        "ko": {
            "IntelligentScene": "스마트 배경",
            "cleaning": "청소중",
            "mop": "물걸레",
            "customClean": "구역 청소",
            "cleaned": "청소 완료",
            "cleantime": "청소 시간",
            "surplusPower": "전량",
            "charge": "재충전",
            "chargePause": "일시 정지",
            "cleanPause": "일시 정지",
            "cleanStart": "청소 시작",
            "areaClean": "구역 청소",
            "remoteClean": "원격 청소",
            "localClean": "부분 청소",
            "chargingBtnText": "충전 중",
            "charging": "충전 중",
            "completedCharge": "충전 완료 됨",
            "completedChargeBtnText": "충전 완료 됨",
            "cleanMode": "청소 모드",
            "modeQuiet": "저소음 모드",
            "modeStandard": "일반 모드",
            "modeMedium": "중간 모드",
            "modeStrong": "강력 모드",
            "cleanTiming": "예약 청소",
            "cleanTimingStart": "{hour, plural,=0 {}other {#시간}}{minute}분 후 시작됩니다",
            "cleanTimingEmpty": "타이머 없음",
            "areaEdit": "구역 편집",
            "robotVoice": "로봇 음성",
            "prompt": "안내",
            "waiting": "대기",
            "gocharging": "재충전 중",
            "areaSlect": "선택한 {areaNum} 개의 구역",
            "areaMerge": "합병",
            "areaSplit": "분할",
            "areaRename": "이름 바꾸기",
            "spot": "지정 구역 청소하기",
            "setting": "설정",
            "robotSetting": "장치 설정",
            "msgSwitch": "메시지 알림 스위치",
            "cleanLog": "청소 기록",
            "materialTime": "소모품 카운트",
            "remoteControl": "리모컨",
            "productGuide": "도움말 사용",
            "functionSetting": "기능 설정",
            "generalSetting": "일반 설정",
            "securitySetting": "보안 설정",
            "moreSetting": "추가 설정",
            "locationRobot": "내 기기 위치 지정",
            "timeZone": "기기의 표준 시간대",
            "volume": "볼륨 설정",
            "disturbTime": "방해 금지 모드",
            "noTiming": "설정된 타이머가 없습니다",
            "repeat": "반복",
            "once": "한 번 작동",
            "everyDay": "매일",
            "workDay": "근무일(월요일부터 금요일)",
            "weekend": "주말",
            "custom": "사용자 정의",
            "Sunday": "일요일",
            "Monday": "월요일",
            "Tuesday": "화요일",
            "Wednesday": "수요일",
            "Thursday": "목요일",
            "Friday": "금요일",
            "Saturday": "토요일",
            "startTime": "작동 시간",
            "sure": "확인",
            "cancle": "취소",
            "heap": "필터",
            "heapDesc": "필터는 먼지가 먼지함에서 밖으로 빠져 나가는 것을 방지하기 위해 폴리머 섬유로 구성됩니다. 작업 시간이 늘어남에 따라 효력이 떨어지게 됩니다. 작업 시간을 {time} 시간 또는 교체 시간을 단축하는 것이 좋습니다.",
            "slidBrush": "사이드 브러쉬",
            "slidBrushDesc": "사이드 브러쉬는 코너의 쓰레기를 청소하고 쓰레기를 메인 브러쉬로 보냅니다. 작업 시간이 길어짐에 따라 마모가 발생하며 청소 효과에 영향을 줍니다. 작업 시간을 {time} 시간 또는 교체 시간을 단축하는 것이 좋습니다.",
            "rollingBrush": "메인 브러쉬",
            "rollingBrushDesc": "메인 브러쉬는 쓰레기를 고속으로 먼지함에 넣는 주요 부품입니다. 메인 브러쉬는 작업 시간이 길어짐에 따라 마모됩니다. 작업 시간을 {time} 시간 또는 교체 시간을 단축하는 것이 좋습니다.",
            "brushExpireDesc": "{time} 시간후에 교체 할 것으로 예상됩니다",
            "buy": "지금 바로 구입",
            "timezoneTip1": "스마트폰의 표준 시간대를 장치와 동기화할 수 있습니다, 휴대 전화와 장치가 동일한 시간대에 있는지 확인하십시오",
            "timezoneTip2": "* 장치의표준 시간대가 정확하지 않습니다, 타이밍 청소 및 방해 금지 모드 시간 오류를 유발할 수 있습니다",
            "syncTimeZone": "지금 동기화",
            "volumeTip": "드래그하여 장치의 음성 볼륨을 조절할 수 있습니다， 오디션 버튼을 클릭하여 확인할 수 있습니다",
            "listen": "오디션",
            "nodistrubTip": "전원을 켜면 설정한 시간 내에 스위프가 자동으로 재개되지 않습니다. 예정된 약속 작업은 설정된 방해 금지 시간대 동안 작동됩니다.",
            "endTime": "종료 시간",
            "remain": "남음",
            "remainDay": "{hour} 시간 사용 가능 예정",
            "materialReset": "{name} 재설정",
            "resetHeapTitle": "필터 사용 수명 재설정",
            "resetHeapMessage": "새 필터로 교체했습니까?",
            "resetRollingBrushTitle": "메인 브러쉬 사용 시간 재설정",
            "resetRollingBrushMessage": "새 메인 브러쉬가 교체 되었습니까?",
            "resetSlidBrushTitle": "사이드 브러쉬 사용 시간 재설정",
            "resetSlidBrushMessage": "새 사이드 브러쉬가 교체 되었습니까?",
            "deveiceName": "기기 이름",
            "deviceShare": "기기 공유",
            "locationManager": "위치 관리",
            "otaCheck": "펌웨어 업그레이드",
            "deleteDevice": "기기 삭제",
            "addDesktop": "바탕 화면 바로 가기 추가",
            "feedback": "문제 피드백",
            "useTerms": "법률 정보",
            "loading": "데이터 로드 중...",
            "pause": "일시 정지",
            "timingStart": "활성화",
            "selectArea": "영역 선택",
            "selectAreaDesc": "맵이 변경되면 타이머가 사라집니다",
            "confirm": "확인",
            "autoClean": "전체 영역 청소",
            "deleteMsg": "이 타이머 설정을 삭제합니다",
            "upgradeErr1": "펌웨어 다운로드 실패",
            "upgradeErr5": "펌웨어 업데이트 실패",
            "upgradeErr7": "배터리가 부족합니다, 업그레이드 할 수 없습니다",
            "upgradeErr8": "본체가 충전 중이 아니므로 업그레이드 할 수 없습니다",
            "networkTimeout": "지정된 요청 시간을 초과하였습니다",
            "remoteTips": "기기와 스마트폰이 같은 LAN에 있지 않습니다, 동일한 LAN에 연결하고 리모콘을 사용하십시오",
            "remoteTip2": "펌웨어 및 네트워크 상태 확인",
            "areaEditTip1": "실제 실내 구조에 따라 영역을 조정하는 것이 좋습니다",
            "areaEditTip2": "병합할 인접한 두 개의 인접한 영역을 선택하십시오",
            "areaEditTip3": "이름을 지정하려는 영역을 선택하십시오",
            "areaEditTip4": "이름을 바꿀 단일 영역을 선택하십시오",
            "areaNames": ["지하실", "다락방", "미디어 룸", "레스토랑", "발코니", "활동실", "거실", "침실", "화장실", "주방"],
            "defaultArea": "기본 설정 방",
            "addArea": "추가",
            "areaTipTitle": "자동 구역 나눔 후 사용하십시오",
            "areaTipMessage": "자동으로 구역을 나누는 방법: 충전 스탠드에서 장치가 출발합니다, 청소가 완료되고 자동 충전이 성공하면 맵을 자동으로 저장하고 구역을 나눕니다",
            "areaTipButton": "확인",
            "use": "사용",
            "used": "흐름",
            "netErr": "네트워크 이상",
            "voiceDownloadErr": "음성 패킷 다운로드에 실패했습니다",
            "voiceTip": "현재 음성 패킷을 다운로드 중입니다, 나중에 다시 시도하십시오",
            "warnInfoTitle": "오류 세부 정보",
            "totalTime": "누적 기간",
            "totalArea": "누적 면적",
            "totalTimes": "누적 횟수",
            "spotTips": "좌표 지점을 중심으로 1.5 × 1.5m 정도의 정사각형 영역을 청소합니다",
            "timingNumTip": "예약 작업이 상한에 도달하여 작업을 추가할 수 없습니다",
            "resetFail": "재설정 실패",
            "syncSuccess": "동기화 완료",
            "cleanTip": "현재 청소를 종료하고 재충전을 시작하시겠습니까?",
            "licenseTitle": "사용자 약관 정보",
            "policyTitle": "개인 정보 보호 정책",
            "removeWaterBoxTitle": "걸레 받침대 제거",
            "removeWaterBoxMessage": "충전 시작, 걸레 받침대를 제거하십시오",
            "keepSweeperTitle": "청소 끊긴 지점에서 계속 청소하기",
            "keepSweeperMessage": "본체는 80%까지 충전 후 자동으로 끝내지 않은 청소 작업을 시작합니다",
            "emptyLog": "레코드가 비어 있습니다",
            "disturbTip": "설정된 시작 시간이 동일합니다, 다시 설정하십시오",
            "otatitle": "펌웨어 업데이트 확인",
            "otaChecking": "테스트 중...",
            "currentVersion": "현재 버전",
            "latestVersion": "최신 버전",
            "isLatestVersion": "현재 최신 버전입니다",
            "back": "돌아가기",
            "checkVersionFailed": "업데이트할 수 있는 펌웨어 감지에 실패했습니다",
            "retry": "다시 시도",
            "updateNow": "지금 업데이트",
            "updateTip": "업그레이드하기 전에 충전 도크에 장치를 놓고 배터리 레벨을 15 % 이상으로 유지하십시오",
            "upgradeErr": "업그레이드 실패",
            "updating": "업그레이드 중...",
            "updateTip2": "업그레이드하는 동안 전원을 끄지 말고 사용하기 전에 업그레이드가 완료 될 때까지 기다리십시오",
            "installing": "업데이트 설치중...",
            "installtip": "설치 과정에서 기기를 다시 부팅해야 하므로 오래 걸릴 수 있습니다, 잠시 기다려주십시오",
            "updatesuccess": "업데이트 완료",
            "warnInfo": {
                "1": {
                    "title": "바퀴가 떠 있습니다",
                    "desc": "시작하려면 본체를 새 위치로 이동하십시오",
                    "warninfo": "바퀴가 떠있는 상태에서 시작하려면 새 위치로 이동하십시오."
                },
                "2": {
                    "title": "추락 방지 센서 이상",
                    "desc": "추락 방지 센서를 닦아서 추락 위험이 있는 구역에서 멀리한 후 작동하십시오",
                    "warninfo": "본체가 떠 있습니다, 새로운 위치로 이동하여 작동하십시오; 추락 방지 센서가 너무 더러워 오류가 발생할 수 있으므로 추락 방지 센서를 닦아주십시오."
                },
                "3": {
                    "title": "충돌 센서가 걸렸습니다",
                    "desc": "충돌 센서를 청소하고 탭하십시오",
                    "warninfo": "충돌 버퍼가 걸렸습니다, 이물질을 제거하십시오; 이물질이 없으면 새로운 위치로 이동하고 작동하십시오."
                },
                "4": {
                    "title": "본체 기울어짐",
                    "desc": "본체를 평평한 바닥에 놓고 작동하십시오.",
                    "warninfo": "본체를 평평한 바닥에 놓고 작동하십시오."
                },
                "5": {
                    "title": "충돌 센서가 걸렸습니다",
                    "desc": "충돌 센서를 청소하고 탭하십시오",
                    "warninfo": "충돌 버퍼가 걸렸습니다, 이물질을 제거하십시오; 이물질이 없으면 새로운 위치로 이동하고 작동하십시오."
                },
                "6": {
                    "title": "바퀴가 떠 있습니다",
                    "desc": "시작하려면 본체를 새 위치로 이동하십시오",
                    "warninfo": "바퀴가 떠있는 상태에서 시작하려면 새 위치로 이동하십시오."
                },
                "7": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "8": {
                    "title": "먼지함이 장착되지 않았습니다",
                    "desc": "먼지함과 필터를 다시 장착하십시오",
                    "warninfo": "먼지함과 필터를 다시 장착하고 설치가 제대로 되었는지 확인하십시오; 그래도 오류가 발생하면 필터를 교체하십시오."
                },
                "11": {
                    "title": "필터가 건조하거나 막혀 있지 않을 수 있습니다",
                    "desc": "필터가 건조되거나 청소되었는지 확인하십시오",
                    "warninfo": "필터가 건조하지 않은 상태에서 최소 24 시간 동안 건조하십시오； 필터가 막혔을 수 있습니다, 필터를 청소하십시오; 그래도 해결할 수 없는 경우에는 필터를 교체하십시오."
                },
                "12": {
                    "title": "메인 브러쉬에 이물질이 감겨있을 수 있습니다",
                    "desc": "브러쉬와 베어링 청소를 위해 메인 브러쉬를 제거하십시오",
                    "warninfo": "메인 브러쉬에 이물질이 감겨있을 수 있습니다, 메인 브러쉬와 베어링을 제거하고 청소하십시오."
                },
                "13": {
                    "title": "사이드 브러쉬에 이물질이 감겨있을 수 있습니다",
                    "desc": "사이드 브러쉬를 분해하고 청소하십시오",
                    "warninfo": "사이드 브러쉬에 이물질이 감겨았을 수 있습니다, 사이드 브러쉬를 제거하고 청소하십시오."
                },
                "14": {
                    "title": "필터가 건조하거나 막혀 있지 않을 수 있습니다",
                    "desc": "필터가 건조되거나 청소되었는지 확인하십시오",
                    "warninfo": "필터가 건조하지 않은 상태에서 최소 24 시간 동안 건조하십시오； 필터가 막혔을 수 있습니다, 필터를 청소하십시오; 그래도 해결할 수 없는 경우에는 필터를 교체하십시오."
                },
                "15": {
                    "title": "막혀 있거나 메인 바퀴가 이물질에 감싸어 있을 수 있습니다",
                    "desc": "메인 바퀴에 이물질에 막혀있는지 확인하고 새 위치로 이동하여 작동하십시오",
                    "warninfo": "메인 바퀴에 이물질이 감겨있을 수 있으므로 청소 후 다시 작동하십시오."
                },
                "16": {
                    "title": "막혀 있거나 메인 바퀴가 이물질에 감싸어 있을 수 있습니다",
                    "desc": "메인 바퀴에 이물질에 막혀있는지 확인하고 새 위치로 이동하여 작동하십시오",
                    "warninfo": "메인 바퀴에 이물질이 감겨있을 수 있으므로 청소 후 다시 작동하십시오."
                },
                "17": {
                    "title": "막혀있거나 걸려 있을 수 있습니다",
                    "desc": "본체 주변 장애물을 제거하십시오",
                    "warninfo": "본체가 끼거나 막혀있을 수 있습니다, 본체 주변의 장애물을 제거하십시오."
                },
                "18": {
                    "title": "막혀있거나 걸려 있을 수 있습니다",
                    "desc": "본체 주변 장애물을 제거하십시오",
                    "warninfo": "본체가 끼거나 막혀있을 수 있습니다, 본체 주변의 장애물을 제거하십시오."
                },
                "20": {
                    "title": "배터리 부족",
                    "desc": "배터리가 부족하면 충전하십시오",
                    "warninfo": ""
                },
                "21": {
                    "title": "충전 이상",
                    "desc": "충전이 비정상적인 경우 충전극을 청소하십시오",
                    "warninfo": "본체 충전 패드와 충전 스탠드 패드를 마른 천으로 닦으십시오."
                },
                "23": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "24": {
                    "title": "비주얼 포지션 센서가 비정상 입니다",
                    "desc": "비주얼 포지션 센서를 청소하십시오",
                    "warninfo": "비주얼 포지션 센서를 닦고 다시 작동하십시오."
                },
                "25": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "29": {
                    "title": "배터리 이상",
                    "desc": "배터리 이상",
                    "warninfo": "배터리 온도가 너무 높거나 낮으면 배터리 온도가 정상이 될 때까지 기다렸다가 사용하십시오."
                },
                "30": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "31": {
                    "title": "막혀 있거나 메인 바퀴가 이물질에 감싸어 있을 수 있습니다",
                    "desc": "메인 바퀴에 이물질에 막혀있는지 확인하고 새 위치로 이동하여 작동하십시오",
                    "warninfo": "메인 바퀴에 이물질이 감겨있을 수 있으므로 청소 후 다시 작동하십시오."
                },
                "32": {
                    "title": "막혀 있거나 메인 바퀴가 이물질에 감싸어 있을 수 있습니다",
                    "desc": "메인 바퀴에 이물질에 막혀있는지 확인하고 새 위치로 이동하여 작동하십시오",
                    "warninfo": "메인 바퀴에 이물질이 감겨있을 수 있으므로 청소 후 다시 작동하십시오."
                },
                "33": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "34": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "35": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "36": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "37": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "38": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "39": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "40": {
                    "title": "내부 오류",
                    "desc": "시스템 재설정을 시도하십시오",
                    "warninfo": "내부 오류가 감지되어 더 이상 작동하지 않습니다, 시스템을 재설정하십시오."
                },
                "41": {
                    "title": "강력한 자기장이 감지 됨",
                    "desc": "강한 자기장이 감지되었습니다,가상 벽에서 멀리하여 작동하십시오",
                    "warninfo": "본체 작동시 가상 벽에 너무 가깝게 위치해 있습니다, 새 위치로 이동하여 작동하십시오."
                }
            },
            "slidBrushWarnTipTitle1": "사이드 브러쉬가 곧 만료됩니다",
            "slidBrushWarnTipMsg1": "사이드 브러쉬가 곧 만료됩니다, 제 때 교체하십시오",
            "slidBrushWarnTipTitle2": "사이드 브러쉬가 만료되었습니다",
            "slidBrushWarnTipMsg2": "사이드 브러쉬가 만료되었습니다, 교체하십시오",
            "rollingBrushWarnTitle1": "메인 브러쉬가 곧 만료됩니다",
            "rollingBrushWarnMsg1": "메인 브러쉬가 곧 만료됩니다, 제 때 교체하십시오",
            "rollingBrushWarnTitle2": "메인 브러쉬가 만료되었습니다",
            "rollingBrushWarnMsg2": "메인 브러쉬가 만료되었습니다, 교체하십시오",
            "heapWarnTitle1": "필터가 곧 만료됩니다",
            "heapWarnMsg1": "필터가 곧 만료됩니다, 제 때 교체하십시오",
            "heapWarnTitle2": "필터가 만료되었습니다",
            "heapWarnMsg2": "필터가 만료되었습니다, 교체하십시오",
            "updateDialogTip": "장치에 최신 펌웨어 버전이 {version}인 것으로 감지되었습니다, 업그레이드하시겠습니까？",
            "logDate": "{month}-{day} {hour}:{minute}"
        },
        "tr": {
            "IntelligentScene": "Akıllı ortamlar",
            "cleaning": "Temizliyor",
            "mop": "Paspaslıyor",
            "customClean": "Alanlara ayrılmış temizlik",
            "cleaned": "Temizlendi",
            "cleantime": "Temizleme zamanı",
            "surplusPower": "Pil",
            "charge": "Stand",
            "chargePause": "Duraklat",
            "cleanPause": "Duraklat",
            "cleanStart": "Temizliği \nbaşlat",
            "areaClean": "Alan temizliği",
            "remoteClean": "Uzaktan kumandalı temizlik",
            "localClean": "Kısmi temizlik",
            "chargingBtnText": "Şarj \nediliyor",
            "charging": "Şarj ediliyor",
            "completedCharge": "Şarj etme tamamlandı",
            "completedChargeBtnText": "Şarj etme \ntamamlandı",
            "cleanMode": "Temizlik modu",
            "modeQuiet": "Sessiz",
            "modeStandard": "Standart",
            "modeMedium": "Orta",
            "modeStrong": "Turbo",
            "cleanTiming": "Planlanmış temizlik",
            "cleanTimingStart": "{hour, plural,=0 { }other {# ve }}{minute} dk içinde başlayacak",
            "cleanTimingEmpty": "Planlanmış temizlik görevi yok",
            "areaEdit": "Alan düzenleyici",
            "robotVoice": "Sesli uyarılar",
            "prompt": "Bildirimler",
            "waiting": "Hazır",
            "gocharging": "Şarj için standa geri dönüyor",
            "areaSlect": "Seçili alanlar: {areaNum}",
            "areaMerge": "Birleştir",
            "areaSplit": "Böl",
            "areaRename": "Yeniden adlandır",
            "spot": "Orayı temizle",
            "setting": "Ayarlar",
            "robotSetting": "Cihaz Ayarları",
            "msgSwitch": "Bildirimler",
            "cleanLog": "Temizlik geçmişi",
            "materialTime": "Servis programı",
            "remoteControl": "Uzaktan kumanda",
            "productGuide": "Yardım",
            "functionSetting": "Diğer ayarlar",
            "generalSetting": "Genel ayarlar",
            "securitySetting": "Güvenlik ayarları",
            "moreSetting": "Ek ayarlar",
            "locationRobot": "Temizlik robotumu bul",
            "timeZone": "Temizlik robotu saat dilimi",
            "volume": "Ses ayarları",
            "disturbTime": "DND modu",
            "noTiming": "Program yok",
            "repeat": "Tekrarla",
            "once": "Bir kez",
            "everyDay": "Günlük",
            "workDay": "İş günleri (Pzt - Cum)",
            "weekend": "Hafta sonları",
            "custom": "Özel",
            "Sunday": "Paz",
            "Monday": "Pzt",
            "Tuesday": "Sal",
            "Wednesday": "Çar",
            "Thursday": "Per",
            "Friday": "Cum",
            "Saturday": "Cmt",
            "startTime": "Başlangıç zamanı",
            "sure": "Tamam",
            "cancle": "İptal",
            "heap": "Filtre",
            "heapDesc": "Filtre, tozun toz haznesinden kaçmasını önlemek için polimer liflerden üretilmiştir. Zaman içinde filtre tıkanır ve verimliliğini kaybeder. Dolayısıyla, toplamda her {time} çalışma saati ya da öncesinde filtrenin değiştirilmesi önerilir.",
            "slidBrush": "Yan fırça",
            "slidBrushDesc": "Yan fırça, kiri ve birikintileri köşelerden alarak ana fırçaya yönlendirir. Zaman içinde yan fırça yıpranır ve verimliliğini kaybeder. Dolayısıyla, toplamda her {time} çalışma saati ya da öncesinde yan fırçanın değiştirilmesi önerilir.",
            "rollingBrush": "Ana fırça",
            "rollingBrushDesc": "Ana fırça, kir ve birikintileri temizlik robotunun toz haznesine yönlendirir. Zaman içinde ana fırça yıpranır ve verimliliğini kaybeder. Dolayısıyla, toplamda her {time} çalışma saati ya da öncesinde ana fırçanın değiştirilmesi önerilir.",
            "brushExpireDesc": "Yaklaşık {time} saat sonra değiştirin",
            "buy": "Şimdi satın al",
            "timezoneTip1": "Telefonunuzun saat dilimini temizlik robotu ile senkronize ederek her ikisinin de aynı saat diliminde olmasını sağlayabilirsiniz.",
            "timezoneTip2": "* Temizlik robotunun saat dilimi doğru değilse, planlanmış temizlikler ve DND modu beklendiği gibi çalışmayabilir.",
            "syncTimeZone": "Şimdi senkronize et",
            "volumeTip": "Temizlik robotu sesli uyarı seviyesi, ses ayar tuşu yukarı aşağı hareket ettirilerek değiştirilebilir. Denemek için test ses ayar tuşuna dokunun.",
            "listen": "Dinle",
            "nodistrubTip": "Bu işlev etkinleştirildiğinde temizlik robotu belirlenen süre içerisinde temizliğe otomatik olarak devam etmez. Bununla birlikte, programlanmış temizlikler DND süresi içerisinde gerçekleştirilir.",
            "endTime": "Bitiş saati",
            "remain": "Kalan",
            "remainDay": "Geriye kalan hizmet süresi: Yaklaşık {hour} saat",
            "materialReset": "{name} sıfırla",
            "resetHeapTitle": "Filtre kullanım süresini sıfırla",
            "resetHeapMessage": "Filtrenizi yenisiyle mi değiştirdiniz?",
            "resetRollingBrushTitle": "Ana fırça kullanım süresini sıfırla",
            "resetRollingBrushMessage": "Ana fırçanızı yenisiyle mi değiştirdiniz?",
            "resetSlidBrushTitle": "Yan fırça kullanım süresini sıfırla",
            "resetSlidBrushMessage": "Yan fırçanızı yenisiyle mi değiştirdiniz?",
            "deveiceName": "Cihaz adı",
            "deviceShare": "Cihaz paylaşımı",
            "locationManager": "Konum yönetimi",
            "otaCheck": "Üretici yazılımı güncelleştirmesi",
            "deleteDevice": "Cihazı sil",
            "addDesktop": "Ana ekran kısayolu ekle",
            "feedback": "Geri bildirim",
            "useTerms": "Hukuki bilgiler",
            "loading": "Veriler yükleniyor…",
            "pause": "Duraklat",
            "timingStart": "Etkinleştir",
            "selectArea": "Alanı seç",
            "selectAreaDesc": "Harita değiştiği zaman bu planlanmış temizlik geçersiz hale gelir.",
            "confirm": "Tamam",
            "autoClean": "Tam temizlik",
            "deleteMsg": "Bu programı sil",
            "upgradeErr1": "Aygıt yazılımı indirilemedi",
            "upgradeErr5": "Üretici yazılımı güncelleştirilemedi",
            "upgradeErr7": "Şarj seviyesi çok düşükken güncellenemez",
            "upgradeErr8": "Temizlik robotu şarjda değilken güncellenemez",
            "networkTimeout": "İstek zaman aşımına uğradı",
            "remoteTips": "Temizlik robotu ve telefon aynı Wi-Fi ağına bağlı değil. Lütfen uzaktan kontrol işlevini kullanabilmek için her ikisini aynı ağa bağlayın.",
            "remoteTip2": "Aygıt yazılımını ve ağ durumunu kontrol edin",
            "areaEditTip1": "Alanları evinizin gerçek düzenine göre ayarlamanız tavsiye edilir.",
            "areaEditTip2": "Lütfen birleştirmek için yan yana iki alanı seçin",
            "areaEditTip3": "Lütfen yeniden adlandırmak istediğiniz alanı seçin",
            "areaEditTip4": "Lütfen yeniden adlandırmak için bir alanı seçin",
            "areaNames": ["Bodrum", "Çatı Katı", "TV Odası", "Yemek Odası", "Balkon", "Etkinlik Odası", "Oturma Odası", "Yatak Odası", "Banyo", "Mutfak"],
            "defaultArea": "Varsayılan oda",
            "addArea": "Ekle",
            "areaTipTitle": "Lütfen kullanmadan önce otomatik bölümleme yapın",
            "areaTipMessage": "Otomatik bölümleme: Temizlik robotu şarj standından başlar. Temizlik ve başarılı şarj işlemi sonrasında harita otomatik olarak kaydedilir ve alanlara bölünür.",
            "areaTipButton": "Tamam",
            "use": "Kullan",
            "used": "Şimdiki",
            "netErr": "Ağ hatası",
            "voiceDownloadErr": "Ses paketi indirilemedi",
            "voiceTip": "Ses paketi indiriliyor, lütfen daha sonra tekrar deneyin",
            "warnInfoTitle": "Hata bilgileri",
            "totalTime": "Toplam süre",
            "totalArea": "Toplam alan",
            "totalTimes": "Toplam saat",
            "spotTips": "Koordinat noktası çevresindeki 1,5m’ye 1,5m alanı temizle",
            "timingNumTip": "Maks. planlanmış temizlik sayısına ulaşıldı, yenisi eklenemez.",
            "resetFail": "Sıfırlanamadı",
            "syncSuccess": "Başarıyla senkronize edildi",
            "cleanTip": "Mevcut temizlemeyi durdur ve şarj için standa geri dön?",
            "licenseTitle": "Kullanıcı Anlaşması",
            "policyTitle": "Gizlilik İlkesi",
            "removeWaterBoxTitle": "Paspas panelini çıkar",
            "removeWaterBoxMessage": "Şarj etmeye başlamak için lütfen paspas panelini çıkarın",
            "keepSweeperTitle": "Temizliğe devam et",
            "keepSweeperMessage": "Şarj seviyesi %80’e ulaştıktan sonra temizlik robotu otomatik olarak geriye kalan temizliğe devam eder.",
            "emptyLog": "Geçmiş boş",
            "disturbTip": "Başlangıç saati ile aynı olamaz, lütfen tekrar girin.",
            "otatitle": "Üretici yazılımı güncelleştirmelerini denetle",
            "otaChecking": "Denetleniyor…",
            "currentVersion": "Geçerli sürüm",
            "latestVersion": "En son sürüm",
            "isLatestVersion": "Geçerli sürüm en son sürümdür",
            "back": "Geri",
            "checkVersionFailed": "Üretici yazılımı güncelleştirmelerine göz atılamadı",
            "retry": "Tekrar dene",
            "updateNow": "Şimdi güncelleştir",
            "updateTip": "Güncellemeden önce temizlik robotunu şarj standına yerleştirin ve şarj seviyesinin %15’ten fazla olduğundan emin olun.",
            "upgradeErr": "Güncelleştirilemedi",
            "updating": "Güncelleştiriliyor…",
            "updateTip2": "Güncelleniyor, güncelleme tamamlanmadan önce temizlik robotunu kapatmayın ya da kullanmayın.",
            "installing": "Güncelleştirme yükleniyor…",
            "installtip": "Kurulum süreci temizlik robotunun yeniden başlatılmasını gerektiriyor. Bu biraz zaman alabilir, lütfen sabırlı olun.",
            "updatesuccess": "Başarıyla güncelleştirildi",
            "warnInfo": {
                "1": {
                    "title": "Tekerlekler havada",
                    "desc": "Lütfen temizlik robotunu yeniden konumlandırın ve yeniden başlatın.",
                    "warninfo": "Tekerlekler havada, lütfen temizlik robotunu yeniden konumlandırın ve yeniden başlatın."
                },
                "2": {
                    "title": "Engel sensörü hatası",
                    "desc": "Lütfen engel sensörünü silin ve temizliğe herhangi engelde uzak bir yerde başlayın.",
                    "warninfo": "Temizlik robotu tekerlekleri havada, onu yeni bir yere koymayı deneyin. Engel sensörü çok kirli olduğu zaman da bu tip bir hata meydana gelebilir. Lütfen engel sensörünü temizleyin ve yeniden deneyin."
                },
                "3": {
                    "title": "Çarpışma sensörü sıkıştı",
                    "desc": "Lütfen çarpışma sensörünü temizleyin ve hafifçe üzerine vurun.",
                    "warninfo": "Tampon sıkıştığı zaman, sıkışan cisimlerin temizlenmesi için birkaç kez hafifçe vurmayı deneyin. Tampon sıkışmamışsa, temizlik robotunu yeni bir yere koymayı ve yeniden başlatmayı deneyin."
                },
                "4": {
                    "title": "Süpürge dengesiz",
                    "desc": "Lütfen temizlik robotunu düz bir yere koyun ve yeniden başlatın.",
                    "warninfo": "Lütfen temizlik robotunu düz bir yere koyun ve yeniden başlatın."
                },
                "5": {
                    "title": "Çarpışma sensörü sıkıştı",
                    "desc": "Lütfen çarpışma sensörünü temizleyin ve hafifçe üzerine vurun.",
                    "warninfo": "Tampon sıkıştığı zaman, sıkışan cisimlerin temizlenmesi için birkaç kez hafifçe vurmayı deneyin. Tampon sıkışmamışsa, temizlik robotunu yeni bir yere koymayı ve yeniden başlatmayı deneyin."
                },
                "6": {
                    "title": "Tekerlekler havada",
                    "desc": "Lütfen temizlik robotunu yeniden konumlandırın ve yeniden başlatın.",
                    "warninfo": "Tekerlekler havada, lütfen temizlik robotunu yeniden konumlandırın ve yeniden başlatın."
                },
                "7": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "8": {
                    "title": "Toz haznesi takılmadı.",
                    "desc": "Lütfen toz haznesi ve filtreyi takın.",
                    "warninfo": "Lütfen hem toz haznesi hem de filtreyi doğru bir şekilde takın. Hata devam ederse filtreyi değiştirmeyi deneyin."
                },
                "11": {
                    "title": "Filtre kuru olmayabilir ya da tıkanmış olabilir.",
                    "desc": "Lütfen filtrenin kuru olup olmadığı ve temizlenmesi gerekip gerekmediğini kontrol edin.",
                    "warninfo": "Filtre kuru değilse, lütfen en az 24 saat boyunca kurumaya bırakın. Filtre tıkanmışsa lütfen temizleyin. Bu sorun çözülemiyorsa lütfen filtreyi değiştirin."
                },
                "12": {
                    "title": "Ana fırça etrafına bir cisim dolanmış olabilir.",
                    "desc": "Lütfen fırça kılları ve yuvaları temizlemek için ana fırçayı çıkarın.",
                    "warninfo": "Ana fırça etrafına bir cisim dolanmış olabilir, lütfen fırça kılları ve yuvaları temizlemek için ana fırçayı çıkarın."
                },
                "13": {
                    "title": "Yan fırça etrafına bir cisim dolanmış olabilir.",
                    "desc": "Lütfen yan fırçayı çıkartın ve temizleyin.",
                    "warninfo": "Yan fırça etrafına bir cisim dolanmış olabilir, lütfen fırça kıllarını temizlemek için yan fırçayı çıkarın."
                },
                "14": {
                    "title": "Filtre kuru olmayabilir ya da tıkanmış olabilir.",
                    "desc": "Lütfen filtrenin kuru olup olmadığı ve temizlenmesi gerekip gerekmediğini kontrol edin.",
                    "warninfo": "Filtre kuru değilse, lütfen en az 24 saat boyunca kurumaya bırakın. Filtre tıkanmışsa lütfen temizleyin. Bu sorun çözülemiyorsa lütfen filtreyi değiştirin."
                },
                "15": {
                    "title": "Temizlik robotu sıkışmış ya da tekerlekleri bir nesne tarafından engellenmiş olabilir.",
                    "desc": "Tekerleklerin bir nesne tarafından engellenmiş olup olmadıklarını kontrol edin, lütfen temizlemek için tekerlekleri döndürün ve yeniden başlamak için temizlik robotunu yeni bir konuma getirin.",
                    "warninfo": "Tekerlekler bir cisim tarafından engellenmiş olabilir, lütfen tekerlekleri temizlemek için onları döndürün ve yeniden başlatın."
                },
                "16": {
                    "title": "Temizlik robotu sıkışmış ya da tekerlekleri bir nesne tarafından engellenmiş olabilir.",
                    "desc": "Tekerleklerin bir nesne tarafından engellenmiş olup olmadıklarını kontrol edin, lütfen temizlemek için tekerlekleri döndürün ve yeniden başlamak için temizlik robotunu yeni bir konuma getirin.",
                    "warninfo": "Tekerlekler bir cisim tarafından engellenmiş olabilir, lütfen tekerlekleri temizlemek için onları döndürün ve yeniden başlatın."
                },
                "17": {
                    "title": "Temizlik robotu tıkanmış ya da takılmış olabilir.",
                    "desc": "Lütfen etrafındaki engelleri kaldırın",
                    "warninfo": "Temizlik robotu tıkanmış ya da takılmış olabilir, lütfen etrafındaki engelleri kaldırın."
                },
                "18": {
                    "title": "Temizlik robotu tıkanmış ya da takılmış olabilir.",
                    "desc": "Lütfen etrafındaki engelleri kaldırın",
                    "warninfo": "Temizlik robotu tıkanmış ya da takılmış olabilir, lütfen etrafındaki engelleri kaldırın."
                },
                "20": {
                    "title": "Düşük batarya",
                    "desc": "Şarj seviyesi çok düşük, lütfen şarj edin.",
                    "warninfo": ""
                },
                "21": {
                    "title": "Şarj etme hatası",
                    "desc": "Şarj hatası, lütfen şarj temas yüzeylerini temizlemeyi deneyin.",
                    "warninfo": "Lütfen hem stand hem de temizlik robotu üzerindeki şarj temas yüzeylerini kuru bir bezle silin."
                },
                "23": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "24": {
                    "title": "Görsel konumlandırma sensör hatası",
                    "desc": "Lütfen görsel konumlandırma sensörünü temizleyin.",
                    "warninfo": "Lütfen görsel konumlandırma sensörünü silerek temizleyin ve yeniden başlatın."
                },
                "25": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "29": {
                    "title": "Batarya hatası",
                    "desc": "Batarya hatası",
                    "warninfo": "Batarya sıcaklığı çok yüksek ya da çok düşük, lütfen batarya sıcaklığı tekrar normale dönene kadar bekleyin."
                },
                "30": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "31": {
                    "title": "Temizlik robotu sıkışmış ya da tekerlekleri bir nesne tarafından engellenmiş olabilir.",
                    "desc": "Tekerleklerin bir nesne tarafından engellenmiş olup olmadıklarını kontrol edin, lütfen temizlemek için tekerlekleri döndürün ve yeniden başlamak için temizlik robotunu yeni bir konuma getirin.",
                    "warninfo": "Tekerlekler bir cisim tarafından engellenmiş olabilir, lütfen tekerlekleri temizlemek için onları döndürün ve yeniden başlatın."
                },
                "32": {
                    "title": "Temizlik robotu sıkışmış ya da tekerlekleri bir nesne tarafından engellenmiş olabilir.",
                    "desc": "Tekerleklerin bir nesne tarafından engellenmiş olup olmadıklarını kontrol edin, lütfen temizlemek için tekerlekleri döndürün ve yeniden başlamak için temizlik robotunu yeni bir konuma getirin.",
                    "warninfo": "Tekerlekler bir cisim tarafından engellenmiş olabilir, lütfen tekerlekleri temizlemek için onları döndürün ve yeniden başlatın."
                },
                "33": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "34": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "35": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "36": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "37": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "38": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "39": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "40": {
                    "title": "Dahili hata",
                    "desc": "Lütfen sistemi sıfırlamayı deneyin.",
                    "warninfo": "Dahili hata saptandı, çalışmaya devam edemiyor, lütfen sistemi sıfırlamayı deneyin."
                },
                "41": {
                    "title": "Güçlü manyetik alan saptandı",
                    "desc": "Güçlü manyetik alan saptandı, lütfen sanal duvardan uzak durun.",
                    "warninfo": "Temizlik robotu başlangıçta sanal duvara çok yakın, lütfen başlamak için başka bir yere koyun."
                }
            },
            "slidBrushWarnTipTitle1": "Yan fırçanın yakında değiştirilmesi gerekiyor",
            "slidBrushWarnTipMsg1": "Yan fırça neredeyse tamamen aşındı, lütfen mümkün olan en kısa sürede değiştirin.",
            "slidBrushWarnTipTitle2": "Yan fırçanın değiştirilmesi gerekiyor",
            "slidBrushWarnTipMsg2": "Yan fırça tamamen aşındı, lütfen değiştirin.",
            "rollingBrushWarnTitle1": "Ana fırçanın yakında değiştirilmesi gerekiyor",
            "rollingBrushWarnMsg1": "Ana fırça neredeyse tamamen aşındı, lütfen mümkün olan en kısa sürede değiştirin.",
            "rollingBrushWarnTitle2": "Ana fırçanın değiştirilmesi gerekiyor",
            "rollingBrushWarnMsg2": "Ana fırça tamamen aşındı, lütfen değiştirin.",
            "heapWarnTitle1": "Filtre neredeyse işlevini yitirdi",
            "heapWarnMsg1": "Filtre neredeyse işlevini yitirdi, lütfen mümkün olan en kısa sürede değiştirin.",
            "heapWarnTitle2": "Filtre işlevini yitirdi",
            "heapWarnMsg2": "Filtre işlevini yitirdi, lütfen değiştirin.",
            "updateDialogTip": "Aygıt yazılımı güncelleştirmesi ({version}) mevcut. Şimdi güncelleştirilsin mi?",
            "minute": "dk",
            "logDate": "{day}/{month} {hour}:{minute}"
        }
    };
    var localStrings = exports.localStrings = new _LocalizedStrings2.default(strings);

    function getString(key) {
        var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (obj) {
            return new _intlMessageformat2.default(localStrings[key], localStrings.language).format(obj);
        } else {
            return localStrings[key];
        }
    }
},10157,[10160,13591,13582,13669,13672,13675,13678],"projects/com.dreame.devices/main/MHLocalizableString.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    var _miot = _require(_dependencyMap[0]);

    var localization = _miot.Host.locale.language;

    if (!localization) {
        console.error("Something went wrong initializing the native ReactLocalization module.\nPlease check your configuration.\nDid you run 'react-native link'?");
    }

    var interfaceLanguage = localization.replace(/_/g, '-');

    var LocalizedStrings = function () {
        babelHelpers.createClass(LocalizedStrings, [{
            key: "_getBestMatchingLanguage",
            value: function _getBestMatchingLanguage(language, props) {
                if (props[language]) return language;
                var idx = language.lastIndexOf("-");

                if (idx >= 0) {
                    language = language.substring(0, idx);
                    return this._getBestMatchingLanguage(language, props);
                }

                return Object.keys(props)[0];
            }
        }]);

        function LocalizedStrings(props) {
            babelHelpers.classCallCheck(this, LocalizedStrings);
            this.props = props;
            this.setLanguage(interfaceLanguage);
        }

        babelHelpers.createClass(LocalizedStrings, [{
            key: "setContent",
            value: function setContent(props) {
                this.props = props;
                this.setLanguage(this.language);
            }
        }, {
            key: "setLanguage",
            value: function setLanguage(language) {
                console.log("langeage:", language);

                var bestLanguage = this._getBestMatchingLanguage(language, this.props);

                var defaultLanguage = Object.keys(this.props)[0];
                this.language = bestLanguage;

                if (this.props[bestLanguage]) {
                    var localizedStrings = babelHelpers.extends({}, this.props[defaultLanguage], this.props[this.language]);

                    for (var key in localizedStrings) {
                        if (localizedStrings.hasOwnProperty(key)) {
                            this[key] = localizedStrings[key];
                        }
                    }

                    if (defaultLanguage !== this.language) {
                        localizedStrings = this.props[defaultLanguage];

                        this._fallbackValues(localizedStrings, this);
                    }
                }
            }
        }, {
            key: "_fallbackValues",
            value: function _fallbackValues(defaultStrings, strings) {
                for (var key in defaultStrings) {
                    if (defaultStrings.hasOwnProperty(key) && !strings[key]) {
                        strings[key] = defaultStrings[key];
                        console.log("Missing localization for language '" + this.language + "' and key '" + key + "'.");
                    } else {
                        if (typeof strings[key] != "string") {
                            this._fallbackValues(defaultStrings[key], strings[key]);
                        }
                    }
                }
            }
        }, {
            key: "getLanguage",
            value: function getLanguage() {
                return this.language;
            }
        }, {
            key: "getInterfaceLanguage",
            value: function getInterfaceLanguage() {
                return interfaceLanguage;
            }
        }, {
            key: "getLocaleObject",
            value: function getLocaleObject() {
                return this.props;
            }
        }, {
            key: "getAvailableLanguages",
            value: function getAvailableLanguages() {
                if (!this.availableLanguages) {
                    this.availableLanguages = [];

                    for (var language in this.props) {
                        this.availableLanguages.push(language);
                    }
                }

                return this.availableLanguages;
            }
        }, {
            key: "formatString",
            value: function formatString(str) {
                var res = str;

                for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    values[_key - 1] = arguments[_key];
                }

                for (var i = 0; i < values.length; i++) {
                    res = this._replaceAll("{" + i + "}", values[i], res);
                }

                return res;
            }
        }, {
            key: "getString",
            value: function getString(key, language) {
                try {
                    return this.props[language][key];
                } catch (ex) {
                    console.log("No localization found for key " + key + " and language " + language);
                }

                return null;
            }
        }, {
            key: "_replaceAll",
            value: function _replaceAll(original, replacement, str) {
                original = original.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
                replacement = ("" + replacement).replace(/([$])/g, '$$$$');
                return str.replace(new RegExp(original, 'g'), replacement);
            }
        }]);
        return LocalizedStrings;
    }();

    module.exports = LocalizedStrings;
},10160,[10074],"projects/com.dreame.devices/main/CommonModules/LocalizedStrings.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = _require(_dependencyMap[1]);

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = _require(_dependencyMap[2]);

  var _tweener = _require(_dependencyMap[3]);

  var _tweener2 = babelHelpers.interopRequireDefault(_tweener);

  var deviceScreen = _reactNative.Dimensions.get('window');

  var DOUBLE_TAP_INTERVAL = 500;
  var TAP_DURATION = 250;
  var propsWhomRequireUpdate = ['closedDrawerOffset', 'openDrawerOffset', 'type', 'styles'];

  var Drawer = function (_Component) {
    babelHelpers.inherits(Drawer, _Component);

    function Drawer() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, Drawer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call.apply(_ref, [this].concat(args))), _this), _this.size = {
        width: deviceScreen.width,
        height: deviceScreen.height
      }, _this.initialize = function (props) {
        if (!_this._prevLength) {
          _this._prevLength = _this.size.height - props.openDrawerOffset;
        }

        _this.isOpen = true;
        var styles = {
          container: {
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center'
          }
        };
        styles.main = babelHelpers.extends({
          position: 'absolute',
          borderWidth: 0
        }, {
          left: 0,
          top: _this._prevLength
        }, _this.props.styles.main);
        styles.drawer = babelHelpers.extends({
          position: 'absolute',
          borderWidth: 0
        }, {
          left: 0
        }, _this.props.styles.drawer);
        styles.message = babelHelpers.extends({
          position: 'absolute',
          top: 0
        });

        if (_this.main) {
          _this.drawer.setNativeProps({
            style: {
              left: styles.drawer.left
            }
          });

          _this.main.setNativeProps({
            style: {
              top: styles.main.top
            }
          });

          _this.message.setNativeProps({
            style: {
              top: styles.message.top
            }
          });
        } else {
          _this.stylesheet = _reactNative.StyleSheet.create(styles);
          _this.responder = _reactNative.PanResponder.create({
            onStartShouldSetPanResponder: _this.onStartShouldSetPanResponder,
            onStartShouldSetPanResponderCapture: _this.onStartShouldSetPanResponderCapture,
            onMoveShouldSetPanResponder: _this.onMoveShouldSetPanResponder,
            onMoveShouldSetPanResponderCapture: _this.onMoveShouldSetPanResponderCapture,
            onPanResponderMove: _this.onPanResponderMove,
            onPanResponderRelease: _this.onPanResponderRelease,
            onPanResponderTerminate: _this.onPanResponderTerminate
          });
        }
      }, _this.onPanResponderTerminate = function (e, gestureState) {}, _this.onStartShouldSetPanResponderCapture = function (e, gestureState) {
        return false;
      }, _this.onStartShouldSetPanResponder = function (e, gestureState) {
        if (_this._activeTween) {
          return false;
        }

        gData.isTouch = true;
        return true;
      }, _this.onMoveShouldSetPanResponderCapture = function (e, gestureState) {
        var delta = gestureState.dy;

        if (Math.abs(delta) > 15 && !_this._activeTween) {
          return true;
        }

        return false;
      }, _this.onMoveShouldSetPanResponder = function (e, gestureState) {
        return false;
      }, _this.onPanResponderMove = function (e, gestureState) {
        gData.isTouch = true;
        var delta = gestureState.dy;
        var length = delta + _this._prevLength;

        if (length < _this.getClosedLength()) {
          length = _this.getClosedLength();
        } else if (length > _this.getOpenLength()) {
          length = _this.getOpenLength() + (length - _this.getOpenLength()) / 2;
        }

        _this._length = length;

        _this.updatePosition();
      }, _this.onPanResponderRelease = function (e, gestureState) {
        gData.isTouch = false;

        if (Math.abs(_this._length - _this.getClosedLength()) < 0.0001) {
          _this._prevLength = _this._length;
          _this.isOpen = false;
        } else if (_this._length > _this.getOpenLength()) {
          _this.open();
        } else {
          if (_this._length == _this.getOpenLength()) {
            _this.isOpen = true;
            _this._prevLength = _this._length;
            return;
          }

          if (gestureState.vy > 0) {
            var _y = Math.abs(_this.getOpenLength() - _this._length);

            _this.open({
              duration: _y
            });
          } else {
            var _y2 = Math.abs(_this.getClosedLength() - _this._length);

            _this.close({
              duration: _y2
            });
          }
        }
      }, _this.open = function (cfg) {
        var start = _this._length;

        var end = _this.getOpenLength();

        if (_this._activeTween || start == end) {
          return;
        }

        var duration = _this.props.tweenDuration;
        var end_ = end;

        if (cfg) {
          if (cfg.duration) {
            duration = cfg.duration;
          }

          if (cfg.springLen) {
            end_ = end + cfg.springLen * 2;
          }
        }

        _this._activeTween = (0, _tweener2.default)({
          start: start,
          end: end_,
          easingType: _this.props.tweenEasing,
          duration: duration,
          onFrame: function onFrame(tweenValue) {
            if (cfg && cfg.springLen) {
              if (tweenValue > end + cfg.springLen) {
                var value = 2 * (end + cfg.springLen) - tweenValue;
                _this._length = Math.round(value * 2) / 2;

                _this.updatePosition();

                return;
              }
            }

            _this._length = Math.round(tweenValue * 2) / 2;

            _this.updatePosition();
          },
          onEnd: function onEnd() {
            _this._activeTween = null;
            _this._prevLength = _this._length = end;
            _this.isOpen = true;

            _this.updatePosition();
          }
        });
      }, _this.close = function (cfg) {
        var start = _this._length;

        var end = _this.getClosedLength();

        if (_this._activeTween || start == end) {
          return;
        }

        var duration = _this.props.tweenDuration;
        var end_ = end;

        if (cfg) {
          if (cfg.duration) {
            duration = cfg.duration;
          }

          if (cfg.springLen) {
            end_ = end - cfg.springLen * 2;
          }
        }

        _this._activeTween = (0, _tweener2.default)({
          start: start,
          end: end_,
          easingType: _this.props.tweenEasing,
          duration: duration,
          onFrame: function onFrame(tweenValue) {
            if (cfg && cfg.springLen) {
              if (tweenValue < end - cfg.springLen) {
                var value = 2 * (end - cfg.springLen) - tweenValue;
                _this._length = Math.round(value * 2) / 2;

                _this.updatePosition();

                return;
              }
            }

            _this._length = Math.round(tweenValue * 2) / 2;

            _this.updatePosition();
          },
          onEnd: function onEnd() {
            _this._activeTween = null;
            _this._prevLength = _this._length;
            _this.isOpen = false;
          }
        });
      }, _this.updatePosition = function () {
        var mainProps = {};
        mainProps.top = _this._length;

        if (_this.main) {
          _this.main.setNativeProps({
            style: mainProps
          });
        }

        if (_this.drawerOverlay) {
          var alpha = (_this.getOpenLength() - _this._length) / _this.getOpenLength() * 0.14;

          _this.drawerOverlay.setNativeProps({
            style: {
              backgroundColor: "rgba(51,51,51," + alpha + ")"
            },
            pointerEvents: _this.getOpenLength() - _this._length <= 0 ? 'none' : 'auto'
          });
        }
      }, _this.getOpenLength = function () {
        return _this.size.height - _this.props.openDrawerOffset;
      }, _this.getClosedLength = function () {
        return _this.size.height - _this.mainHeight;
      }, _this.getMainWidth = function () {
        return _this.size.width;
      }, _this.getMainHeight = function () {
        return _this.mainHeight || _this.size.height;
      }, _this.getDrawerWidth = function () {
        return _this.size.width;
      }, _this.getDrawerHeight = function () {
        return _this.size.height;
      }, _this.getMessageWidth = function () {
        return _this.size.width;
      }, _this.getMessageHeight = function () {
        return _this.props.messageHeight || 60;
      }, _this.setSliderHeight = function (sliderHeight) {
        _this.sliderHeight = sliderHeight;
      }, _this.handleSetViewport = function (e) {
        var viewport = e.nativeEvent.layout;
        _this.size.width = viewport.width;
        _this.size.height = viewport.height;
        _this._prevLength = _this.size.height - _this.props.openDrawerOffset;

        _this.main.setNativeProps({
          style: {
            top: _this._prevLength
          }
        });
      }, _this.handleMainViewport = function (e) {
        var viewport = e.nativeEvent.layout;
        var lastmainHeight = _this.mainHeight;
        _this.mainHeight = viewport.height;

        if (_this.isOpen == false && Math.abs(lastmainHeight - _this.mainHeight) > 10) {
          if (Math.abs(_this._length - _this.getClosedLength()) > 0.01) {
            _this.close();
          }
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(Drawer, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.initialize(this.props);
      }
    }, {
      key: "setInteractionHandle",
      value: function setInteractionHandle() {
        if (this._interactionHandle) _reactNative.InteractionManager.clearInteractionHandle(this._interactionHandle);
        this._interactionHandle = _reactNative.InteractionManager.createInteractionHandle();
      }
    }, {
      key: "clearInteractionHandle",
      value: function clearInteractionHandle() {
        _reactNative.InteractionManager.clearInteractionHandle(this._interactionHandle);
      }
    }, {
      key: "render",
      value: function render() {
        var first = this.renderDrawer();
        var second = this.renderMain();
        var third = this.renderMessage();
        return _react2.default.createElement(
          _reactNative.View,
          {
            key: "drawerContainer",
            onLayout: this.handleSetViewport,
            style: this.stylesheet.container
          },
          first,
          second,
          third
        );
      }
    }, {
      key: "renderMain",
      value: function renderMain() {
        var _this2 = this;

        return _react2.default.createElement(
          _reactNative.View,
          babelHelpers.extends({}, this.responder.panHandlers, {
            key: "main",
            onLayout: this.handleMainViewport,
            ref: function ref(c) {
              return _this2.main = c;
            },
            style: [this.stylesheet.main, {
              width: this.getMainWidth()
            }]
          }),
          this.props.children
        );
      }
    }, {
      key: "renderDrawer",
      value: function renderDrawer() {
        var _this3 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            key: "drawer",
            ref: function ref(c) {
              return _this3.drawer = c;
            },
            style: [this.stylesheet.drawer, {
              height: this.getDrawerHeight(),
              width: this.getDrawerWidth()
            }]
          },
          this.props.content,
          _react2.default.createElement(
            _reactNative.TouchableWithoutFeedback,
            {
              onPress: this.open
            },
            _react2.default.createElement(_reactNative.View, {
              pointerEvents: "none",
              ref: function ref(c) {
                return _this3.drawerOverlay = c;
              },
              style: styles.overlay
            })
          )
        );
      }
    }, {
      key: "renderMessage",
      value: function renderMessage() {
        var _this4 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            key: "message",
            ref: function ref(c) {
              return _this4.message = c;
            },
            style: [this.stylesheet.message, {
              height: this.getMessageHeight(),
              width: this.getMessageWidth()
            }]
          },
          this.props.message
        );
      }
    }]);
    return Drawer;
  }(_react.Component);

  Drawer.propTypes = {
    content: _propTypes2.default.node,
    children: _propTypes2.default.node,
    openDrawerOffset: _propTypes2.default.number
  };
  Drawer.defaultProps = {
    tweenHandler: null,
    tweenDuration: 250,
    tweenEasing: 'linear'
  };
  exports.default = Drawer;

  var styles = _reactNative.StyleSheet.create({
    overlay: {
      right: 0,
      left: 0,
      top: 0,
      bottom: 0,
      position: 'absolute',
      backgroundColor: 'transparent'
    }
  });
},10163,[10297,10318,10033,10166],"projects/com.dreame.devices/main/Drawer/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
	var easingTypes = _require(_dependencyMap[0]);

	module.exports = function (config) {
		return new Tween(config);
	};

	function Tween(config) {
		this._rafLoop = this._rafLoop.bind(this);
		this.terminate = this.terminate.bind(this);
		this._t0 = Date.now();
		this._config = config;

		this._rafLoop();
	}

	Tween.prototype._rafLoop = function () {
		if (this._break) {
			return;
		}

		var _config = this._config,
		    duration = _config.duration,
		    start = _config.start,
		    end = _config.end,
		    easingType = _config.easingType;
		var now = Date.now();
		var elapsed = now - this._t0;

		if (elapsed >= duration) {
			this._config.onFrame(end);

			this._config.onEnd();

			return;
		}

		var tweenVal = easingTypes[easingType](elapsed, start, end, duration);

		this._config.onFrame(tweenVal);

		requestAnimationFrame(this._rafLoop);
	};

	Tween.prototype.terminate = function () {
		this._break = true;
	};
},10166,[10169],"projects/com.dreame.devices/main/Drawer/tweener.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  var tweenFunctions = {
    linear: function linear(t, b, _c, d) {
      var c = _c - b;
      return c * t / d + b;
    },
    easeInQuad: function easeInQuad(t, b, _c, d) {
      var c = _c - b;
      return c * (t /= d) * t + b;
    },
    easeOutQuad: function easeOutQuad(t, b, _c, d) {
      var c = _c - b;
      return -c * (t /= d) * (t - 2) + b;
    },
    easeInOutQuad: function easeInOutQuad(t, b, _c, d) {
      var c = _c - b;

      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      } else {
        return -c / 2 * (--t * (t - 2) - 1) + b;
      }
    },
    easeInCubic: function easeInCubic(t, b, _c, d) {
      var c = _c - b;
      return c * (t /= d) * t * t + b;
    },
    easeOutCubic: function easeOutCubic(t, b, _c, d) {
      var c = _c - b;
      return c * ((t = t / d - 1) * t * t + 1) + b;
    },
    easeInOutCubic: function easeInOutCubic(t, b, _c, d) {
      var c = _c - b;

      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t + b;
      } else {
        return c / 2 * ((t -= 2) * t * t + 2) + b;
      }
    },
    easeInQuart: function easeInQuart(t, b, _c, d) {
      var c = _c - b;
      return c * (t /= d) * t * t * t + b;
    },
    easeOutQuart: function easeOutQuart(t, b, _c, d) {
      var c = _c - b;
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },
    easeInOutQuart: function easeInOutQuart(t, b, _c, d) {
      var c = _c - b;

      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t + b;
      } else {
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
      }
    },
    easeInQuint: function easeInQuint(t, b, _c, d) {
      var c = _c - b;
      return c * (t /= d) * t * t * t * t + b;
    },
    easeOutQuint: function easeOutQuint(t, b, _c, d) {
      var c = _c - b;
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    easeInOutQuint: function easeInOutQuint(t, b, _c, d) {
      var c = _c - b;

      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t * t + b;
      } else {
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
      }
    },
    easeInSine: function easeInSine(t, b, _c, d) {
      var c = _c - b;
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    },
    easeOutSine: function easeOutSine(t, b, _c, d) {
      var c = _c - b;
      return c * Math.sin(t / d * (Math.PI / 2)) + b;
    },
    easeInOutSine: function easeInOutSine(t, b, _c, d) {
      var c = _c - b;
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    },
    easeInExpo: function easeInExpo(t, b, _c, d) {
      var c = _c - b;
      return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    },
    easeOutExpo: function easeOutExpo(t, b, _c, d) {
      var c = _c - b;
      return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    },
    easeInOutExpo: function easeInOutExpo(t, b, _c, d) {
      var c = _c - b;

      if (t === 0) {
        return b;
      }

      if (t === d) {
        return b + c;
      }

      if ((t /= d / 2) < 1) {
        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
      } else {
        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
      }
    },
    easeInCirc: function easeInCirc(t, b, _c, d) {
      var c = _c - b;
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    },
    easeOutCirc: function easeOutCirc(t, b, _c, d) {
      var c = _c - b;
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    },
    easeInOutCirc: function easeInOutCirc(t, b, _c, d) {
      var c = _c - b;

      if ((t /= d / 2) < 1) {
        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
      } else {
        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
      }
    },
    easeInElastic: function easeInElastic(t, b, _c, d) {
      var c = _c - b;
      var a, p, s;
      s = 1.70158;
      p = 0;
      a = c;

      if (t === 0) {
        return b;
      } else if ((t /= d) === 1) {
        return b + c;
      }

      if (!p) {
        p = d * 0.3;
      }

      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }

      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },
    easeOutElastic: function easeOutElastic(t, b, _c, d) {
      var c = _c - b;
      var a, p, s;
      s = 1.70158;
      p = 0;
      a = c;

      if (t === 0) {
        return b;
      } else if ((t /= d) === 1) {
        return b + c;
      }

      if (!p) {
        p = d * 0.3;
      }

      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }

      return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
    },
    easeInOutElastic: function easeInOutElastic(t, b, _c, d) {
      var c = _c - b;
      var a, p, s;
      s = 1.70158;
      p = 0;
      a = c;

      if (t === 0) {
        return b;
      } else if ((t /= d / 2) === 2) {
        return b + c;
      }

      if (!p) {
        p = d * 0.44999999999999996;
      }

      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }

      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
      } else {
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
      }
    },
    easeInBack: function easeInBack(t, b, _c, d, s) {
      var c = _c - b;

      if (s === void 0) {
        s = 1.70158;
      }

      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    easeOutBack: function easeOutBack(t, b, _c, d, s) {
      var c = _c - b;

      if (s === void 0) {
        s = 1.70158;
      }

      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    easeInOutBack: function easeInOutBack(t, b, _c, d, s) {
      var c = _c - b;

      if (s === void 0) {
        s = 1.70158;
      }

      if ((t /= d / 2) < 1) {
        return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
      } else {
        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
      }
    },
    easeInBounce: function easeInBounce(t, b, _c, d) {
      var c = _c - b;
      var v;
      v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
      return c - v + b;
    },
    easeOutBounce: function easeOutBounce(t, b, _c, d) {
      var c = _c - b;

      if ((t /= d) < 0.36363636363636365) {
        return c * (7.5625 * t * t) + b;
      } else if (t < 0.7272727272727273) {
        return c * (7.5625 * (t -= 0.5454545454545454) * t + 0.75) + b;
      } else if (t < 0.9090909090909091) {
        return c * (7.5625 * (t -= 0.8181818181818182) * t + 0.9375) + b;
      } else {
        return c * (7.5625 * (t -= 0.9545454545454546) * t + 0.984375) + b;
      }
    },
    easeInOutBounce: function easeInOutBounce(t, b, _c, d) {
      var c = _c - b;
      var v;

      if (t < d / 2) {
        v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
        return v * 0.5 + b;
      } else {
        v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
        return v * 0.5 + c * 0.5 + b;
      }
    }
  };
  module.exports = tweenFunctions;
},10169,[],"node_modules/tween-functions/index.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _propTypes = _require(_dependencyMap[1]);

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _reactNative = _require(_dependencyMap[2]);

  var _tweener = _require(_dependencyMap[3]);

  var _tweener2 = babelHelpers.interopRequireDefault(_tweener);

  var deviceScreen = _reactNative.Dimensions.get('window');

  var DOUBLE_TAP_INTERVAL = 500;
  var TAP_DURATION = 250;
  var propsWhomRequireUpdate = ['closedDrawerOffset', 'openDrawerOffset', 'type', 'styles'];

  var Drawer = function (_Component) {
    babelHelpers.inherits(Drawer, _Component);

    function Drawer() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, Drawer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call.apply(_ref, [this].concat(args))), _this), _this.size = {
        width: deviceScreen.width,
        height: deviceScreen.height
      }, _this.initialize = function (props) {
        if (!_this._prevLength) {
          _this._prevLength = _this.size.height - props.openDrawerOffset;
        }

        _this.isOpen = true;
        var styles = {
          container: {
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center'
          }
        };
        styles.main = babelHelpers.extends({
          position: 'absolute',
          borderWidth: 0
        }, {
          left: 0,
          top: _this._prevLength
        }, _this.props.styles.main);
        styles.drawer = babelHelpers.extends({
          position: 'absolute',
          borderWidth: 0
        }, {
          left: 0
        }, _this.props.styles.drawer);
        styles.message = babelHelpers.extends({
          position: 'absolute',
          top: 0
        });

        if (_this.main) {
          _this.drawer.setNativeProps({
            style: {
              left: styles.drawer.left
            }
          });

          _this.main.setNativeProps({
            style: {
              top: styles.main.top
            }
          });

          _this.message.setNativeProps({
            style: {
              top: styles.message.top
            }
          });
        } else {
          _this.stylesheet = _reactNative.StyleSheet.create(styles);
          _this.responder = _reactNative.PanResponder.create({
            onStartShouldSetPanResponder: _this.onStartShouldSetPanResponder,
            onStartShouldSetPanResponderCapture: _this.onStartShouldSetPanResponderCapture,
            onMoveShouldSetPanResponder: _this.onMoveShouldSetPanResponder,
            onMoveShouldSetPanResponderCapture: _this.onMoveShouldSetPanResponderCapture,
            onPanResponderMove: _this.onPanResponderMove,
            onPanResponderRelease: _this.onPanResponderRelease,
            onPanResponderTerminate: _this.onPanResponderTerminate
          });
        }
      }, _this.onPanResponderTerminate = function (e, gestureState) {}, _this.onStartShouldSetPanResponderCapture = function (e, gestureState) {
        return false;
      }, _this.onStartShouldSetPanResponder = function (e, gestureState) {
        if (_this._activeTween) {
          return false;
        }

        gData.isTouch = true;
        return true;
      }, _this.onMoveShouldSetPanResponderCapture = function (e, gestureState) {
        var delta = gestureState.dy;

        if (Math.abs(delta) > 15 && !_this._activeTween) {
          return true;
        }

        return false;
      }, _this.onMoveShouldSetPanResponder = function (e, gestureState) {
        return false;
      }, _this.onPanResponderMove = function (e, gestureState) {
        gData.isTouch = true;
        var delta = gestureState.dy;
        var length = delta + _this._prevLength;

        if (length < _this.getClosedLength()) {
          length = _this.getClosedLength();
        } else if (length > _this.getOpenLength()) {
          length = _this.getOpenLength() + (length - _this.getOpenLength()) / 2;
        }

        _this._length = length;

        _this.updatePosition();
      }, _this.onPanResponderRelease = function (e, gestureState) {
        gData.isTouch = false;

        if (Math.abs(_this._length - _this.getClosedLength()) < 0.0001) {
          _this._prevLength = _this._length;
          _this.isOpen = false;
        } else if (_this._length > _this.getOpenLength()) {
          _this.open();
        } else {
          if (_this._length == _this.getOpenLength()) {
            _this.isOpen = true;
            _this._prevLength = _this._length;
            return;
          }

          var vy = Math.abs(gestureState.vy);

          if (vy < 0.3) {
            _this._prevLength = _this._length;
          } else {
            if (gestureState.vy > 0) {
              var _y = Math.abs(_this.getOpenLength() - _this._length);

              _this.open({
                duration: _y
              });
            } else {
              var _y2 = Math.abs(_this.getClosedLength() - _this._length);

              _this.close({
                duration: _y2
              });
            }
          }
        }
      }, _this.open = function (cfg) {
        var start = _this._length;

        var end = _this.getOpenLength();

        if (_this._activeTween || start == end) {
          return;
        }

        var duration = _this.props.tweenDuration;
        var end_ = end;

        if (cfg) {
          if (cfg.duration) {
            duration = cfg.duration;
          }

          if (cfg.springLen) {
            end_ = end + cfg.springLen * 2;
          }
        }

        _this._activeTween = (0, _tweener2.default)({
          start: start,
          end: end_,
          easingType: _this.props.tweenEasing,
          duration: duration,
          onFrame: function onFrame(tweenValue) {
            if (cfg && cfg.springLen) {
              if (tweenValue > end + cfg.springLen) {
                var value = 2 * (end + cfg.springLen) - tweenValue;
                _this._length = Math.round(value * 2) / 2;

                _this.updatePosition();

                return;
              }
            }

            _this._length = Math.round(tweenValue * 2) / 2;

            _this.updatePosition();
          },
          onEnd: function onEnd() {
            _this._activeTween = null;
            _this._prevLength = _this._length = end;
            _this.isOpen = true;

            _this.updatePosition();
          }
        });
      }, _this.close = function (cfg) {
        var start = _this._length;

        var end = _this.getClosedLength();

        if (_this._activeTween || start == end) {
          return;
        }

        var duration = _this.props.tweenDuration;
        var end_ = end;

        if (cfg) {
          if (cfg.duration) {
            duration = cfg.duration;
          }

          if (cfg.springLen) {
            end_ = end - cfg.springLen * 2;
          }
        }

        _this._activeTween = (0, _tweener2.default)({
          start: start,
          end: end_,
          easingType: _this.props.tweenEasing,
          duration: duration,
          onFrame: function onFrame(tweenValue) {
            if (cfg && cfg.springLen) {
              if (tweenValue < end - cfg.springLen) {
                var value = 2 * (end - cfg.springLen) - tweenValue;
                _this._length = Math.round(value * 2) / 2;

                _this.updatePosition();

                return;
              }
            }

            _this._length = Math.round(tweenValue * 2) / 2;

            _this.updatePosition();
          },
          onEnd: function onEnd() {
            _this._activeTween = null;
            _this._prevLength = _this._length;
            _this.isOpen = false;
          }
        });
      }, _this.updatePosition = function () {
        var mainProps = {};
        mainProps.top = _this._length;

        if (_this.main) {
          _this.main.setNativeProps({
            style: mainProps
          });
        }

        if (_this.message) {
          var l = _this.getOpenLength();

          var messageOffset = (l * 9 / 10 - _this._length) / (2 * l / 5) * _this.getMessageHeight();

          if (messageOffset < 0 || isNaN(messageOffset)) {
            messageOffset = 0;
          } else if (messageOffset > _this.getMessageHeight()) {
            messageOffset = _this.getMessageHeight();
          }

          _this.message.setNativeProps({
            style: {
              top: -messageOffset
            }
          });
        }

        if (_this.drawerOverlay) {
          var alpha = (_this.getOpenLength() - _this._length) / _this.getOpenLength() * 0.14;

          _this.drawerOverlay.setNativeProps({
            style: {
              backgroundColor: "rgba(51,51,51," + alpha + ")"
            },
            pointerEvents: _this.getOpenLength() - _this._length <= 0 ? 'none' : 'auto'
          });
        }
      }, _this.getOpenLength = function () {
        return _this.size.height - _this.props.openDrawerOffset;
      }, _this.getClosedLength = function () {
        return _this.size.height - _this.mainHeight;
      }, _this.getMainWidth = function () {
        return _this.size.width;
      }, _this.getMainHeight = function () {
        return _this.mainHeight || _this.size.height;
      }, _this.getDrawerWidth = function () {
        return _this.size.width;
      }, _this.getDrawerHeight = function () {
        return _this.size.height;
      }, _this.getMessageWidth = function () {
        return _this.size.width;
      }, _this.getMessageHeight = function () {
        return _this.props.messageHeight || 60;
      }, _this.setSliderHeight = function (sliderHeight) {
        _this.sliderHeight = sliderHeight;
      }, _this.handleSetViewport = function (e) {
        var viewport = e.nativeEvent.layout;
        _this.size.width = viewport.width;
        _this.size.height = viewport.height;
        _this._prevLength = _this.size.height - _this.props.openDrawerOffset;

        _this.main.setNativeProps({
          style: {
            top: _this._prevLength
          }
        });
      }, _this.handleMainViewport = function (e) {
        var viewport = e.nativeEvent.layout;
        var lastmainHeight = _this.mainHeight;
        _this.mainHeight = viewport.height;

        if (_this.isOpen == false && Math.abs(lastmainHeight - _this.mainHeight) > 10) {
          if (Math.abs(_this._length - _this.getClosedLength()) > 0.01) {
            _this.close();
          }
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(Drawer, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.initialize(this.props);
      }
    }, {
      key: "setInteractionHandle",
      value: function setInteractionHandle() {
        if (this._interactionHandle) _reactNative.InteractionManager.clearInteractionHandle(this._interactionHandle);
        this._interactionHandle = _reactNative.InteractionManager.createInteractionHandle();
      }
    }, {
      key: "clearInteractionHandle",
      value: function clearInteractionHandle() {
        _reactNative.InteractionManager.clearInteractionHandle(this._interactionHandle);
      }
    }, {
      key: "render",
      value: function render() {
        var first = this.renderDrawer();
        var second = this.renderMain();
        var third = this.renderMessage();
        return _react2.default.createElement(
          _reactNative.View,
          {
            key: "drawerContainer",
            onLayout: this.handleSetViewport,
            style: this.stylesheet.container
          },
          first,
          second,
          third
        );
      }
    }, {
      key: "renderMain",
      value: function renderMain() {
        var _this2 = this;

        return _react2.default.createElement(
          _reactNative.View,
          babelHelpers.extends({}, this.responder.panHandlers, {
            key: "main",
            onLayout: this.handleMainViewport,
            ref: function ref(c) {
              return _this2.main = c;
            },
            style: [this.stylesheet.main, {
              width: this.getMainWidth()
            }]
          }),
          this.props.children
        );
      }
    }, {
      key: "renderDrawer",
      value: function renderDrawer() {
        var _this3 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            key: "drawer",
            ref: function ref(c) {
              return _this3.drawer = c;
            },
            style: [this.stylesheet.drawer, {
              height: this.getDrawerHeight(),
              width: this.getDrawerWidth()
            }]
          },
          this.props.content,
          _react2.default.createElement(
            _reactNative.TouchableWithoutFeedback,
            {
              onPress: this.open
            },
            _react2.default.createElement(_reactNative.View, {
              pointerEvents: "none",
              ref: function ref(c) {
                return _this3.drawerOverlay = c;
              },
              style: styles.overlay
            })
          )
        );
      }
    }, {
      key: "renderMessage",
      value: function renderMessage() {
        var _this4 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            key: "message",
            ref: function ref(c) {
              return _this4.message = c;
            },
            style: [this.stylesheet.message, {
              height: this.getMessageHeight(),
              width: this.getMessageWidth()
            }]
          },
          this.props.message
        );
      }
    }]);
    return Drawer;
  }(_react.Component);

  Drawer.propTypes = {
    content: _propTypes2.default.node,
    children: _propTypes2.default.node,
    openDrawerOffset: _propTypes2.default.number
  };
  Drawer.defaultProps = {
    tweenHandler: null,
    tweenDuration: 250,
    tweenEasing: 'linear'
  };
  exports.default = Drawer;

  var styles = _reactNative.StyleSheet.create({
    overlay: {
      right: 0,
      left: 0,
      top: 0,
      bottom: 0,
      position: 'absolute',
      backgroundColor: 'transparent'
    }
  });
},10172,[10297,10318,10033,10166],"projects/com.dreame.devices/main/Drawer/indexv2.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _glReact = _require(_dependencyMap[2]);

  var _glReact2 = babelHelpers.interopRequireDefault(_glReact);

  var _glReactNative = _require(_dependencyMap[3]);

  var _miot = _require(_dependencyMap[4]);

  var _reactNativeSvg = _require(_dependencyMap[5]);

  var _reactNativeSvg2 = babelHelpers.interopRequireDefault(_reactNativeSvg);

  var _buffer = _require(_dependencyMap[6]);

  var easingTypes = _require(_dependencyMap[7]);

  var shaders = _glReact2.default.Shaders.create({
    mapGL: {
      frag: "\nprecision highp float;\nvarying vec2 uv;\n\n\nuniform int spot;\nuniform vec2 spotPos;\nuniform vec2 dim;\nuniform sampler2D map;\nuniform vec2 mapSize;\nuniform vec2 offset;\nuniform vec2 robotPos;\nuniform vec2 mapPos;\n\nuniform sampler2D bg;\n\nuniform sampler2D robot;\nuniform sampler2D sleep;\nuniform sampler2D dock;\nuniform sampler2D line;\n// uniform sampler2D trace;\n\nuniform float widthGridNum;\nuniform float zoom;\nuniform float robotAngle;\nuniform float animScale;\nuniform float animAlpha;\nuniform vec2 sleep1;\nuniform float animScale2;\nuniform float animAlpha2;\nuniform vec2 sleep2;\n\nuniform int workMode;\nuniform int onCharge;\n\nuniform int charge;\nuniform vec2 chargePos;\nuniform float chargeAngel;\n\nuniform float minR;\n\nuniform float robotSize;\n\n// uniform buffer test;\n\n\n\nvoid main () {\n    float pieceWidth_ = dim.x/widthGridNum;\n    float pieceWidth = dim.x/widthGridNum*zoom;\n    vec2 mapSize_ = mapSize*pieceWidth;\n    float _widthGridNum = widthGridNum/zoom;\n    float heightGridNum = dim.y * _widthGridNum /dim.x;\n    float cx = 1.0/widthGridNum*zoom;\n    float cy = dim.x * cx / dim.y;\n    // vec2 mapPos = vec2((widthGridNum-mapSize.x)*pieceWidth_/2.0,( dim.y * widthGridNum /dim.x-mapSize.y)*pieceWidth_/2.0);\n\n    vec2 startMap = (mapPos+offset) / dim;\n    vec2 endMap = (mapPos+offset+mapSize_) / dim;\n\n\n    float bw = 1.0/26.0;\n    float bh = dim.x/dim.y * bw;\n\n    vec4 mapColor = vec4(0.0,0.0,0.0,0.0);\n    \n    gl_FragColor = texture2D(bg, vec2(fract(uv.x/bw),fract(uv.y/bh)));\n    // gl_FragColor = texture2D(bg,uv);\n    if(uv.x<startMap.x||uv.x>endMap.x||uv.y<startMap.y||uv.y>endMap.y){\n        // gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n    }else{\n        float xnum = (uv.x-startMap.x) / cx;\n        float xmin = floor(xnum);\n    \n        float ynum = (uv.y-startMap.y) / cy;\n        float ymin = floor(ynum);\n        mapColor = texture2D(map, vec2((xmin+0.5)/mapSize.x,(ymin+0.5)/mapSize.y));\n        \n        gl_FragColor = vec4(mix(gl_FragColor.rgb,mapColor.rgb,mapColor.a),1.0);\n\n        // gl_FragColor = texture2D(map, vec2((xmin+0.5)/mapSize.x,(ymin+0.5)/mapSize.y));\n        // vec4 tracec = texture2D(trace,(uv-startMap)/(endMap-startMap));\n        // gl_FragColor = vec4(mix(gl_FragColor.rgb,tracec.rgb,tracec.a),1.0);\n\n    }\n\n    float robotR = pieceWidth*robotSize/2.0;\n    if(robotR<minR){\n      robotR = minR;\n    }\n    vec2 _robotPos = robotPos*mapSize_+mapPos+offset;\n    // robotR = robotR * 1.40625;\n    if(charge == 1){\n        vec2 _chargePos = chargePos*mapSize_+mapPos+offset;\n        float cr =  distance(uv*dim,_chargePos);\n        // vec2 cr = abs(uv*dim - _chargePos);\n        // // float robotR = 10.0*zoom;\n        // if(cr.x<robotR && cr.y<robotR){\n        //   mat2 rotation = mat2(cos(chargeAngel), -sin(chargeAngel), sin(chargeAngel), cos(chargeAngel));\n        //   vec2 p = ((uv*dim-(_chargePos-robotR))/(robotR*2.0) - vec2(0.5)) * rotation + vec2(0.5);\n        //   vec4 rc = texture2D(dock,p); \n        //   gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n        // //  gl_FragColor = vec4(0.5,0.5,0.0,1.0);\n        // }\n        float chargeR = robotR * 1.40625;\n        if(cr<chargeR){\n          mat2 rotation = mat2(cos(chargeAngel), -sin(chargeAngel), sin(chargeAngel), cos(chargeAngel));\n          vec2 p = ((uv*dim-(_chargePos-chargeR))/(chargeR*2.0) - vec2(0.5)) * rotation + vec2(0.5);\n          vec4 rc = texture2D(dock,p); \n          gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n        //  gl_FragColor = vec4(0.5,0.5,0.0,1.0);\n        }\n\n        if(onCharge == 1){\n          float c_r = robotR * 1.0;\n          _robotPos[0] = _chargePos[0] + cos(-chargeAngel) * c_r;\n          _robotPos[1] = _chargePos[1] + sin(-chargeAngel) * c_r;\n        }\n    }\n    \n    // vec2 _robotPos = robotPos*mapSize_+mapPos+offset;\n\n    float r =  distance(uv*dim,_robotPos);\n\n    \n    if(workMode == 1){\n      if(r<animScale*robotR){\n        vec4 anim = vec4(1.0,1.0,1.0,0.7*animAlpha*r/animScale/robotR);\n        gl_FragColor = vec4(mix(gl_FragColor.rgb,anim.rgb,anim.a),1.0);\n      } \n    }else if(workMode == 2){\n      if(r<animScale*robotR){\n        vec4 anim = vec4(0.07,1.0,0.0,0.4*animAlpha*r/animScale/robotR);\n        gl_FragColor = vec4(mix(gl_FragColor.rgb,anim.rgb,anim.a),1.0);\n      } \n    }else if(workMode == 3){\n      if(r<animScale*robotR){\n        vec4 anim = vec4(1.0,0.66,0.114,1.0*animAlpha*r/animScale/robotR);\n        gl_FragColor = vec4(mix(gl_FragColor.rgb,anim.rgb,anim.a),1.0);\n      } \n    }else if(workMode == 4){\n      vec2 startSleep1 = _robotPos + vec2(0.8*robotR) + sleep1*15.0;\n      vec2 cr = abs(uv*dim - startSleep1);\n      float sr = 5.0 * animScale;\n      if(cr.x<sr && cr.y<sr){\n        vec2 p = (uv*dim-(startSleep1-sr))/(sr*2.0);\n        vec4 rc = texture2D(sleep,p); \n        if(rc.a>=0.8){\n          gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a*animAlpha),1.0);\n        }\n        \n      }\n\n      vec2 startSleep2 = _robotPos + vec2(1.0*robotR,0.0) + sleep2*15.0;\n      cr = abs(uv*dim - startSleep2);\n      sr = 4.0 * animScale2;\n      if(cr.x<sr && cr.y<sr){\n        vec2 p = (uv*dim-(startSleep2-sr))/(sr*2.0);\n        vec4 rc = texture2D(sleep,p); \n        if(rc.a>=0.8){\n           gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a*animAlpha2),1.0);\n        }\n      }\n    }\n    \n    if(r<robotR){\n      mat2 rotation = mat2(cos(robotAngle), -sin(robotAngle), sin(robotAngle), cos(robotAngle));\n      vec2 p = ((uv*dim-(_robotPos-robotR))/(robotR*2.0) - vec2(0.5)) * rotation + vec2(0.5);\n      vec4 rc = texture2D(robot,p); \n      gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n    //  gl_FragColor = vec4(0.5,0.5,0.0,1.0);\n    }\n    \n    if(spot == 1){\n        vec2 _spotPos = spotPos*mapSize_+mapPos+offset;\n        vec2 uv_ = uv*dim;\n        vec2 dis = abs(uv_-_spotPos);\n        float side = 15.0*pieceWidth;\n        float spotCell = 3.0*pieceWidth;\n\n        if(dis.x<side&&dis.y<side){\n          vec4 rc = vec4(0.0,0.0,0.0,0.2); \n          vec2 spotUV = mod(uv_-_spotPos+vec2(side),spotCell)/spotCell;\n          if(mapColor.a<0.000001){\n            rc = texture2D(line,spotUV); \n          }\n          float lineW = side-2.5;\n          if(dis.x>lineW||dis.y>lineW){\n            rc = vec4(0.5,0.5,0.5,1.0); \n          }\n          gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n          \n        }\n         float r =  distance(uv*dim,_spotPos);\n         if(r<10.0){\n          gl_FragColor = vec4(0.5,1.0,0.5,1.0);\n          // gl_FragColor = vec4(test[0],test[1],test[2],1.0);\n         }    \n    }\n\n}\n    "
    }
  });

  var base64ImageData = "iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAC0lEQVR4AWOgAgAAAEQAAZ+iuIQAAAAASUVORK5CYII=";
  var Action = {
    ACTION_NONE: 0,
    ACTION_DOWN: 1,
    ACTION_CLICK: 2,
    ACTION_MOVE: 3,
    ACTION_ZOOM: 4,
    ACTION_DOUBLE_CLICK: 5
  };
  var MapType = {
    TYPE_NONE: 0,
    TYPE_SPOT: 1,
    TYPE_AREA: 2
  };

  var CleanMap = function (_React$Component) {
    babelHelpers.inherits(CleanMap, _React$Component);

    function CleanMap(props) {
      babelHelpers.classCallCheck(this, CleanMap);

      var _this = babelHelpers.possibleConstructorReturn(this, (CleanMap.__proto__ || Object.getPrototypeOf(CleanMap)).call(this, props));

      _initialiseProps.call(_this);

      _this.initialize(props);

      return _this;
    }

    babelHelpers.createClass(CleanMap, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var _this2 = this;

        this.executor = null;

        _miot.Host.createBackgroundExecutor(_require(_dependencyMap[8]), {
          name1: "testName"
        }).then(function (executor) {
          console.log("-----------");
          _this2.executor = executor;
        }).then(function (err) {});
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.lastClickEvent) {
          clearTimeout(this.lastClickEvent);
          this.lastClickEvent = null;
        }

        this.executor && this.executor.remove();
        stopAnimation();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {}
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            width = _props.width,
            height = _props.height;

        if (!this.state) {
          return null;
        }

        var curveLine = this.state.tracePath;
        this.state.size = {
          width: width,
          height: height
        };

        if (this.state.dim[0] != width || this.state.dim[1] != height) {
          this.state.dim[0] = width;
          this.state.dim[1] = height;
        }

        var workMode = this.deviceStatus;
        var _state = this.state,
            spot = _state.spot,
            dim = _state.dim,
            map = _state.map,
            mapSize = _state.mapSize,
            offset = _state.offset,
            zoom = _state.zoom,
            robotPos = _state.robotPos,
            mapPos = _state.mapPos,
            robotAngle = _state.robotAngle,
            widthGridNum = _state.widthGridNum,
            charge = _state.charge,
            chargePos = _state.chargePos,
            chargeAngel = _state.chargeAngel,
            animScale = _state.animScale,
            animAlpha = _state.animAlpha,
            sleep1 = _state.sleep1,
            sleep2 = _state.sleep2,
            animScale2 = _state.animScale2,
            onCharge = _state.onCharge,
            animAlpha2 = _state.animAlpha2;
        var spotPos = this.mapDataUtil.convertSpotPosToMap(this.state.spotPos);
        var bg = this.bg;
        var robot = this.robot;
        var dock = this.dock;
        var sleep = this.sleep;
        var line = this.line;
        var minR = 60 * Const.onePixel / 2;
        var rSize = 9.333333333333334;

        if (this.gridWidth) {
          rSize = 443.33333333333326 / this.gridWidth;
        }

        var robotSize = rSize;
        return _react2.default.createElement(
          _reactNative.View,
          null,
          _react2.default.createElement(
            _glReactNative.Surface,
            babelHelpers.extends({
              ref: "surface",
              style: {
                backgroundColor: "#000"
              },
              autoRedraw: true,
              preload: true
            }, this._panResponder.panHandlers, {
              width: width,
              height: height
            }),
            _react2.default.createElement(_glReact2.default.Node, {
              shader: shaders.mapGL,
              uniforms: {
                dim: dim,
                spot: spot,
                spotPos: spotPos,
                map: map,
                mapSize: mapSize,
                offset: offset,
                zoom: zoom,
                robotPos: robotPos,
                robot: robot,
                mapPos: mapPos,
                bg: bg,
                robotAngle: robotAngle,
                sleep: sleep,
                sleep1: sleep1,
                animAlpha: animAlpha,
                animScale: animScale,
                sleep2: sleep2,
                animScale2: animScale2,
                animAlpha2: animAlpha2,
                workMode: workMode,
                charge: charge,
                chargePos: chargePos,
                chargeAngel: chargeAngel,
                minR: minR,
                dock: dock,
                line: line,
                robotSize: robotSize,
                onCharge: onCharge,
                widthGridNum: widthGridNum
              }
            })
          )
        );
      }
    }]);
    return CleanMap;
  }(_react2.default.Component);

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.initialize = function (props) {
      _this3.mapDataUtil = props.mapDataUtil;
      _this3.mapType = MapType.TYPE_NONE;

      _this3.mapDataUtil.setMapChangeListener(_this3.onMapChange);

      _this3.openDrawerOffset = props.openDrawerOffset;
      _this3.cleanInfoHeight = props.cleanInfoHeight;
      _this3.state = {
        spot: 0,
        spotPos: [0, 0],
        dim: [props.width, props.height],
        map: {
          uri: "data:image/png;base64," + base64ImageData
        },
        mapSize: [4, 4],
        offset: [0, 0],
        mapPos: _this3.calculateMapPos(100, [4, 4]),
        robotPos: [0.0, 0.0],
        zoom: 1.0,
        robotAngle: -0.0 * 2 * Math.PI,
        animScale: 0.0,
        animAlpha: 0.0,
        tracePath: null,
        charge: 0,
        chargePos: [0, 0],
        chargeAngel: 0,
        workMode: 0,
        sleep1: [0.0, 0.0],
        sleep2: [0, 0],
        animScale2: 0,
        animAlpha2: 0,
        onCharge: 0,
        widthGridNum: 100
      };
      _this3.action = Action.ACTION_NONE;
      _this3.bg = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[9]));
      _this3.robot = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[10]));
      _this3.charging = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[11]));
      _this3.cleaning = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[12]));
      _this3.dock = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[13]));
      _this3.line = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[14]));
      _this3.sleep = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[15]));
      _this3.t0 = Date.now();
      _this3.deviceStatus = 0;
      _this3.startAnim = false;
      _this3._panResponder = _reactNative.PanResponder.create({
        onStartShouldSetPanResponder: function onStartShouldSetPanResponder(evt, gestureState) {
          _this3.action = Action.ACTION_DOWN;
          _this3.distance = -1;
          _this3.lastPos = null;
          gData.isTouch = true;
          return true;
        },
        onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture(evt, gestureState) {
          _this3.action = Action.ACTION_DOWN;
          _this3.distance = -1;
          _this3.lastPos = null;
          return false;
        },
        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {
          return false;
        },
        onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture(evt, gestureState) {
          if (gestureState.numberActiveTouches == 2) {
            _this3.action = Action.ACTION_ZOOM;
            _this3.distance = _this3.calculateDistance(evt.nativeEvent.touches);
            return true;
          } else if (gestureState.numberActiveTouches == 1) {
            var delta = 15;

            if (Math.abs(gestureState.dy) > delta || Math.abs(gestureState.dx) > delta) {
              _this3.lastPos = {
                x: gestureState.moveX,
                y: gestureState.moveY
              };
              _this3.action = Action.ACTION_MOVE;
              return true;
            }
          }

          return false;
        },
        onPanResponderGrant: function onPanResponderGrant(evt, gestureState) {},
        onPanResponderMove: function onPanResponderMove(evt, gestureState) {
          if (gestureState.numberActiveTouches == 2) {
            var currentDis = _this3.calculateDistance(evt.nativeEvent.touches);

            if (_this3.action == Action.ACTION_ZOOM) {
              var zoom = currentDis / _this3.distance * _this3.state.zoom;

              if (zoom > 2) {
                zoom = 2;
              }

              if (zoom < 0.5) {
                zoom = 0.5;
              }

              var x_ = (zoom - _this3.state.zoom) * (_this3.state.mapSize[0] * _this3.props.width / _this3.state.widthGridNum) / 2;
              var y_ = (zoom - _this3.state.zoom) * (_this3.state.mapSize[1] * _this3.props.width / _this3.state.widthGridNum) / 2;
              var newOffset = [_this3.state.offset[0] - x_, _this3.state.offset[1] - y_];
              newOffset = _this3.calculateOffset(zoom, newOffset);

              _this3.updateState({
                zoom: zoom,
                offset: newOffset
              });

              _this3.distance = currentDis;
            } else {
              _this3.action = Action.ACTION_ZOOM;
              _this3.distance = currentDis;
            }
          } else if (gestureState.numberActiveTouches == 1) {
            if (_this3.action == Action.ACTION_MOVE) {
              var currentPos = {
                x: gestureState.moveX,
                y: gestureState.moveY
              };
              var delay = {
                x: currentPos.x - _this3.lastPos.x,
                y: currentPos.y - _this3.lastPos.y
              };
              var _newOffset = [_this3.state.offset[0] + delay.x, _this3.state.offset[1] - delay.y];
              _newOffset = _this3.calculateOffset(_this3.state.zoom, _newOffset);

              _this3.updateState({
                offset: _newOffset
              });

              _this3.lastPos = currentPos;
            } else if (_this3.action == Action.ACTION_ZOOM) {
              _this3.lastPos = {
                x: gestureState.moveX,
                y: gestureState.moveY
              };
              _this3.action = Action.ACTION_MOVE;
            } else {
              var delta = 15;

              if (Math.abs(gestureState.dy) > delta || Math.abs(gestureState.dx) > delta) {
                _this3.lastPos = {
                  x: gestureState.moveX,
                  y: gestureState.moveY
                };
                _this3.action = Action.ACTION_MOVE;
              }
            }
          } else if (gestureState.numberActiveTouches > 2) {
            _this3.action = Action.ACTION_NONE;
          }
        },
        onPanResponderTerminationRequest: function onPanResponderTerminationRequest(evt, gestureState) {
          return true;
        },
        onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {
          gData.isTouch = false;

          if (_this3.action == Action.ACTION_DOWN) {
            var currentTime = Date.now();

            if (_this3.lastAction == Action.ACTION_CLICK && currentTime - _this3.lastClickTime < 200) {
              _this3.lastAction = Action.ACTION_DOUBLE_CLICK;

              if (_this3.lastClickEvent) {
                clearTimeout(_this3.lastClickEvent);
                _this3.lastClickEvent = null;
              }

              _this3.updateState({
                zoom: 1.0,
                offset: [0, 0]
              });
            } else {
              _this3.lastAction = Action.ACTION_CLICK;
              _this3.lastClickPos = {
                x: evt.nativeEvent.locationX,
                y: evt.nativeEvent.locationY
              };
              _this3.lastClickEvent = setTimeout(_this3.onClickMap, 250);
            }

            _this3.lastClickTime = currentTime;
          } else {
            _this3.lastAction = Action.ACTION_NONE;
          }
        },
        onPanResponderTerminate: function onPanResponderTerminate(evt, gestureState) {},
        onShouldBlockNativeResponder: function onShouldBlockNativeResponder(evt, gestureState) {
          return true;
        }
      });
    };

    this.setDeviceStatus = function (deviceStatus) {
      if (_this3.deviceStatus != deviceStatus) {
        _this3.deviceStatus = deviceStatus;
        _this3.t0 = Date.now();
      }

      if (_this3.props.checkFocused) {
        if (_this3.props.checkFocused() == false) {
          return;
        }
      }

      if (_this3.deviceStatus == 0 && _this3.startAnim == true) {
        _this3.startAnim = false;
      } else if (_this3.deviceStatus != 0 && _this3.startAnim == false) {
        _this3.startAnim = true;
        requestAnimationFrame(_this3._rafLoop);
      }
    };

    this.setType = function (type) {
      _this3.mapType = type;

      if (_this3.mapType == Const.MAP_EDIT_TYPE_NULL) {
        _this3.updateState({
          spot: 0
        });
      }
    };

    this.calculateMapPos = function (widthGridNum, mapSize) {
      var pieceWidth_ = _this3.props.width / widthGridNum;
      var mapPos = {
        x: (widthGridNum - mapSize[0]) * pieceWidth_ / 2.0,
        y: ((_this3.props.height - _this3.openDrawerOffset - _this3.cleanInfoHeight) * widthGridNum / _this3.props.width - mapSize[1]) * pieceWidth_ / 2.0 + _this3.openDrawerOffset
      };
      return [mapPos.x, mapPos.y];
    };

    this.onClickMap = function () {
      var widthGridNum = _this3.state.widthGridNum;
      var pieceWidth_ = _this3.props.width / widthGridNum;
      var pieceWidth = pieceWidth_ * _this3.state.zoom;
      var mapSize = {
        w: _this3.state.mapSize[0] * pieceWidth,
        h: _this3.state.mapSize[1] * pieceWidth
      };

      var mapPosArr = _this3.calculateMapPos(widthGridNum, _this3.state.mapSize);

      var mapPos = {
        x: mapPosArr[0],
        y: mapPosArr[1]
      };
      var startMap = {
        x: _this3.state.offset[0] + mapPos.x,
        y: _this3.state.offset[1] + mapPos.y
      };
      var endMap = {
        x: startMap.x + mapSize.w,
        y: startMap.y + mapSize.h
      };
      var touchPos = {
        x: _this3.lastClickPos.x,
        y: _this3.props.height - _this3.lastClickPos.y
      };

      if (touchPos.x > startMap.x && touchPos.x < endMap.x && touchPos.y > startMap.y && touchPos.y < endMap.y) {
        var spotPos = [(touchPos.x - startMap.x) / mapSize.w, (touchPos.y - startMap.y) / mapSize.h];
        var x = Math.floor(spotPos[0] * _this3.state.mapSize[0]);
        var y = Math.floor(spotPos[1] * _this3.state.mapSize[1]);

        if (_this3.mapType == Const.MAP_EDIT_TYPE_SPOT) {
          var cPos = _this3.mapDataUtil.calculateSpotPos(x, y);

          if (cPos != null && cPos.value == 1) {
            _this3.updateState({
              spot: 1,
              spotPos: cPos.spotPos
            });
          }
        }
      } else {}
    };

    this.startTest = function () {
      if (_this3.interval) {
        clearInterval(_this3.interval);
        _this3.interval = null;
      }

      _this3.interval = setInterval(function () {
        _this3.onMapChange();
      }, 2000);
    };

    this.onMapChange = function (isNew) {
      if (isNew != true) {
        if (gData.isTouch == true) {
          return;
        }

        if (_this3.props.checkFocused) {
          if (_this3.props.checkFocused() == false) {
            return;
          }
        }
      }

      if (_this3.executor) {
        if (_this3.executor.isRunning || !_this3.executor.isReady) {
          console.log("executor: not ready");
          return;
        }
      }

      _this3.ttt = Date.now();

      var mapDataTmp = _this3.mapDataUtil.getCleanMapInfo();

      if (!mapDataTmp) {
        console.log("mapDataTmp: undefiend");
        return;
      }

      if (_this3.executor) {
        console.log("mapDataTmp:", mapDataTmp);
        var chargePos = {
          angle: mapDataTmp.chargePos.angle,
          x: (mapDataTmp.chargePos.x - mapDataTmp.mapInfo.minX) / mapDataTmp.gridWidth,
          y: (mapDataTmp.chargePos.y - mapDataTmp.mapInfo.minY) / mapDataTmp.gridWidth
        };
        console.log("chargePos:", chargePos);

        _this3.executor.execute("Optimize2", mapDataTmp.mapData, mapDataTmp.width, mapDataTmp.height, chargePos).then(function (res) {
          if (res.points == undefined) {
            res = JSON.parse(res);
          }

          var Multiple = res.Multiple;

          if (res.chargePos) {
            mapDataTmp.chargePos = {
              x: Math.floor(res.chargePos.x * mapDataTmp.gridWidth) + mapDataTmp.mapInfo.minX,
              y: Math.floor(res.chargePos.y * mapDataTmp.gridWidth) + mapDataTmp.mapInfo.minY,
              angle: res.chargePos.angle
            };
          }

          mapDataTmp.gridWidth = mapDataTmp.gridWidth / Multiple;
          mapDataTmp.width = res.picW;
          mapDataTmp.height = res.picH;
          return _miot.Host.crypto.pointsToImageBase64(res.picW, res.picH, res.points, '{"0":"#00000000","1":"#ff83b2ff","2":"#ff6e6e6e","3":"#ffbed4f5"}');
        }).then(function (base64) {
          mapDataTmp.data = base64;
          var mapData = mapDataTmp;
          var wnum = mapData.width + 2;

          if (mapData.width / mapData.height < _this3.props.width / (_this3.props.height - _this3.cleanInfoHeight - _this3.openDrawerOffset)) {
            wnum = Math.ceil(_this3.props.width / (_this3.props.height - _this3.cleanInfoHeight - _this3.openDrawerOffset) * mapData.height) + 2;
          }

          var times = 50 / mapData.gridWidth;

          if (wnum < times * 100) {
            wnum = times * 100;
          }

          var rX = (mapData.robotPos.x - mapData.mapInfo.minX) / mapData.width / mapData.gridWidth;
          var rY = (mapData.robotPos.y - mapData.mapInfo.minY) / mapData.height / mapData.gridWidth;

          var mapPos = _this3.calculateMapPos(wnum, [mapData.width, mapData.height]);

          var traces = mapData.traces;
          var width = _this3.props.width;

          var calculateTracePos = function calculateTracePos(pos) {
            var x = (pos.x - mapData.mapInfo.minX) / 100 * (width / wnum) + mapPos[0];
            var y = _this3.props.height - (pos.y - mapData.mapInfo.minY) / 100 * (width / wnum) - mapPos[1];
            return {
              x: x,
              y: y
            };
          };

          var path = '';
          var charge = 0;
          var chargePos = [0, 0];
          var cAngel = 0;
          var robotAngle = -mapData.robotPos.angle / 360 * 2 * Math.PI;

          if (mapData.chargePos && mapData.chargePos.x != 0x7fff) {
            charge = 1;
            var cX = (mapData.chargePos.x - mapData.mapInfo.minX) / mapData.width / mapData.gridWidth;
            var cY = (mapData.chargePos.y - mapData.mapInfo.minY) / mapData.height / mapData.gridWidth;
            chargePos = [cX, cY];

            if (Const.status.isOnCharge()) {
              var r = 250;
              var chargeX = mapData.chargePos.x;
              var chargeY = mapData.chargePos.y;
              var chargeAngle = mapData.chargePos.angle;
              rX = (chargeX + r * Math.cos(chargeAngle * Math.PI / 180) - mapData.mapInfo.minX) / mapData.width / mapData.gridWidth;
              rY = (chargeY + r * Math.sin(chargeAngle * Math.PI / 180) - mapData.mapInfo.minY) / mapData.height / mapData.gridWidth;
              robotAngle = -(chargeAngle + 180) / 360 * 2 * Math.PI;
            }

            cAngel = -mapData.chargePos.angle / 360 * 2 * Math.PI;
          }

          _this3.gridWidth = mapData.gridWidth;
          var update = {
            map: {
              uri: "data:image/png;base64," + mapData.data
            },
            mapSize: [mapData.width, mapData.height],
            charge: charge,
            chargePos: chargePos,
            chargeAngel: cAngel,
            mapPos: mapPos,
            robotAngle: robotAngle,
            onCharge: Const.status.isOnCharge() ? 1 : 0,
            tracePath: path,
            widthGridNum: wnum
          };

          if (_this3.startAnim && isNew != true && !Const.status.isOnCharge()) {
            _this3.targetPos = {
              targetTime: Date.now() + 1950,
              robotPos: [rX, rY],
              robotAngle: robotAngle,
              oldPos: _this3.state.robotPos,
              oldAngle: _this3.state.robotAngle,
              startTime: Date.now()
            };
          } else {
            update.robotPos = [rX, rY];
            _this3.targetPos = null;
          }

          _this3.updateState(update);
        }).catch(function (err) {
          console.log("ObjectMethodCall failed :", err);
        });
      }
    };

    this.updateState = function (updateState) {
      if (_this3.startAnim) {
        _this3.state = babelHelpers.extends(_this3.state, updateState);
      } else {
        _this3.setState(updateState);
      }
    };

    this.calculateOffset = function (zoom, newOffset) {
      if (newOffset[0] < -_this3.props.width) {
        newOffset[0] = -_this3.props.width;
      }

      if (newOffset[0] > _this3.props.width) {
        newOffset[0] = _this3.props.width;
      }

      if (newOffset[1] < -_this3.props.height) {
        newOffset[1] = -_this3.props.height;
      }

      if (newOffset[1] > _this3.props.height) {
        newOffset[1] = _this3.props.height;
      }

      return newOffset;
    };

    this.startAnimtion = function () {
      _this3.setDeviceStatus(_this3.deviceStatus);
    };

    this.stopAnimation = function () {
      if (_this3.startAnim) {
        _this3.startAnim = false;
        cancelAnimationFrame(_this3._rafLoop);
      }
    };

    this.calculateDistance = function (touchs) {
      var pos1 = {
        x: touchs[0].locationX,
        y: touchs[0].locationY
      };
      var pos2 = {
        x: touchs[1].locationX,
        y: touchs[1].locationY
      };
      var distance = Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
      return distance;
    };

    this._rafLoop = function () {
      if (!_this3.startAnim) {
        _this3.setState({
          animScale: 0.0,
          animAlpha: 0.0,
          sleep1: [0, 0],
          animScale2: 0.0,
          animAlpha2: 0.0,
          sleep2: [0, 0]
        });

        return;
      }

      var current = Date.now();

      var _time = current - _this3.t0;

      var totleTime = 2000;

      if (_this3.deviceStatus == 4) {
        totleTime = 3400;
      }

      if (_time > totleTime) {
        _this3.t0 = current;
        var update = {
          animScale: 0.0,
          animAlpha: 0.0,
          sleep1: [0, 0],
          animScale2: 0.0,
          animAlpha2: 0.0,
          sleep2: [0, 0]
        };

        if (_this3.targetPos) {
          if (current >= _this3.targetPos.targetTime) {
            update.robotPos = _this3.targetPos.robotPos;
          } else {
            var scale = (current - _this3.targetPos.startTime) / (_this3.targetPos.targetTime - _this3.targetPos.startTime);
            update.robotPos = [_this3.targetPos.oldPos[0] + scale * (_this3.targetPos.robotPos[0] - _this3.targetPos.oldPos[0]), _this3.targetPos.oldPos[1] + scale * (_this3.targetPos.robotPos[1] - _this3.targetPos.oldPos[1])];
          }
        }

        _this3.setState(update);
      } else {
        var alpha = 1.0;
        var _update = {};
        var animScale = 0.7;

        if (_this3.deviceStatus == 1) {
          if (_time < 500) {
            alpha = _time / 500 * 1.0;
          }

          _update = {
            animScale: 1.5 - _time / totleTime * 0.8,
            animAlpha: alpha
          };
        } else if (_this3.deviceStatus == 3) {
          _time = _time % 1000;

          if (_time < 130) {
            alpha = _time / 130 * 0.7;
            animScale = 1.1 + _time / 130 * 0.4;
          } else if (_time < 260) {
            alpha = 0.7 - (_time - 130) / 130 * 0.5;
            animScale = 1.5 - (_time - 130) / 130 * 0.3;
          } else if (_time < 400) {
            animScale = 1.2;
            alpha = (_time - 260) / 140 * 0.6 + 0.2;
          } else {
            animScale = 1.2;
            alpha = 0.8 + (_time - 400) / 600 * 0.1;
          }

          _update = {
            animScale: animScale,
            animAlpha: alpha
          };
        } else if (_this3.deviceStatus == 4) {
          var sleep1 = [0.0, 0.0];

          if (_time < 1700) {
            sleep1[0] = easingTypes["linear"](_time, 0.0, 1.0, 1700);
            sleep1[1] = easingTypes["easeInQuad"](_time, 0.0, 1.0, 1700);
          } else if (_time < 1900) {
            sleep1[0] = 1.0;
            sleep1[1] = 1.0;
          } else {
            sleep1[0] = 0.0;
            sleep1[1] = 0.0;
          }

          if (_time < 800) {
            animScale = easingTypes["linear"](_time, 0.2, 1.0, 800);
          } else if (_time < 1900) {
            animScale = 1.0;
          } else {
            animScale = 0.0;
          }

          if (_time < 200) {
            animAlpha = easingTypes["linear"](_time, 0.2, 1.0, 200);
          } else if (_time < 1700) {
            animAlpha = 1.0;
          } else if (_time < 1900) {
            animAlpha = easingTypes["linear"](_time - 1700, 1.0, 0.0, 200);
          } else {
            animAlpha = 0.0;
          }

          _update.animAlpha = animAlpha;
          _update.animScale = animScale;
          _update.sleep1 = sleep1;
          var animAlpha2 = 0;
          var animScale2 = 0;
          var sleep2 = [0, 0];

          if (_time <= 700) {} else if (_time <= 1700) {
            animScale2 = easingTypes["linear"](_time - 700, 0.2, 1.0, 1000);
            animAlpha2 = easingTypes["linear"](_time - 700, 0.2, 1.0, 1000);
          } else if (_time < 2400) {
            animScale2 = 1.0;
            animAlpha2 = 1.0;
          } else if (_time < 2600) {
            animAlpha2 = easingTypes["linear"](_time - 2600, 1.0, 0.0, 200);
            animScale2 = 1.0;
          } else {
            animAlpha2 = 0;
            animScale2 = 0;
          }

          if (_time < 700) {} else if (_time < 2600) {
            sleep2[0] = easingTypes["linear"](_time - 700, 0.0, 0.9, 1900);
            sleep2[1] = easingTypes["easeOutQuad"](_time - 700, 0.0, 0.9, 1900);
          }

          _update.animAlpha2 = animAlpha2;
          _update.animScale2 = animScale2;
          _update.sleep2 = sleep2;
        } else {
          if (_time < 1000) {
            alpha = _time / 1000 * 1.0;
            animScale = 0.7 + _time / 1000 * 0.8;
          } else {
            alpha = 1.0 - (_time - 1000) / 1000 * 1.0;

            if (alpha < 0) {
              alpha = 0;
            }

            animScale = 1.5;
          }

          _update.animAlpha = alpha;
          _update.animScale = animScale;
        }

        if (_this3.targetPos) {
          if (current >= _this3.targetPos.targetTime) {
            _update.robotPos = _this3.targetPos.robotPos;
          } else {
            var _scale = (current - _this3.targetPos.startTime) / (_this3.targetPos.targetTime - _this3.targetPos.startTime);

            _update.robotPos = [_this3.targetPos.oldPos[0] + _scale * (_this3.targetPos.robotPos[0] - _this3.targetPos.oldPos[0]), _this3.targetPos.oldPos[1] + _scale * (_this3.targetPos.robotPos[1] - _this3.targetPos.oldPos[1])];
          }
        }

        _this3.setState(_update);
      }

      requestAnimationFrame(_this3._rafLoop);
    };
  };

  module.exports = CleanMap;
},10175,[10297,10033,13489,13480,10074,11485,10007,10169,10178,10181,10184,10187,10190,10193,10196,10199],"projects/com.dreame.devices/main/DreameUtil/CleanMap.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
        "scales": [1],
        "hash": "6a1d20d0f345322b835ebdc4bf644694",
        "name": "optimize",
        "type": "jx"
    });
},10178,[10420],"projects/com.dreame.devices/resources/optimize.jx");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 40,
      "height": 40,
      "scales": [1],
      "hash": "99d75046ff789b21e877d10ba6d8705e",
      "name": "background",
      "type": "png"
   });
},10181,[10420],"projects/com.dreame.devices/resources/background.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 64,
      "height": 64,
      "scales": [1],
      "hash": "0e8e33e2c543a9533000557a32881ba7",
      "name": "robot",
      "type": "png"
   });
},10184,[10420],"projects/com.dreame.devices/resources/robot.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 76,
      "height": 76,
      "scales": [1],
      "hash": "0794fd1fac2b0dd8f54cad304f87b433",
      "name": "charging",
      "type": "png"
   });
},10187,[10420],"projects/com.dreame.devices/resources/charging.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 228,
    "height": 228,
    "scales": [1],
    "hash": "b4338db8b08de1f2cc73e94b0bb1b285",
    "name": "cleaning",
    "type": "png"
  });
},10190,[10420],"projects/com.dreame.devices/resources/cleaning.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 90,
    "height": 90,
    "scales": [1],
    "hash": "43644353dbc5387da09f271e25532cb4",
    "name": "dock_log",
    "type": "png"
  });
},10193,[10420],"projects/com.dreame.devices/resources/dock_log.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 14,
      "height": 14,
      "scales": [1],
      "hash": "019cd450d45438f06e5efb346dcfaaa0",
      "name": "spot_line",
      "type": "png"
   });
},10196,[10420],"projects/com.dreame.devices/resources/spot_line.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 90,
    "height": 90,
    "scales": [1],
    "hash": "2f9487ab021477ff1bc6b8e007bb6e01",
    "name": "sleep",
    "type": "png"
  });
},10199,[10420],"projects/com.dreame.devices/resources/sleep.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _Host = _require(_dependencyMap[2]);

  var _Host2 = babelHelpers.interopRequireDefault(_Host);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var RobotInfoView = function (_React$Component) {
    babelHelpers.inherits(RobotInfoView, _React$Component);

    function RobotInfoView() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, RobotInfoView);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = RobotInfoView.__proto__ || Object.getPrototypeOf(RobotInfoView)).call.apply(_ref, [this].concat(args))), _this), _this.handleSetViewport = function (e) {
        var mainProps = {};
        var layout = e.nativeEvent.layout;

        if (_this.props.isTime) {
          mainProps.top = layout.y + 3;
        } else {
          mainProps.top = layout.y + 5;
        }

        if (_this.props.unit === "%" && _Host2.default.locale.language === "tr") {
          mainProps.left = layout.x - 2;
        } else {
          mainProps.left = layout.x + layout.width - 2;
        }

        if (_this.unitView) {
          _this.unitView.setNativeProps({
            style: mainProps
          });
        }
      }, _this.handleSetDesc = function (e) {
        var height = e.nativeEvent.layout.height;

        if (_this.props.onHeight) {
          _this.props.onHeight(height);
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(RobotInfoView, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var minHeight = this.props.minDescHeight;

        if (minHeight == undefined) {
          minHeight = 0;
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.content
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.content2
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [styles.value, {
                  fontFamily: Const.fontFamily
                }],
                onLayout: this.handleSetViewport
              },
              " " + this.props.value + " "
            ),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [styles.desc, {
                  fontFamily: Const.fontFamily
                }, {
                  minHeight: minHeight
                }],
                onLayout: this.handleSetDesc
              },
              this.props.desc
            ),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [this.props.isTime ? styles.unit2 : styles.unit, {
                  fontFamily: Const.fontFamily
                }],
                ref: function ref(c) {
                  return _this2.unitView = c;
                }
              },
              this.props.unit
            )
          )
        );
      }
    }]);
    return RobotInfoView;
  }(_react2.default.Component);

  exports.default = RobotInfoView;

  var styles = _reactNative.StyleSheet.create({
    unit: {
      right: 0,
      left: 0,
      top: 0,
      bottom: 0,
      fontSize: 10.26,
      color: 'rgba(0,0,0,0.6)',
      position: 'absolute',
      backgroundColor: 'transparent'
    },
    unit2: {
      right: 0,
      left: 0,
      top: 0,
      bottom: 0,
      fontSize: 14.5,
      color: 'rgba(0,0,0,0.6)',
      position: 'absolute',
      backgroundColor: 'transparent'
    },
    content: {
      flex: 1.0,
      justifyContent: 'center',
      alignItems: 'center'
    },
    content2: {
      width: (width - 40) / 3,
      paddingLeft: 2,
      paddingRight: 2,
      justifyContent: 'center',
      alignItems: 'center'
    },
    value: {
      fontSize: 22,
      fontFamily: "Kmedium",
      fontWeight: "400",
      color: 'rgba(0,0,0,0.8)',
      textAlignVertical: 'center',
      textAlign: 'center'
    },
    desc: {
      marginTop: 1,
      color: 'rgba(0,0,0,0.5)',
      fontSize: 13,
      fontWeight: "100",
      textAlign: 'center'
    }
  });
},10202,[10297,10033,10035],"projects/com.dreame.devices/main/widget/RobotInfoView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _miot = _require(_dependencyMap[2]);

  var _reactNativeShadow = _require(_dependencyMap[3]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var CardButton = function (_React$Component) {
    babelHelpers.inherits(CardButton, _React$Component);

    function CardButton() {
      var _ref;

      var _temp, _this, _ret;

      babelHelpers.classCallCheck(this, CardButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = CardButton.__proto__ || Object.getPrototypeOf(CardButton)).call.apply(_ref, [this].concat(args))), _this), _this.handleSetViewport = function (e) {
        var mainProps = {};
        var layout = e.nativeEvent.layout;
        mainProps.width = layout.width;
        mainProps.height = layout.height;

        if (_this.cover) {
          _this.cover.setNativeProps({
            style: mainProps
          });
        }
      }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
    }

    babelHelpers.createClass(CardButton, [{
      key: "_buttonPressIn",
      value: function _buttonPressIn() {
        if (this.cover) {
          this.cover.setNativeProps({
            style: {
              borderColor: 'rgba(0,0,0,0.05)',
              backgroundColor: 'rgba(0,0,0,0.05)'
            }
          });
        }
      }
    }, {
      key: "_buttonPressOut",
      value: function _buttonPressOut() {
        if (this.cover) {
          this.cover.setNativeProps({
            style: {
              borderColor: 'rgba(255,255,255,0)',
              backgroundColor: 'rgba(255,255,255,0)'
            }
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var shadowOpt = {
          width: (width - 30) / 2,
          height: this.props.style.height,
          color: "#000",
          border: 5,
          radius: 11,
          opacity: 0.03,
          x: 0,
          y: 3,
          style: {
            marginVertical: 0,
            marginLeft: this.props.style.marginLeft
          }
        };

        var textPaddingLeft = 40 / _reactNative.PixelRatio.get();

        if (_miot.Host.locale.language == "de") {
          textPaddingLeft = textPaddingLeft - 3;
        } else if (_miot.Host.locale.language == "fr") {
          textPaddingLeft = textPaddingLeft - 8;
        } else if (_miot.Host.locale.language == "th") {
          textPaddingLeft = textPaddingLeft - 3;
        } else if (_miot.Host.locale.language == "ru") {
          textPaddingLeft = textPaddingLeft - 3;
        } else if (_miot.Host.locale.language == "tr") {
          textPaddingLeft = textPaddingLeft - 3;
        }

        return _react2.default.createElement(
          _reactNativeShadow.BoxShadow,
          {
            setting: shadowOpt
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: [styles.cardStyle],
              onLayout: this.handleSetViewport,
              alignItems: "center",
              flexDirection: "row",
              flex: 1.0
            },
            _react2.default.createElement(_reactNative.Image, {
              ref: function ref(c) {
                return _this2.image = c;
              },
              source: this.props.nomalImage,
              style: {
                width: 40,
                height: 40,
                marginLeft: 20
              },
              resizeMode: "contain"
            }),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  fontSize: 16.5,
                  marginLeft: textPaddingLeft,
                  fontFamily: Const.fontFamily,
                  color: 'rgba(0,0,0,1.0)'
                }
              },
              this.props.text
            ),
            _react2.default.createElement(
              _reactNative.TouchableWithoutFeedback,
              {
                onPress: this.props.onPress,
                onPressIn: this._buttonPressIn.bind(this),
                onPressOut: this._buttonPressOut.bind(this)
              },
              _react2.default.createElement(_reactNative.View, {
                style: styles.coverStyle,
                ref: function ref(c) {
                  return _this2.cover = c;
                }
              })
            )
          )
        );
      }
    }]);
    return CardButton;
  }(_react2.default.Component);

  CardButton.defaultProps = {
    onPress: null
  };
  exports.default = CardButton;

  var styles = _reactNative.StyleSheet.create({
    cardStyle: {
      backgroundColor: '#ffffffff',
      borderWidth: _reactNative.StyleSheet.hairlineWidth,
      borderRadius: 11,
      borderColor: '#ffffffff'
    },
    coverStyle: {
      left: 0,
      top: 0,
      position: 'absolute',
      backgroundColor: 'transparent',
      borderRadius: 11,
      borderColor: 'transparent',
      borderWidth: _reactNative.StyleSheet.hairlineWidth
    }
  });
},10205,[10297,10033,10074,13699],"projects/com.dreame.devices/main/widget/CardButton.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _CleanModeButton = _require(_dependencyMap[2]);

  var _CleanModeButton2 = babelHelpers.interopRequireDefault(_CleanModeButton);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _reactNativeShadow = _require(_dependencyMap[4]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var CleanModeView = function (_React$Component) {
    babelHelpers.inherits(CleanModeView, _React$Component);

    function CleanModeView(props) {
      babelHelpers.classCallCheck(this, CleanModeView);

      var _this = babelHelpers.possibleConstructorReturn(this, (CleanModeView.__proto__ || Object.getPrototypeOf(CleanModeView)).call(this, props));

      _this.onModeSelect = function (index) {
        if (index != _this.state.selectMode) {
          if (_this.props.onModeSelect) {
            _this.props.onModeSelect(index);
          }
        }
      };

      _this.setMode = function (mode) {
        _this.setState({
          selectMode: mode
        });
      };

      _this.handleSetViewport = function (e) {};

      _this.onDescHeight = function (h) {
        if (h > _this.state.descHeight) {
          _this.setState({
            descHeight: h
          });
        }
      };

      _this.state = {
        selectMode: _this.props.selectMode,
        descHeight: 0
      };
      _this.modes = [(0, _MHLocalizableString.getString)('modeQuiet'), (0, _MHLocalizableString.getString)('modeStandard'), (0, _MHLocalizableString.getString)('modeMedium'), (0, _MHLocalizableString.getString)('modeStrong')];
      return _this;
    }

    babelHelpers.createClass(CleanModeView, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var shadowOpt = {
          width: width - 20,
          height: this.props.style.height,
          color: "#000",
          border: 5,
          radius: 11,
          opacity: 0.03,
          x: 0,
          y: 3,
          style: {
            marginVertical: 0,
            marginTop: 10,
            marginBottom: 10
          }
        };
        return _react2.default.createElement(
          _reactNativeShadow.BoxShadow,
          {
            setting: shadowOpt
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: [this.props.style, styles.cardStyle],
              paddingTop: 17
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  marginLeft: 20,
                  flexDirection: "row"
                },
                alignItems: "center"
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 16.8,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,1.0)'
                  }
                },
                (0, _MHLocalizableString.getString)('cleanMode')
              ),
              _react2.default.createElement(_reactNative.View, {
                style: {
                  backgroundColor: 'rgba(0,0,0,0.3)'
                },
                width: Const.onePixel,
                height: 15,
                marginLeft: 5,
                marginTop: 2,
                marginRight: 5
              }),
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 15.8,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,0.6)'
                  }
                },
                this.modes[this.state.selectMode]
              )
            ),
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  flexDirection: "row",
                  alignItems: 'center',
                  flex: 1.0,
                  paddingLeft: 3,
                  paddingRight: 3
                }
              },
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[5]),
                selectImage: _require(_dependencyMap[6]),
                pressImage: _require(_dependencyMap[7]),
                text: (0, _MHLocalizableString.getString)('modeQuiet'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(0);
                },
                isSelect: this.state.selectMode == 0
              }),
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[8]),
                selectImage: _require(_dependencyMap[9]),
                pressImage: _require(_dependencyMap[10]),
                text: (0, _MHLocalizableString.getString)('modeStandard'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(1);
                },
                isSelect: this.state.selectMode == 1
              }),
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[11]),
                selectImage: _require(_dependencyMap[12]),
                pressImage: _require(_dependencyMap[13]),
                text: (0, _MHLocalizableString.getString)('modeMedium'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(2);
                },
                isSelect: this.state.selectMode == 2
              }),
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[14]),
                selectImage: _require(_dependencyMap[15]),
                pressImage: _require(_dependencyMap[16]),
                text: (0, _MHLocalizableString.getString)('modeStrong'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(3);
                },
                isSelect: this.state.selectMode == 3
              })
            )
          )
        );
      }
    }]);
    return CleanModeView;
  }(_react2.default.Component);

  CleanModeView.defaultProps = {
    selectMode: 1
  };
  exports.default = CleanModeView;

  var styles = _reactNative.StyleSheet.create({
    cardStyle: {
      backgroundColor: '#ffffffff',
      borderWidth: _reactNative.StyleSheet.hairlineWidth,
      borderRadius: 11,
      borderColor: '#ffffffff'
    }
  });
},10208,[10297,10033,10211,10157,13699,10214,10217,10220,10223,10226,10229,10232,10235,10238,10241,10244,10247],"projects/com.dreame.devices/main/widget/CleanModeView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var CleanModeButton = function (_React$Component) {
        babelHelpers.inherits(CleanModeButton, _React$Component);

        function CleanModeButton(props) {
            babelHelpers.classCallCheck(this, CleanModeButton);

            var _this = babelHelpers.possibleConstructorReturn(this, (CleanModeButton.__proto__ || Object.getPrototypeOf(CleanModeButton)).call(this, props));

            _this.handleSetViewport = function (e) {
                var mainProps = {};
                var layout = e.nativeEvent.layout;
                mainProps.width = layout.width;
                mainProps.height = layout.height;

                if (_this.cover) {
                    _this.cover.setNativeProps({
                        style: mainProps
                    });
                }
            };

            _this.handleSetDesc = function (e) {
                var height = e.nativeEvent.layout.height;

                if (_this.props.onHeight) {
                    _this.props.onHeight(height);
                }
            };

            _this.state = {
                buttonPressed: false
            };
            return _this;
        }

        babelHelpers.createClass(CleanModeButton, [{
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.setState({
                    buttonPressed: true
                });
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.setState({
                    buttonPressed: false
                });
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;

                var imageW = 55;
                var minHeight = this.props.minDescHeight;

                if (minHeight == undefined) {
                    minHeight = 0;
                }

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: {},
                        onLayout: this.handleSetViewport,
                        justifyContent: "center",
                        alignItems: "center",
                        flex: 1.0
                    },
                    _react2.default.createElement(_reactNative.Image, {
                        ref: function ref(c) {
                            return _this2.image = c;
                        },
                        source: this.props.isSelect ? this.props.selectImage : this.state.buttonPressed ? this.props.pressImage : this.props.nomalImage,
                        style: {
                            width: imageW,
                            height: imageW
                        },
                        resizeMode: "contain"
                    }),
                    _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: [{
                                fontSize: 14.5,
                                fontWeight: "300",
                                textAlign: 'center',
                                fontFamily: Const.fontFamily,
                                marginTop: 10,
                                minHeight: minHeight
                            }, this.props.isSelect ? {
                                color: '#5696ff'
                            } : {
                                color: 'rgba(0,0,0,0.6)'
                            }],
                            onLayout: this.handleSetDesc
                        },
                        this.props.text
                    ),
                    _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this.props.onPress,
                            onPressIn: this._buttonPressIn.bind(this),
                            onPressOut: this._buttonPressOut.bind(this)
                        },
                        _react2.default.createElement(_reactNative.View, {
                            style: [styles.coverStyle, {
                                backgroundColor: 'rgba(255,255,255,0)'
                            }],
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        })
                    )
                );
            }
        }]);
        return CleanModeButton;
    }(_react2.default.Component);

    CleanModeButton.defaultProps = {
        onPress: null
    };
    exports.default = CleanModeButton;

    var styles = _reactNative.StyleSheet.create({
        coverStyle: {
            left: 0,
            top: 0,
            position: 'absolute',
            borderColor: 'transparent',
            borderWidth: _reactNative.StyleSheet.hairlineWidth
        }
    });
},10211,[10297,10033],"projects/com.dreame.devices/main/widget/CleanModeButton.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "6f0a022c3a34224c8b9cf959f01994f2",
      "name": "quiet_nomal",
      "type": "png"
   });
},10214,[10420],"projects/com.dreame.devices/resources/quiet_nomal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "9529e0653b7b65db7817203a9d59fcd8",
      "name": "quiet_select",
      "type": "png"
   });
},10217,[10420],"projects/com.dreame.devices/resources/quiet_select.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "1a326602f4642dc58023b611ebed8135",
      "name": "quiet_press",
      "type": "png"
   });
},10220,[10420],"projects/com.dreame.devices/resources/quiet_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "4a9c756e8c2d99682893f5539e04f71f",
      "name": "standard_normal",
      "type": "png"
   });
},10223,[10420],"projects/com.dreame.devices/resources/standard_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "a3a102cc28539d82cedbf505a79a2778",
      "name": "standard_select",
      "type": "png"
   });
},10226,[10420],"projects/com.dreame.devices/resources/standard_select.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "08ba83dddb5da84d737ab16b04d04f4c",
      "name": "standard_press",
      "type": "png"
   });
},10229,[10420],"projects/com.dreame.devices/resources/standard_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "2b74d29fd03ff38f2baf7acab7e292f1",
      "name": "medium_normal",
      "type": "png"
   });
},10232,[10420],"projects/com.dreame.devices/resources/medium_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "bf138d73cd27843708ff9199c77862b6",
      "name": "medium_select",
      "type": "png"
   });
},10235,[10420],"projects/com.dreame.devices/resources/medium_select.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "200f0c985c086f33931b961651a11dfb",
      "name": "medium_press",
      "type": "png"
   });
},10238,[10420],"projects/com.dreame.devices/resources/medium_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "d9153ff6e5cae8424cbe373b5d61611d",
      "name": "strong_normal",
      "type": "png"
   });
},10241,[10420],"projects/com.dreame.devices/resources/strong_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "b9091d8f8234838a3b5ec245c750571a",
      "name": "strong_select",
      "type": "png"
   });
},10244,[10420],"projects/com.dreame.devices/resources/strong_select.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 150,
      "height": 150,
      "scales": [1],
      "hash": "7e7837d6b1554cc70f86ffd7e358fdc1",
      "name": "strong_press",
      "type": "png"
   });
},10247,[10420],"projects/com.dreame.devices/resources/strong_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _CleanModeButton = _require(_dependencyMap[2]);

  var _CleanModeButton2 = babelHelpers.interopRequireDefault(_CleanModeButton);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _reactNativeShadow = _require(_dependencyMap[4]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var CleanModeView = function (_React$Component) {
    babelHelpers.inherits(CleanModeView, _React$Component);

    function CleanModeView(props) {
      babelHelpers.classCallCheck(this, CleanModeView);

      var _this = babelHelpers.possibleConstructorReturn(this, (CleanModeView.__proto__ || Object.getPrototypeOf(CleanModeView)).call(this, props));

      _this.onModeSelect = function (index) {
        if (index != _this.state.selectMode) {
          if (_this.props.onModeSelect) {
            _this.props.onModeSelect(index);
          }
        }
      };

      _this.setMode = function (mode) {
        _this.setState({
          selectMode: mode
        });
      };

      _this.handleSetViewport = function (e) {};

      _this.onDescHeight = function (h) {
        if (h > _this.state.descHeight) {
          _this.setState({
            descHeight: h
          });
        }
      };

      _this.state = {
        selectMode: _this.props.selectMode,
        descHeight: 0
      };
      _this.modes = [(0, _MHLocalizableString.getString)('mopMode1'), (0, _MHLocalizableString.getString)('mopMode2'), (0, _MHLocalizableString.getString)('mopMode3')];
      return _this;
    }

    babelHelpers.createClass(CleanModeView, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var shadowOpt = {
          width: width - 20,
          height: this.props.style.height,
          color: "#000",
          border: 5,
          radius: 11,
          opacity: 0.03,
          x: 0,
          y: 3,
          style: {
            marginVertical: 0,
            marginTop: 0,
            marginBottom: 10
          }
        };
        return _react2.default.createElement(
          _reactNativeShadow.BoxShadow,
          {
            setting: shadowOpt
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: [this.props.style, styles.cardStyle],
              paddingTop: 17
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  marginLeft: 20,
                  flexDirection: "row"
                },
                alignItems: "center"
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 16.8,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,1.0)'
                  }
                },
                (0, _MHLocalizableString.getString)('mopModeSet')
              ),
              _react2.default.createElement(_reactNative.View, {
                style: {
                  backgroundColor: 'rgba(0,0,0,0.3)'
                },
                width: Const.onePixel,
                height: 15,
                marginLeft: 5,
                marginTop: 2,
                marginRight: 5
              }),
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 15.8,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,0.6)'
                  }
                },
                this.modes[this.state.selectMode]
              )
            ),
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  flexDirection: "row",
                  alignItems: 'center',
                  flex: 1.0,
                  paddingLeft: 3,
                  paddingRight: 3
                }
              },
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[5]),
                selectImage: _require(_dependencyMap[6]),
                pressImage: _require(_dependencyMap[7]),
                text: (0, _MHLocalizableString.getString)('mopMode1'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(0);
                },
                isSelect: this.state.selectMode == 0
              }),
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[8]),
                selectImage: _require(_dependencyMap[9]),
                pressImage: _require(_dependencyMap[10]),
                text: (0, _MHLocalizableString.getString)('mopMode2'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(1);
                },
                isSelect: this.state.selectMode == 1
              }),
              _react2.default.createElement(_CleanModeButton2.default, {
                nomalImage: _require(_dependencyMap[11]),
                selectImage: _require(_dependencyMap[12]),
                pressImage: _require(_dependencyMap[13]),
                text: (0, _MHLocalizableString.getString)('mopMode3'),
                onHeight: this.onDescHeight,
                minDescHeight: this.state.descHeight,
                onPress: function onPress() {
                  _this2.onModeSelect(2);
                },
                isSelect: this.state.selectMode == 2
              })
            )
          )
        );
      }
    }]);
    return CleanModeView;
  }(_react2.default.Component);

  CleanModeView.defaultProps = {
    selectMode: 1
  };
  exports.default = CleanModeView;

  var styles = _reactNative.StyleSheet.create({
    cardStyle: {
      backgroundColor: '#ffffffff',
      borderWidth: _reactNative.StyleSheet.hairlineWidth,
      borderRadius: 11,
      borderColor: '#ffffffff'
    }
  });
},10250,[10297,10033,10211,10157,13699,10253,10256,10259,10262,10265,10268,10271,10274,10277],"projects/com.dreame.devices/main/widget/MopModeView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "cc429c705c6266e6c3decc3513d6d188",
    "name": "mop_mode1_nomal",
    "type": "png"
  });
},10253,[10420],"projects/com.dreame.devices/resources/mop_mode1_nomal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "1fc31a5753e973055c9904582c1104f6",
    "name": "mop_mode1_selected",
    "type": "png"
  });
},10256,[10420],"projects/com.dreame.devices/resources/mop_mode1_selected.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "9b3b20e264c8689cd6ef386c4a0a4976",
    "name": "mop_mode1_press",
    "type": "png"
  });
},10259,[10420],"projects/com.dreame.devices/resources/mop_mode1_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "656a80e71e24f64b29ee05c17bcffba3",
    "name": "mop_mode2_nomal",
    "type": "png"
  });
},10262,[10420],"projects/com.dreame.devices/resources/mop_mode2_nomal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "e7595f0f63c10ef8eee727f945b6da66",
    "name": "mop_mode2_selected",
    "type": "png"
  });
},10265,[10420],"projects/com.dreame.devices/resources/mop_mode2_selected.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "8f3c8b56689c8be00b8d6a507af6c0e8",
    "name": "mop_mode2_press",
    "type": "png"
  });
},10268,[10420],"projects/com.dreame.devices/resources/mop_mode2_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "d2eab8c7bd45b82c6fed90d7b7e7e009",
    "name": "mop_mode3_nomal",
    "type": "png"
  });
},10271,[10420],"projects/com.dreame.devices/resources/mop_mode3_nomal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources",
		"width": 150,
		"height": 150,
		"scales": [1],
		"hash": "47b7f46b1e926acb219fc8b1c4fdbdd1",
		"name": "mop_mode3_selected",
		"type": "png"
	});
},10274,[10420],"projects/com.dreame.devices/resources/mop_mode3_selected.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 150,
    "height": 150,
    "scales": [1],
    "hash": "5e82584c4e523d6a6869f2952ec79512",
    "name": "mop_mode3_press",
    "type": "png"
  });
},10277,[10420],"projects/com.dreame.devices/resources/mop_mode3_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _ui = _require(_dependencyMap[2]);

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var ListItemView = function (_React$Component) {
        babelHelpers.inherits(ListItemView, _React$Component);

        function ListItemView(props) {
            babelHelpers.classCallCheck(this, ListItemView);

            var _this = babelHelpers.possibleConstructorReturn(this, (ListItemView.__proto__ || Object.getPrototypeOf(ListItemView)).call(this, props));

            _this.handleSetViewport = function (e) {
                var mainProps = {};
                var layout = e.nativeEvent.layout;
                mainProps.width = layout.width;
                mainProps.height = layout.height;

                if (_this.cover) {
                    _this.cover.setNativeProps({
                        style: mainProps
                    });
                }

                if (_this.delete) {
                    _this.delete.setNativeProps({
                        style: {
                            top: (layout.height - 14) / 2
                        }
                    });
                }

                if (_this.props.onCardHeightChange) {
                    _this.props.onCardHeightChange(layout.height);
                }
            };

            _this.isPressed = false;
            return _this;
        }

        babelHelpers.createClass(ListItemView, [{
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.isPressed = true;

                if (this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(0,0,0,0.05)',
                            backgroundColor: 'rgba(0,0,0,0.05)'
                        }
                    });
                }
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.isPressed = false;

                if (this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(255,255,255,0)',
                            backgroundColor: 'rgba(255,255,255,0)'
                        }
                    });
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;

                var imageW = 40;
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: [styles.cardStyle, this.props.style],
                        onLayout: this.handleSetViewport,
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    _react2.default.createElement(_reactNative.Image, {
                        source: this.props.nomalImage,
                        style: {
                            width: imageW,
                            height: imageW
                        },
                        resizeMode: "contain"
                    }),
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            flex: 1.0,
                            marginLeft: 10,
                            justifyContent: "center"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 15.5,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,1)'
                                },
                                ellipsizeMode: "tail",
                                numberOfLines: 2
                            },
                            this.props.title
                        ),
                        this.props.tips && _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13.5,
                                    fontWeight: '300',
                                    lineHeight: 15,
                                    fontFamily: Const.fontFamily,
                                    marginTop: 5,
                                    color: 'rgba(0,0,0,0.6)'
                                },
                                ellipsizeMode: "tail",
                                numberOfLines: this.props.tipLineNum ? this.props.tipLineNum : 2
                            },
                            this.props.tips
                        )
                    ),
                    _react2.default.createElement(_reactNative.Image, {
                        style: {
                            width: 14,
                            height: this.props.onDelete || !this.props.onPress ? 0 : 14
                        },
                        resizeMode: "contain",
                        source: _require(_dependencyMap[3])
                    }),
                    _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this.props.onPress,
                            onPressIn: this._buttonPressIn.bind(this),
                            onPressOut: this._buttonPressOut.bind(this)
                        },
                        _react2.default.createElement(_reactNative.View, {
                            style: [styles.coverStyle, this.props.style, this.isPressed ? {
                                backgroundColor: 'rgba(255,255,255,0.5)'
                            } : {
                                backgroundColor: 'rgba(255,255,255,0)'
                            }],
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        })
                    ),
                    _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this.props.onDelete
                        },
                        _react2.default.createElement(_reactNative.Image, {
                            style: {
                                width: 14,
                                height: this.props.onDelete ? 14 : 0,
                                position: 'absolute',
                                top: 0,
                                right: 20
                            },
                            ref: function ref(c) {
                                return _this2.delete = c;
                            },
                            resizeMode: "contain",
                            source: _require(_dependencyMap[4])
                        })
                    )
                );
            }
        }]);
        return ListItemView;
    }(_react2.default.Component);

    ListItemView.defaultProps = {
        onPress: null
    };
    exports.default = ListItemView;

    var styles = _reactNative.StyleSheet.create({
        cardStyle: {
            backgroundColor: '#ffffffff',
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            flexDirection: "row",
            borderColor: '#ffffffff',
            paddingLeft: 20,
            paddingRight: 18
        },
        coverStyle: {
            left: 0,
            top: 0,
            position: 'absolute',
            borderColor: 'transparent',
            borderWidth: _reactNative.StyleSheet.hairlineWidth
        }
    });
},10280,[10297,10033,10230,10283,10286],"projects/com.dreame.devices/main/widget/ListItemView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 41,
      "height": 41,
      "scales": [1],
      "hash": "5e23e5cc70b2685c19ef5c142b97777c",
      "name": "arrow",
      "type": "png"
   });
},10283,[10420],"projects/com.dreame.devices/resources/arrow.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 27,
      "height": 27,
      "scales": [1],
      "hash": "e5be9f5830ea8eee4d12d2d000650068",
      "name": "warn_delete_normal",
      "type": "png"
   });
},10286,[10420],"projects/com.dreame.devices/resources/warn_delete_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _propTypes = _require(_dependencyMap[0]);

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _react = _require(_dependencyMap[1]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[2]);

  var _resources = _require(_dependencyMap[3]);

  var _Checkbox = _require(_dependencyMap[4]);

  var _Checkbox2 = babelHelpers.interopRequireDefault(_Checkbox);

  var _Separator = _require(_dependencyMap[5]);

  var _Separator2 = babelHelpers.interopRequireDefault(_Separator);

  var _AbstractDialog = _require(_dependencyMap[6]);

  var _AbstractDialog2 = babelHelpers.interopRequireDefault(_AbstractDialog);

  var paddingHorizontal = 29;
  var paddingVertical = 27;
  var paddingTop = 13;
  var TYPE = {
    SIMPLE: 'simple',
    UNDERLINE: 'underline',
    CHECKBOX: 'checkbox'
  };
  Object.freeze(TYPE);

  var MessageDialog = function (_React$Component) {
    babelHelpers.inherits(MessageDialog, _React$Component);

    function MessageDialog(props, context) {
      babelHelpers.classCallCheck(this, MessageDialog);

      var _this = babelHelpers.possibleConstructorReturn(this, (MessageDialog.__proto__ || Object.getPrototypeOf(MessageDialog)).call(this, props, context));

      _this.state = {
        checked: false
      };

      _this.process(props);

      return _this;
    }

    babelHelpers.createClass(MessageDialog, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(props) {
        this.process(props);
      }
    }, {
      key: "process",
      value: function process(props) {
        var _this2 = this;

        this.state.checked = props.extra.checked || false;
        this.hasPressUnderlineText = false;
        var buttons = props.buttons;

        if (buttons instanceof Array) {
          var button = buttons[buttons.length - 1];

          if (button && button.callback) {
            var callbackOrigin = button.callback;

            button.callback = function () {
              if (props.type === TYPE.UNDERLINE) {
                callbackOrigin({
                  hasPressUnderlineText: _this2.hasPressUnderlineText
                });
              } else if (props.type === TYPE.CHECKBOX) {
                callbackOrigin({
                  checked: _this2.state.checked
                });
              } else {
                callbackOrigin({});
              }
            };
          }
        }

        this.buttons = buttons;
      }
    }, {
      key: "renderExtra",
      value: function renderExtra() {
        var _this3 = this;

        switch (this.props.type) {
          case TYPE.SIMPLE:
            return null;

          case TYPE.UNDERLINE:
            return _react2.default.createElement(
              _reactNative.View,
              {
                style: [styles.extraContainer, {
                  paddingTop: paddingTop
                }]
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  numberOfLines: 1,
                  style: [styles.underlineText, {
                    color: this.props.color
                  }],
                  onPress: function onPress(_) {
                    return _this3.onPressUnderlineText();
                  }
                },
                this.props.extraText || ''
              )
            );

          case TYPE.CHECKBOX:
            return _react2.default.createElement(
              _reactNative.TouchableOpacity,
              {
                onPress: function onPress(_) {
                  return _this3.onPressCheckbox();
                },
                activeOpacity: 1,
                style: {
                  paddingTop: paddingTop
                }
              },
              _react2.default.createElement(
                _reactNative.View,
                {
                  style: styles.extraContainer
                },
                _react2.default.createElement(_Checkbox2.default, {
                  checked: this.state.checked,
                  checkedColor: this.props.color,
                  style: {
                    width: 20,
                    height: 20,
                    borderRadius: 10
                  },
                  onValueChange: function onValueChange(checked) {
                    return _this3.state.checked = checked;
                  }
                }),
                _react2.default.createElement(
                  _reactNative.Text,
                  {
                    style: styles.checkboxText,
                    numberOfLines: 1
                  },
                  this.props.extraText || ''
                )
              )
            );

          default:
            return null;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        if (!this.props.visible) return null;
        var showTitle = !!this.props.title;
        var paddingTop = showTitle ? {
          paddingTop: 0
        } : {};
        var canDismiss = true;

        if (this.props.canDismiss != undefined && this.props.canDismiss == false) {
          canDismiss = false;
        }

        return _react2.default.createElement(
          _AbstractDialog2.default,
          {
            animationType: this.props.animationType,
            visible: this.props.visible,
            title: this.props.title,
            showTitle: showTitle,
            buttons: this.buttons,
            canDismiss: canDismiss,
            onDismiss: function onDismiss(_) {
              return _this4._onDismiss();
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: [styles.container, paddingTop]
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                numberOfLines: 15,
                style: styles.message
              },
              this.props.message || ''
            ),
            this.renderExtra()
          ),
          _react2.default.createElement(_Separator2.default, null)
        );
      }
    }, {
      key: "_onDismiss",
      value: function _onDismiss() {
        this.props.onDismiss && this.props.onDismiss();
      }
    }, {
      key: "onPressUnderlineText",
      value: function onPressUnderlineText() {
        this.hasPressUnderlineText = true;
        var onPress = this.props.extra.onPress;
        onPress && onPress();
      }
    }, {
      key: "onPressCheckbox",
      value: function onPressCheckbox() {
        this.setState({
          checked: !this.state.checked
        });
      }
    }]);
    return MessageDialog;
  }(_react2.default.Component);

  MessageDialog.propTypes = {
    animationType: _propTypes2.default.string,
    visible: _propTypes2.default.bool,
    type: _propTypes2.default.oneOf([TYPE.SIMPLE, TYPE.UNDERLINE, TYPE.CHECKBOX]),
    color: _propTypes2.default.string,
    title: _propTypes2.default.string,
    message: _propTypes2.default.string,
    extraText: _propTypes2.default.string,
    extra: _propTypes2.default.object,
    buttons: _propTypes2.default.arrayOf(_propTypes2.default.object),
    onDismiss: _propTypes2.default.func
  };
  MessageDialog.defaultProps = {
    type: TYPE.SIMPLE,
    color: _resources.Styles.common.MHGreen,
    message: "\u8BF7\u81EA\u5B9A\u4E49\u63D0\u793A\u6587\u6848",
    extra: {}
  };
  MessageDialog.TYPE = TYPE;
  exports.default = MessageDialog;

  var styles = _reactNative.StyleSheet.create({
    container: {
      paddingHorizontal: paddingHorizontal,
      paddingVertical: paddingVertical,
      backgroundColor: '#fff',
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: _resources.Styles.dialog.modal.borderRadius
    },
    message: {
      fontSize: 15,
      color: '#666',
      lineHeight: 22,
      fontFamily: 'MI-LANTING--GBK1-Light',
      fontWeight: '400'
    },
    underlineText: {
      flex: 1,
      textDecorationLine: 'underline',
      fontSize: 14
    },
    extraContainer: {
      flexDirection: 'row',
      alignItems: 'center'
    },
    checkboxText: {
      flex: 1,
      marginLeft: 8,
      fontSize: 14,
      color: '#999'
    }
  });
},10289,[10318,10297,10033,10077,10383,10332,10292],"projects/com.dreame.devices/main/widget/CopyMessageDialog.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _propTypes = _require(_dependencyMap[0]);

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _react = _require(_dependencyMap[1]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[2]);

  var _resources = _require(_dependencyMap[3]);

  var _Separator = _require(_dependencyMap[4]);

  var _Separator2 = babelHelpers.interopRequireDefault(_Separator);

  var _Host = _require(_dependencyMap[5]);

  var _Host2 = babelHelpers.interopRequireDefault(_Host);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var underlayColor = 'rgba(0,0,0,.05)';

  var AbstractDialog = function (_React$Component) {
    babelHelpers.inherits(AbstractDialog, _React$Component);

    function AbstractDialog(props, context) {
      babelHelpers.classCallCheck(this, AbstractDialog);

      var _this = babelHelpers.possibleConstructorReturn(this, (AbstractDialog.__proto__ || Object.getPrototypeOf(AbstractDialog)).call(this, props, context));

      _this.state = {
        visible: _this.props.visible
      };
      return _this;
    }

    babelHelpers.createClass(AbstractDialog, [{
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        if (newProps.visible !== this.state.visible) {
          this.setState({
            visible: newProps.visible
          });
        }
      }
    }, {
      key: "renderTitle",
      value: function renderTitle() {
        if (!this.props.showTitle) return null;
        var _Styles$dialog$title = _resources.Styles.dialog.title,
            titleHeightFat = _Styles$dialog$title.titleHeightFat,
            titleHeightThin = _Styles$dialog$title.titleHeightThin;
        var height = {
          height: this.props.showSubtitle ? titleHeightFat : titleHeightThin
        };
        var marginBottom = this.props.showSubtitle ? {
          marginBottom: 6
        } : {
          height: height.height
        };
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: [styles.titleContainer, height]
          },
          _react2.default.createElement(
            _reactNative.Text,
            {
              numberOfLines: 3,
              style: [{
                width: _resources.Styles.dialog.modal.width * 0.75,
                textAlign: 'center',
                textAlignVertical: 'center',
                fontSize: 15,
                fontWeight: 'bold',
                color: '#000000'
              }, marginBottom]
            },
            this.props.title || ''
          ),
          this.props.showSubtitle ? _react2.default.createElement(
            _reactNative.Text,
            {
              numberOfLines: 1,
              style: _resources.Styles.dialog.subtitle
            },
            this.props.subtitle
          ) : null
        );
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        if (this.props.children) return this.props.children;
        return _react2.default.createElement(
          _reactNative.View,
          null,
          _react2.default.createElement(_Separator2.default, null),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.content
            },
            _react2.default.createElement(
              _reactNative.Text,
              null,
              "\u2B06\uFE0F\u53EF\u81EA\u5B9A\u4E49\u6807\u9898\u548C\u526F\u6807\u9898\u2B06\uFE0F"
            ),
            _react2.default.createElement(
              _reactNative.Text,
              null,
              "\u53EF\u81EA\u5B9A\u4E49\u5185\u5BB9"
            ),
            _react2.default.createElement(
              _reactNative.Text,
              null,
              "\u2B07\uFE0F\u53EF\u81EA\u5B9A\u4E49\u6309\u94AE\u6587\u5B57\u548C\u6837\u5F0F\u2B07\uFE0F"
            )
          ),
          _react2.default.createElement(_Separator2.default, null)
        );
      }
    }, {
      key: "renderButtonGroup",
      value: function renderButtonGroup() {
        if (!this.props.showButton) return null;
        var buttons = this.props.buttons;
        if (!(buttons instanceof Array)) return null;
        if (buttons.length === 1) return this.renderOneButton(buttons);
        if (buttons.length === 2) return this.renderTwoButtons(buttons);else {
          console.warn('只允许设置1～2个按钮');
          return null;
        }
      }
    }, {
      key: "renderOneButton",
      value: function renderOneButton(buttons) {
        var _this2 = this;

        var button0 = buttons[0];
        if (typeof button0 !== 'object') return null;
        var callback = button0.callback;

        if (callback === undefined || !(callback instanceof Function)) {
          callback = function callback(_) {
            return _this2.dismiss();
          };
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: _resources.Styles.dialog.buttons
          },
          _react2.default.createElement(
            _reactNative.TouchableHighlight,
            {
              style: [_resources.Styles.dialog.button, {
                borderBottomLeftRadius: _resources.Styles.dialog.modal.borderRadius
              }],
              onPress: callback,
              underlayColor: underlayColor
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [_resources.Styles.dialog.buttonText, button0.style]
              },
              button0.text || _resources.strings.ok
            )
          )
        );
      }
    }, {
      key: "renderTwoButtons",
      value: function renderTwoButtons(buttons) {
        var _this3 = this;

        var button0 = buttons[0],
            button1 = buttons[1];
        if (typeof button0 !== 'object' || typeof button1 !== 'object') return null;
        var callback0 = button0.callback;
        var callback1 = button1.callback;

        if (callback0 === undefined || !(callback0 instanceof Function)) {
          callback0 = function callback0(_) {
            return _this3.dismiss();
          };
        }

        if (callback1 === undefined || !(callback1 instanceof Function)) {
          callback1 = function callback1(_) {
            return _this3.dismiss();
          };
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: _resources.Styles.dialog.buttons
          },
          _react2.default.createElement(
            _reactNative.TouchableHighlight,
            {
              style: [_resources.Styles.dialog.button, {
                borderBottomLeftRadius: _resources.Styles.dialog.modal.borderRadius
              }],
              onPress: callback0,
              underlayColor: underlayColor
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [_resources.Styles.dialog.buttonText, button0.style]
              },
              button0.text || _resources.strings.cancel
            )
          ),
          _react2.default.createElement(_Separator2.default, {
            type: "column",
            style: {
              height: _resources.Styles.dialog.buttons.height
            }
          }),
          _react2.default.createElement(
            _reactNative.TouchableHighlight,
            {
              style: [_resources.Styles.dialog.button, {
                borderBottomRightRadius: _resources.Styles.dialog.modal.borderRadius
              }],
              onPress: callback1,
              underlayColor: underlayColor
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [_resources.Styles.dialog.buttonText, {
                  color: _resources.Styles.common.MHGreen
                }, button1.style]
              },
              button1.text || _resources.strings.ok
            )
          )
        );
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        return _react2.default.createElement(
          _reactNative.Modal,
          {
            animationType: this.props.animationType,
            transparent: true,
            visible: this.state.visible,
            onRequestClose: function onRequestClose(_) {
              return _this4.dismiss();
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: _resources.Styles.dialog.background
            },
            _react2.default.createElement(
              _reactNative.TouchableWithoutFeedback,
              {
                onPress: function onPress(_) {
                  return _this4.dismiss();
                }
              },
              _react2.default.createElement(_reactNative.View, {
                style: {
                  width: width,
                  height: height
                }
              })
            ),
            _react2.default.createElement(
              _reactNative.View,
              {
                style: [_resources.Styles.dialog.modal, this.props.style]
              },
              this.renderTitle(),
              this.renderContent(),
              this.renderButtonGroup()
            )
          )
        );
      }
    }, {
      key: "dismiss",
      value: function dismiss() {
        if (this.props.canDismiss) {
          this.setState({
            visible: false
          });
          this.props.onDismiss && this.props.onDismiss();
        }
      }
    }]);
    return AbstractDialog;
  }(_react2.default.Component);

  AbstractDialog.propTypes = {
    animationType: _propTypes2.default.string,
    visible: _propTypes2.default.bool,
    style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.number]),
    title: _propTypes2.default.string,
    subtitle: _propTypes2.default.string,
    showTitle: _propTypes2.default.bool,
    showSubtitle: _propTypes2.default.bool,
    canDismiss: _propTypes2.default.bool,
    buttons: _propTypes2.default.arrayOf(_propTypes2.default.object),
    showButton: _propTypes2.default.bool,
    onDismiss: _propTypes2.default.func
  };
  AbstractDialog.defaultProps = {
    animationType: 'fade',
    visible: false,
    showTitle: true,
    showSubtitle: false,
    canDismiss: true,
    buttons: [{
      text: _resources.strings.cancel
    }, {
      text: _resources.strings.ok,
      style: {
        color: _resources.Styles.common.MHGreen
      }
    }],
    showButton: true
  };
  exports.default = AbstractDialog;

  var styles = _reactNative.StyleSheet.create({
    titleContainer: {
      justifyContent: 'center',
      alignItems: 'center'
    },
    content: {
      width: _resources.Styles.dialog.modal.width,
      height: 150,
      justifyContent: 'center',
      alignItems: 'center'
    }
  });
},10292,[10318,10297,10033,10077,10332,10035],"projects/com.dreame.devices/main/widget/AbstractDialog.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "f0cf74a7b8ad431c9036e6ee2a5332d0",
      "name": "info",
      "type": "png"
   });
},10295,[10420],"projects/com.dreame.devices/resources/info.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "5e8b57d4eb0cf30463ea2619e5ab5493",
      "name": "error",
      "type": "png"
   });
},10298,[10420],"projects/com.dreame.devices/resources/error.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "a98fcd6db32eecc70461c400fb654760",
      "name": "pause_charge",
      "type": "png"
   });
},10301,[10420],"projects/com.dreame.devices/resources/pause_charge.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "50851a1db10a5e5170f5c415698cbe35",
      "name": "gochange",
      "type": "png"
   });
},10304,[10420],"projects/com.dreame.devices/resources/gochange.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "f4fdd6e38b225bee0c34100ed207fb1e",
      "name": "pause",
      "type": "png"
   });
},10307,[10420],"projects/com.dreame.devices/resources/pause.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "72da6d6c9d72ff61ea24c3947dc16234",
      "name": "start_clean",
      "type": "png"
   });
},10310,[10420],"projects/com.dreame.devices/resources/start_clean.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "c8f948edb0659750b8582673a6663753",
      "name": "clock",
      "type": "png"
   });
},10313,[10420],"projects/com.dreame.devices/resources/clock.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 110,
      "height": 110,
      "scales": [1],
      "hash": "7a6ff35c64f896b49ebb00150cdab65f",
      "name": "voice",
      "type": "png"
   });
},10316,[10420],"projects/com.dreame.devices/resources/voice.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 136,
      "height": 136,
      "scales": [1],
      "hash": "4fbae0e3f71d7a97d87ef61489c79df9",
      "name": "spot_disable",
      "type": "png"
   });
},10319,[10420],"projects/com.dreame.devices/resources/spot_disable.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 136,
      "height": 136,
      "scales": [1],
      "hash": "a0882f8a93c5d7c956a95d0d33562376",
      "name": "spot_cancle",
      "type": "png"
   });
},10322,[10420],"projects/com.dreame.devices/resources/spot_cancle.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 136,
      "height": 136,
      "scales": [1],
      "hash": "f60e24aaa375c47ed2cd863178562a1b",
      "name": "spot_enable",
      "type": "png"
   });
},10325,[10420],"projects/com.dreame.devices/resources/spot_enable.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 136,
      "height": 136,
      "scales": [1],
      "hash": "b97db7c3060bcf9f45db0392d4d12426",
      "name": "area_disable",
      "type": "png"
   });
},10328,[10420],"projects/com.dreame.devices/resources/area_disable.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 136,
      "height": 136,
      "scales": [1],
      "hash": "1f172d49234404c654d75c9ba2ca3d9e",
      "name": "area_cancle",
      "type": "png"
   });
},10331,[10420],"projects/com.dreame.devices/resources/area_cancle.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 136,
      "height": 136,
      "scales": [1],
      "hash": "8bffea4425d6dc772d2ce8096ce7591f",
      "name": "area_enable",
      "type": "png"
   });
},10334,[10420],"projects/com.dreame.devices/resources/area_enable.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _Toast = _require(_dependencyMap[5]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var _reactNativeUiKitten = _require(_dependencyMap[6]);

  var _TextButton = _require(_dependencyMap[7]);

  var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

  var _miot = _require(_dependencyMap[8]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var did = _miot.Device.getDeviceWifi().deviceID;

  var SettingPage = function (_React$Component) {
    babelHelpers.inherits(SettingPage, _React$Component);

    function SettingPage(props) {
      babelHelpers.classCallCheck(this, SettingPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (SettingPage.__proto__ || Object.getPrototypeOf(SettingPage)).call(this, props));

      _this.robotSetting = function () {
        _this.props.navigation.navigate("robotSetting");
      };

      _this.timingTask = function () {
        _this.props.navigation.navigate("timingTask");
      };

      _this.cleanLog = function () {
        _this.props.navigation.navigate("cleanLog");
      };

      _this.onSwitchValueChange = function (newValue) {};

      _this.material = function () {
        _this.props.navigation.navigate("material");
      };

      _this.locationRobot = function () {
        if (!_this.locationTime || Date.now() - _this.startClickTime > 5000) {
          _this.locationTime = 0;
          _this.startClickTime = Date.now();
        }

        _this.locationTime++;

        if (_this.locationTime == 3 && Date.now() - _this.startClickTime < 5000) {
          _this.locationTime = 0;
          _this.startClickTime = 0;

          _this.showToast("插件版本：" + _miot.Package.version);
        }

        _miot.Device.getDeviceWifi().callMethod("action", {
          "did": did,
          "siid": 17,
          "aiid": 1
        }).then(function (res) {
          console.log("-----------", res);
        });
      };

      _this.showToast = function (msg) {
        if (_this.refs.toast) {
          _this.refs.toast.show(msg, 2200);
        }
      };

      _this.renameRobot = function () {
        _miot.Host.ui.openChangeDeviceName();
      };

      _this.shareRobot = function () {
        _miot.Host.ui.openShareDevicePage();
      };

      _this.intelligentScene = function () {
        _miot.Host.ui.openIftttAutoPage();
      };

      _this.locationManager = function () {
        _miot.Host.ui.openRoomManagementPage();
      };

      _this.checkVersion = function () {
        _this.props.navigation.navigate("ota");
      };

      _this.deleteDevice = function () {
        _miot.Host.ui.openDeleteDevice();
      };

      _this.addDesktop = function () {
        _miot.Host.ui.openAddToDesktopPage();
      };

      _this.moreSetting = function () {
        _miot.Host.ui.openSecuritySetting();
      };

      _this.networkInfo = function () {
        _this.props.navigation.navigate("netInfo");
      };

      _this.deviceTimeZone = function () {
        _miot.Host.ui.openDeviceTimeZoneSettingPage();
      };

      _this.feedback = function () {
        _miot.Host.ui.openFeedbackInput();
      };

      _this.agreement = function () {
        _miot.Host.ui.privacyAndProtocolReview((0, _MHLocalizableString.getString)('licenseTitle'), Const.license, (0, _MHLocalizableString.getString)('policyTitle'), Const.policy);
      };

      _this.state = {
        timeZone: gData.timeZone,
        name: _miot.Device.name,
        hasNewFirmware: gData.hasNewFirmware == true ? true : false
      };
      _this.startClickTime = 0;
      _this.lastClickRemote = 0;
      return _this;
    }

    babelHelpers.createClass(SettingPage, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._deviceNameChangedListener) {
          this._deviceNameChangedListener.remove();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this._deviceNameChangedListener = _miot.DeviceEvent.deviceNameChanged.addListener(function (device) {
          _this2.setState({
            name: device.name
          });
        });
        this.willBlurListener = this.props.navigation.addListener('willBlur', function () {});
        this.didFocusListener = this.props.navigation.addListener('willFocus', function () {
          _this2.setState({
            hasNewFirmware: gData.hasNewFirmware == true ? true : false
          });
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var hasNewFirmware = this.state.hasNewFirmware;
        var showRobotDot = false;
        var params = this.props.navigation.state.params;

        if (params) {
          showRobotDot = gData.timeZone != undefined && gData.timeZone != gData.localTimeZone;
        }

        return _react2.default.createElement(
          _reactNative.ScrollView,
          {
            style: styles.container
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                width: width,
                height: 35
              },
              justifyContent: "center",
              alignItems: "flex-start"
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  color: 'rgba(0,0,0,0.6)',
                  fontSize: 13,
                  fontWeight: "100",
                  fontFamily: Const.fontFamily,
                  marginLeft: 25,
                  textAlignVertical: 'center',
                  textAlign: 'center'
                }
              },
              (0, _MHLocalizableString.getString)('functionSetting')
            )
          ),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('robotSetting'),
            showDot: showRobotDot,
            onPress: this.robotSetting
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('cleanLog'),
            onPress: this.cleanLog
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('materialTime'),
            onPress: this.material
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('remoteControl'),
            onPress: function onPress() {
              if (Date.now() - _this3.lastClickRemote > 500) {
                _this3.lastClickRemote = Date.now();

                _this3.props.navigation.navigate('RemoteControlPage');
              }
            }
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line2
          }),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                width: width,
                height: 35
              },
              justifyContent: "center",
              alignItems: "flex-start"
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  color: 'rgba(0,0,0,0.6)',
                  fontSize: 13,
                  fontWeight: "100",
                  marginLeft: 25,
                  textAlignVertical: 'center',
                  fontFamily: Const.fontFamily,
                  textAlign: 'center'
                }
              },
              (0, _MHLocalizableString.getString)('generalSetting')
            )
          ),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _miot.Device.isOwner ? _react2.default.createElement(
            _reactNative.View,
            null,
            _react2.default.createElement(_SettingListItemView2.default, {
              style: {
                minHeight: 55,
                paddingLeft: 25,
                paddingRight: 25,
                paddingTop: Const.minTextSpacing,
                paddingBottom: Const.minTextSpacing,
                flex: 1.0
              },
              leftText: (0, _MHLocalizableString.getString)('deveiceName'),
              rightText: _miot.Host.locale.language == "zh" ? this.state.name : undefined,
              desc: _miot.Host.locale.language == "zh" ? undefined : this.state.name,
              onPress: this.renameRobot
            }),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            }),
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              leftText: (0, _MHLocalizableString.getString)('locationManager'),
              onPress: this.locationManager
            }),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            }),
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              leftText: (0, _MHLocalizableString.getString)('deviceShare'),
              onPress: this.shareRobot
            }),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            }),
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              leftText: (0, _MHLocalizableString.getString)('IntelligentScene'),
              onPress: this.intelligentScene
            }),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            }),
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              showDot: hasNewFirmware,
              leftText: (0, _MHLocalizableString.getString)('otaCheck'),
              onPress: this.checkVersion
            }),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            })
          ) : null,
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('moreSetting'),
            onPress: function onPress() {
              _this3.props.navigation.navigate('generalSetting', {
                hasNewFirmware: hasNewFirmware
              });
            }
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('productGuide'),
            onPress: function onPress() {
              _miot.Host.ui.openHelpPage();
            }
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('useTerms'),
            onPress: this.agreement
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line2
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: {
              minHeight: 55,
              paddingLeft: 25,
              paddingRight: 25,
              paddingTop: 5.5,
              paddingBottom: 5.5,
              flex: 1.0
            },
            leftText: (0, _MHLocalizableString.getString)('locationRobot'),
            hideArrow: true,
            onPress: this.locationRobot
          }),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                height: 100,
                width: width,
                backgroundColor: "#f7f7f7",
                padding: 26
              }
            },
            _react2.default.createElement(_TextButton2.default, {
              style: {
                width: width - 52,
                height: 48,
                borderColor: 'rgba(0,0,0,0.2)',
                borderWidth: _reactNative.StyleSheet.hairlineWidth
              },
              normalColor: "#ffffffff",
              pressColor: "#f2f2f2",
              text: (0, _MHLocalizableString.getString)('deleteDevice'),
              onPress: this.deleteDevice,
              textStyle: {
                color: "#ec2700",
                fontFamily: Const.fontFamily,
                fontSize: 15
              }
            })
          ),
          _react2.default.createElement(_Toast2.default, {
            ref: "toast",
            position: 'center',
            height: Const.contentViewHeight
          })
        );
      }
    }]);
    return SettingPage;
  }(_react2.default.Component);

  SettingPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('setting'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = SettingPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: '#fff'
    },
    listItem: {
      height: 55,
      paddingLeft: 25,
      paddingRight: 25,
      flex: 1.0
    },
    line: {
      height: 1 / _reactNative.PixelRatio.get(),
      flex: 1.0,
      marginLeft: 25,
      backgroundColor: 'rgba(0,0,0,0.1)'
    },
    line2: {
      height: 9,
      flex: 1.0,
      backgroundColor: '#f7f7f7'
    }
  });
},10337,[10297,10033,10121,10157,10340,10343,11251,10346,10074],"projects/com.dreame.devices/main/SettingPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _reactNativeUiKitten = _require(_dependencyMap[2]);

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var ListItemView = function (_React$Component) {
        babelHelpers.inherits(ListItemView, _React$Component);

        function ListItemView(props) {
            babelHelpers.classCallCheck(this, ListItemView);

            var _this = babelHelpers.possibleConstructorReturn(this, (ListItemView.__proto__ || Object.getPrototypeOf(ListItemView)).call(this, props));

            _this.handleSetViewport = function (e) {
                var mainProps = {};
                var layout = e.nativeEvent.layout;
                mainProps.width = layout.width;
                mainProps.height = layout.height;

                if (_this.cover) {
                    _this.cover.setNativeProps({
                        style: mainProps
                    });
                }
            };

            _this.isPressed = false;
            _this.state = {
                switchState: _this.props.switchState
            };
            return _this;
        }

        babelHelpers.createClass(ListItemView, [{
            key: "setSwitchState",
            value: function setSwitchState(state) {
                this.setState({
                    switchState: state
                });
            }
        }, {
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.isPressed = true;

                if (this.props.onPress && this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(0,0,0,0.05)',
                            backgroundColor: 'rgba(0,0,0,0.05)'
                        }
                    });
                }
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.isPressed = false;

                if (this.props.onPress && this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(255,255,255,0)',
                            backgroundColor: 'rgba(255,255,255,0)'
                        }
                    });
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: [styles.cardStyle, this.props.style],
                        onLayout: this.handleSetViewport,
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            flex: 1.0
                        },
                        _react2.default.createElement(
                            _reactNative.View,
                            {
                                flexDirection: "row"
                            },
                            _react2.default.createElement(
                                _reactNative.Text,
                                {
                                    style: {
                                        fontSize: 17,
                                        fontFamily: Const.fontFamily,
                                        color: 'rgba(0,0,0,1)'
                                    }
                                },
                                this.props.leftText
                            )
                        ),
                        this.props.desc && _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13,
                                    marginTop: 0,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.6)',
                                    paddingBottom: 3
                                }
                            },
                            this.props.desc
                        )
                    ),
                    this.props.showSwitch && _react2.default.createElement(_reactNativeUiKitten.RkSwitch, {
                        style: {
                            borderRadius: 16,
                            backgroundColor: '#f0f0f0'
                        },
                        tintColor: "#e3e3e3",
                        onTintColor: "#5696ff",
                        value: this.props.switchState,
                        onValueChange: function onValueChange() {
                            var change = !_this2.props.switchState;

                            if (_this2.props.onValueChange) {
                                _this2.props.onValueChange(change);
                            }
                        }
                    }),
                    this.props.rightText && _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: {
                                fontSize: 15,
                                fontFamily: Const.fontFamily,
                                marginRight: 5,
                                maxWidth: width / 2,
                                color: 'rgba(0,0,0,0.4)'
                            },
                            ellipsizeMode: "tail",
                            numberOfLines: 1
                        },
                        this.props.rightText
                    ),
                    this.props.showDot && _react2.default.createElement(_reactNative.Image, {
                        style: {
                            width: 10,
                            height: 10,
                            marginRight: 5,
                            resizeMode: 'contain'
                        },
                        source: _require(_dependencyMap[3])
                    }),
                    _react2.default.createElement(_reactNative.Image, {
                        style: {
                            width: this.props.hideArrow === true ? 0 : 15,
                            height: this.props.hideArrow === true ? 0 : 15
                        },
                        resizeMode: "contain",
                        source: _require(_dependencyMap[4])
                    }),
                    !this.props.showSwitch && _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this.props.onPress,
                            onPressIn: this._buttonPressIn.bind(this),
                            onPressOut: this._buttonPressOut.bind(this)
                        },
                        _react2.default.createElement(_reactNative.View, {
                            style: [styles.coverStyle, this.isPressed ? {
                                backgroundColor: 'rgba(0,0,0,0.5)'
                            } : {
                                backgroundColor: 'rgba(0,0,0,0)'
                            }],
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        })
                    )
                );
            }
        }]);
        return ListItemView;
    }(_react2.default.Component);

    ListItemView.defaultProps = {
        onPress: null,
        switchState: false
    };
    exports.default = ListItemView;

    var styles = _reactNative.StyleSheet.create({
        cardStyle: {
            flexDirection: "row"
        },
        coverStyle: {
            left: 0,
            top: 0,
            position: 'absolute',
            borderColor: 'transparent',
            borderWidth: _reactNative.StyleSheet.hairlineWidth
        }
    });
},10340,[10297,10033,11251,10154,10283],"projects/com.dreame.devices/main/widget/SettingListItemView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.DURATION = undefined;

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _propTypes = _require(_dependencyMap[1]);

    var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

    var _reactNative = _require(_dependencyMap[2]);

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var OPACITY = 0.8;
    var DURATION = exports.DURATION = {
        LONG: 1500,
        SHORT: 500
    };

    var Toast = function (_Component) {
        babelHelpers.inherits(Toast, _Component);

        function Toast(props) {
            babelHelpers.classCallCheck(this, Toast);

            var _this = babelHelpers.possibleConstructorReturn(this, (Toast.__proto__ || Object.getPrototypeOf(Toast)).call(this, props));

            _this.state = {
                text: '',
                isShow: false,
                opacityAnimate: new _reactNative.Animated.Value(OPACITY)
            };
            _this.isShow = false;
            _this.duration = DURATION.SHORT;
            return _this;
        }

        babelHelpers.createClass(Toast, [{
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this.animateTimer && clearTimeout(this.animateTimer);
            }
        }, {
            key: "show",
            value: function show(text, duration) {
                if (duration >= DURATION.LONG) {
                    this.duration = DURATION.LONG;
                } else if (duration < DURATION.SHORT) {
                    this.duration = DURATION.SHORT;
                } else {
                    this.duration = duration;
                }

                this.setState({
                    text: text,
                    isShow: true
                });
                this.isShow = true;
                this.state.opacityAnimate.setValue(OPACITY);
                this.hide();
            }
        }, {
            key: "hide",
            value: function hide() {
                var _this2 = this;

                if (!this.isShow) {
                    return;
                }

                this.animateTimer && clearTimeout(this.animateTimer);
                this.animateTimer = setTimeout(function () {
                    _reactNative.Animated.timing(_this2.state.opacityAnimate, {
                        toValue: 0.0,
                        duration: 600
                    }).start(function () {
                        _this2.setState({
                            isShow: false
                        });

                        _this2.isShow = false;
                    });
                }, this.duration);
            }
        }, {
            key: "render",
            value: function render() {
                var top = void 0;
                var h = height;

                if (this.props.height) {
                    h = height;
                }

                switch (this.props.position) {
                    case 'top':
                        top = 30;
                        break;

                    case 'center':
                        top = h / 2;
                        break;

                    case 'bottom':
                        top = h - 200;
                        break;

                    default:
                        break;
                }

                return this.state.isShow ? _react2.default.createElement(
                    _reactNative.View,
                    {
                        pointerEvents: 'none',
                        style: [styles.container, {
                            top: top
                        }]
                    },
                    _react2.default.createElement(
                        _reactNative.Animated.View,
                        {
                            style: [styles.content, this.props.contentStyle, {
                                opacity: this.state.opacityAnimate
                            }]
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: [styles.text, this.props.textStyle, {
                                    fontFamily: Const.fontFamily
                                }]
                            },
                            this.state.text
                        )
                    )
                ) : null;
            }
        }]);
        return Toast;
    }(_react.Component);

    Toast.propTypes = {
        textStyle: _reactNative.ViewPropTypes.style,
        contentStyle: _reactNative.ViewPropTypes.style,
        containerStyle: _reactNative.ViewPropTypes.style,
        position: _propTypes2.default.oneOf(['top', 'center', 'bottom'])
    };
    Toast.defaultProps = {
        position: 'center'
    };
    exports.default = Toast;

    var styles = _reactNative.StyleSheet.create({
        container: {
            position: 'absolute',
            left: 0,
            right: 0,
            alignItems: 'center'
        },
        content: {
            backgroundColor: '#000000',
            opacity: OPACITY,
            borderRadius: 20,
            padding: 10
        },
        text: {
            color: '#FFFFFF',
            fontSize: 14,
            paddingLeft: 10,
            paddingRight: 10
        }
    });
},10343,[10297,10318,10033],"projects/com.dreame.devices/main/widget/Toast.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _ui = _require(_dependencyMap[2]);

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var TextButton = function (_React$Component) {
        babelHelpers.inherits(TextButton, _React$Component);

        function TextButton(props) {
            babelHelpers.classCallCheck(this, TextButton);

            var _this = babelHelpers.possibleConstructorReturn(this, (TextButton.__proto__ || Object.getPrototypeOf(TextButton)).call(this, props));

            _this.handleSetViewport = function (e) {
                if (_this.props.onLayout) {
                    _this.props.onLayout(e);
                }
            };

            _this.isPressed = false;
            return _this;
        }

        babelHelpers.createClass(TextButton, [{
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.isPressed = true;

                if (this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            backgroundColor: this.props.pressColor
                        }
                    });
                }
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.isPressed = false;

                if (this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            backgroundColor: this.props.normalColor
                        }
                    });
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;

                return _react2.default.createElement(
                    _reactNative.TouchableWithoutFeedback,
                    {
                        onPress: this.props.onPress,
                        onPressIn: this._buttonPressIn.bind(this),
                        onPressOut: this._buttonPressOut.bind(this),
                        onLayout: this.handleSetViewport
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: [styles.cardStyle, this.props.style, this.isPressed ? {
                                backgroundColor: this.props.pressColor
                            } : {
                                backgroundColor: this.props.normalColor
                            }],
                            justifyContent: "center",
                            alignItems: "center",
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: [this.props.textStyle]
                            },
                            this.props.text
                        )
                    )
                );
            }
        }]);
        return TextButton;
    }(_react2.default.Component);

    TextButton.defaultProps = {
        onPress: null
    };
    exports.default = TextButton;

    var styles = _reactNative.StyleSheet.create({
        cardStyle: {
            borderRadius: 5
        },
        coverStyle: {
            left: 0,
            top: 0,
            position: 'absolute',
            borderColor: 'transparent',
            borderWidth: _reactNative.StyleSheet.hairlineWidth
        }
    });
},10346,[10297,10033,10230],"projects/com.dreame.devices/main/widget/TextButton.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _miot = _require(_dependencyMap[5]);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var RobotSettingPage = function (_React$Component) {
    babelHelpers.inherits(RobotSettingPage, _React$Component);

    function RobotSettingPage(props) {
      babelHelpers.classCallCheck(this, RobotSettingPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (RobotSettingPage.__proto__ || Object.getPrototypeOf(RobotSettingPage)).call(this, props));

      _this.timezoneSetting = function () {
        _this.props.navigation.navigate("timeZone");
      };

      _this.voiceSetting = function () {
        _this.props.navigation.navigate("volume");
      };

      _this.distrubSetting = function () {
        _this.props.navigation.navigate("nodistrub");
      };

      _this.goVoiceManage = function () {
        _this.props.navigation.navigate("voiceManage");
      };

      _this.onSwitchValueChange = function (switchState) {
        _this.setState({
          pushSwitch: switchState
        });

        var batchData = {};
        batchData.did = _miot.Device.deviceID;
        batchData.props = {};
        batchData.props["prop.s_push_switch_" + _miot.Service.account.ID] = switchState ? "3" : "0";

        _miot.Service.smarthome.batchSetDeviceDatas([batchData]).then(function (res) {
          gData.pushSwitch = switchState;
        }).catch(function (err) {});
      };

      _this.state = {
        timeZone: gData.timeZone === undefined ? " " : gData.timeZone,
        pushSwitch: gData.pushSwitch == true ? true : false
      };

      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 25,
        "piid": 1
      }]).then(function (res) {
        if (res.code == 0) {
          for (var i = 0; i < res.result.length; i++) {
            var item = res.result[i];

            if (item.code != 0) {
              continue;
            }

            switch (item.siid) {
              case 25:
                if (item.piid == 1) {
                  gData.timeZone = item.value;

                  _this.setState({
                    timeZone: item.value
                  });
                }

                break;

              case 22:
                if (item.piid == 2) {
                  gData.pushSwitch = item.value == 1;
                }

                _this.setState({
                  pushSwitch: gData.pushSwitch
                });

                break;

              default:
                break;
            }
          }
        }
      }).catch(function (err) {});

      _miot.Service.smarthome.batchGetDeviceDatas([{
        did: _miot.Device.deviceID,
        props: ["prop.s_push_switch_" + _miot.Service.account.ID]
      }]).then(function (res) {
        var result = res[_miot.Device.deviceID];
        var config = void 0;

        if (result && result['prop.s_push_switch_' + _miot.Service.account.ID]) {
          config = result['prop.s_push_switch_' + _miot.Service.account.ID];
        }

        gData.pushSwitch = true;

        if (config == "0") {
          gData.pushSwitch = false;
        }

        _this.setState({
          pushSwitch: gData.pushSwitch
        });
      });

      return _this;
    }

    babelHelpers.createClass(RobotSettingPage, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.willBlurListener) {
          this.willBlurListener.remove();
        }

        if (this.didFocusListener) {
          this.didFocusListener.remove();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this.willBlurListener = this.props.navigation.addListener('willBlur', function () {});
        this.didFocusListener = this.props.navigation.addListener('willFocus', function () {
          _this2.setState({
            timeZone: gData.timeZone
          });
        });
      }
    }, {
      key: "getShowTimeZone",
      value: function getShowTimeZone() {
        if (this.state.timeZone == "Asia/Shanghai") {
          return "Asia/Beijing";
        }

        return this.state.timeZone;
      }
    }, {
      key: "render",
      value: function render() {
        return _react2.default.createElement(
          _reactNative.ScrollView,
          {
            style: styles.container
          },
          _react2.default.createElement(_SettingListItemView2.default, {
            style: {
              minHeight: 55,
              paddingLeft: 25,
              paddingRight: 25,
              paddingTop: Const.minTextSpacing,
              paddingBottom: Const.minTextSpacing,
              flex: 1.0
            },
            leftText: (0, _MHLocalizableString.getString)('timeZone'),
            showDot: this.state.timeZone && this.state.timeZone != gData.localTimeZone,
            rightText: _miot.Host.locale.language == "zh" ? this.getShowTimeZone() : undefined,
            desc: _miot.Host.locale.language == "zh" ? undefined : this.getShowTimeZone(),
            onPress: this.timezoneSetting
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('volume'),
            onPress: this.voiceSetting
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('disturbTime'),
            onPress: this.distrubSetting
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('msgSwitch'),
            showSwitch: true,
            switchState: this.state.pushSwitch,
            onValueChange: this.onSwitchValueChange,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          })
        );
      }
    }]);
    return RobotSettingPage;
  }(_react2.default.Component);

  RobotSettingPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('robotSetting'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = RobotSettingPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: '#fff'
    },
    listItem: {
      height: 55,
      paddingLeft: 25,
      paddingRight: 25,
      flex: 1.0
    },
    line: {
      height: 1 / _reactNative.PixelRatio.get(),
      flex: 1.0,
      marginLeft: 25,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10349,[10297,10033,10121,10157,10340,10074],"projects/com.dreame.devices/main/RobotSettingPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _Toast = _require(_dependencyMap[5]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var _miot = _require(_dependencyMap[6]);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var TimeZonePage = function (_React$Component) {
    babelHelpers.inherits(TimeZonePage, _React$Component);

    function TimeZonePage(props) {
      babelHelpers.classCallCheck(this, TimeZonePage);

      var _this = babelHelpers.possibleConstructorReturn(this, (TimeZonePage.__proto__ || Object.getPrototypeOf(TimeZonePage)).call(this, props));

      _this.timezoneSetting = function () {
        _miot.Host.locale.getSystemTimeZone().then(function (res) {
          if (res.timeZone) {
            gData.localTimeZone = res.timeZone;
          } else if (typeof res == "string") {
            gData.localTimeZone = res;
          }

          return _miot.Device.getDeviceWifi().callMethod("miIO.config_tz", {
            "tz": gData.localTimeZone
          });
        }).then(function (res) {
          gData.timeZone = gData.localTimeZone;

          _this.showToast((0, _MHLocalizableString.getString)('syncSuccess'));
        }).catch(function (err) {
          console.log('failed:', err);
        });
      };

      _this.showToast = function (msg) {
        if (_this.refs.toast) {
          _this.refs.toast.show(msg, 1200);
        }
      };

      console.log("--------", _miot.Host.locale.timeZone);
      return _this;
    }

    babelHelpers.createClass(TimeZonePage, [{
      key: "render",
      value: function render() {
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container
          },
          _react2.default.createElement(
            _reactNative.View,
            null,
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  marginTop: 25,
                  marginBottom: 20,
                  paddingLeft: 25,
                  paddingRight: 25,
                  fontFamily: Const.fontFamily,
                  fontSize: 15,
                  color: 'rgba(0,0,0,1.0)'
                }
              },
              (0, _MHLocalizableString.getString)('timezoneTip1')
            ),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            }),
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              leftText: (0, _MHLocalizableString.getString)('syncTimeZone'),
              hideArrow: true,
              onPress: this.timezoneSetting
            }),
            _react2.default.createElement(_reactNative.View, {
              style: styles.line
            }),
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  marginTop: 20,
                  paddingLeft: 25,
                  paddingRight: 25,
                  fontFamily: Const.fontFamily,
                  fontSize: 13,
                  color: 'rgba(0,0,0,0.4)'
                }
              },
              (0, _MHLocalizableString.getString)('timezoneTip2')
            )
          ),
          _react2.default.createElement(_Toast2.default, {
            ref: "toast",
            position: 'center',
            height: Const.contentViewHeight
          })
        );
      }
    }]);
    return TimeZonePage;
  }(_react2.default.Component);

  TimeZonePage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('timeZone'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = TimeZonePage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: 'rgba(255,255,255,1)',
      flex: 1.0
    },
    listItem: {
      height: 55,
      width: width,
      paddingLeft: 25,
      paddingRight: 25
    },
    line: {
      height: 1 / _reactNative.PixelRatio.get(),
      width: width,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10352,[10297,10033,10121,10157,10340,10343,10074],"projects/com.dreame.devices/main/TimeZonePage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _SliderView = _require(_dependencyMap[5]);

  var _SliderView2 = babelHelpers.interopRequireDefault(_SliderView);

  var _Toast = _require(_dependencyMap[6]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var _reactNativeUiKitten = _require(_dependencyMap[7]);

  var _TextButton = _require(_dependencyMap[8]);

  var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

  var _miot = _require(_dependencyMap[9]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var did = _miot.Device.getDeviceWifi().deviceID;

  var VolumeSettingPage = function (_React$Component) {
    babelHelpers.inherits(VolumeSettingPage, _React$Component);

    function VolumeSettingPage(props) {
      babelHelpers.classCallCheck(this, VolumeSettingPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (VolumeSettingPage.__proto__ || Object.getPrototypeOf(VolumeSettingPage)).call(this, props));

      _this.onProcessChange = function (volume) {
        _this.volume = volume;

        _miot.Device.getDeviceWifi().callMethod("set_properties", [{
          "did": did,
          "siid": 24,
          "piid": 1,
          "value": volume
        }]).then(function (res) {
          console.log("-----------", res);
        }).catch(function (err) {
          _this.showToast((0, _MHLocalizableString.getString)('netErr'));

          console.log('changeMode failed:', err);
        });
      };

      _this.showToast = function (msg) {
        _this.refs.toast.show(msg, 1200);
      };

      _this.listen = function () {
        _miot.Device.getDeviceWifi().callMethod("action", {
          "did": did,
          "siid": 17,
          "aiid": 3
        }).then(function (res) {
          console.log("-----------", res);
        });
      };

      _this.volume = 0;

      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 24,
        "piid": 1
      }]).then(function (res) {
        if (res.code == 0) {
          var updateState = {};

          for (var i = 0; i < res.result.length; i++) {
            var item = res.result[i];

            if (item.code != 0) {
              continue;
            }

            switch (item.siid) {
              case 24:
                if (item.piid == 1) {
                  _this.volume = item.value;

                  if (_this.slider) {
                    _this.slider.setProcess(_this.volume);
                  }
                }

                break;

              default:
                break;
            }
          }
        }
      }).catch(function (err) {
        console.log('failed:', err);

        _this.showToast((0, _MHLocalizableString.getString)('netErr'));
      });

      return _this;
    }

    babelHelpers.createClass(VolumeSettingPage, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container
          },
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: {
                paddingTop: 20,
                paddingLeft: 20,
                paddingRight: 20,
                paddingBottom: 20,
                fontFamily: Const.fontFamily,
                fontSize: 13,
                color: 'rgba(0,0,0,0.4)'
              }
            },
            (0, _MHLocalizableString.getString)('volumeTip')
          ),
          _react2.default.createElement(_reactNative.View, {
            style: {
              height: 10,
              width: width,
              backgroundColor: '#f7f7f7'
            }
          }),
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                marginLeft: 20,
                marginRight: 20,
                height: 77,
                justifyContent: 'center',
                alignItems: 'center',
                flexDirection: "row"
              }
            },
            _react2.default.createElement(_reactNative.Image, {
              style: {
                width: 16,
                height: 16
              },
              source: _require(_dependencyMap[10]),
              resizeMode: "contain"
            }),
            _react2.default.createElement(_SliderView2.default, {
              ref: function ref(_ref) {
                _this2.slider = _ref;
              },
              process: this.volume,
              width: width - 90,
              height: 50,
              onProcessChange: this.onProcessChange
            }),
            _react2.default.createElement(_reactNative.Image, {
              style: {
                width: 16,
                height: 16
              },
              source: _require(_dependencyMap[11]),
              resizeMode: "contain"
            })
          ),
          _react2.default.createElement(_reactNative.View, {
            style: {
              height: 1 / _reactNative.PixelRatio.get(),
              width: width - 40,
              marginLeft: 20,
              marginRight: 20,
              backgroundColor: '#f7f7f7'
            }
          }),
          _react2.default.createElement(_reactNative.View, {
            style: {
              flex: 1.0,
              width: width - 40
            }
          }),
          _react2.default.createElement(_TextButton2.default, {
            style: {
              width: width - 52,
              height: 48,
              marginBottom: 26,
              marginLeft: 26,
              borderColor: 'rgba(0,0,0,0.2)',
              borderWidth: _reactNative.StyleSheet.hairlineWidth
            },
            normalColor: "#ffffffff",
            pressColor: "#f2f2f2",
            text: (0, _MHLocalizableString.getString)('listen'),
            onPress: this.listen,
            textStyle: {
              color: "rgba(0,0,0,0.7)",
              fontFamily: Const.fontFamily,
              fontSize: 13
            }
          }),
          _react2.default.createElement(_Toast2.default, {
            ref: "toast",
            position: 'center',
            height: Const.contentViewHeight
          })
        );
      }
    }]);
    return VolumeSettingPage;
  }(_react2.default.Component);

  VolumeSettingPage.navigationOptions = function (_ref2) {
    var navigation = _ref2.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('volume'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: false,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = VolumeSettingPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: 'rgba(255,255,255,1)',
      flex: 1.0
    },
    listItem: {
      height: 50,
      width: width - 40,
      marginLeft: 20
    },
    line: {
      height: 1,
      width: width,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10355,[10297,10033,10121,10157,10340,10358,10343,11251,10346,10074,10364,10367],"projects/com.dreame.devices/main/VolumeSettingPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _reactNativeUiKitten = _require(_dependencyMap[2]);

    var SliderView = function (_React$Component) {
        babelHelpers.inherits(SliderView, _React$Component);

        function SliderView(props) {
            babelHelpers.classCallCheck(this, SliderView);

            var _this = babelHelpers.possibleConstructorReturn(this, (SliderView.__proto__ || Object.getPrototypeOf(SliderView)).call(this, props));

            _this.onProcessChange = function (process) {
                _this.setState({
                    process: process
                });

                if (_this.props.onProcessChange) {
                    _this.props.onProcessChange(process);
                }
            };

            _this.updateView = function (dx) {
                var coverStyle = {
                    width: (_this.props.width - _this.imageW) * _this.state.process / 100 + dx
                };

                if (coverStyle.width < 0) {
                    coverStyle.width = 0;
                }

                if (coverStyle.width > _this.props.width - _this.imageW) {
                    coverStyle.width = _this.props.width - _this.imageW;
                }

                var sliderStyle = {
                    left: coverStyle.width
                };

                if (_this.cover) {
                    _this.cover.setNativeProps({
                        style: coverStyle
                    });
                }

                if (_this.slider) {
                    _this.slider.setNativeProps({
                        style: sliderStyle
                    });
                }
            };

            _this.setProcess = function (process) {
                _this.setState({
                    process: process
                });
            };

            _this.state = {
                process: _this.props.process
            };
            _this.imageW = 24;
            _this.processHeight = 2;
            _this._panResponder = _reactNative.PanResponder.create({
                onStartShouldSetPanResponder: function onStartShouldSetPanResponder(evt, gestureState) {
                    return true;
                },
                onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture(evt, gestureState) {
                    return true;
                },
                onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {
                    return true;
                },
                onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture(evt, gestureState) {
                    return true;
                },
                onPanResponderGrant: function onPanResponderGrant(evt, gestureState) {},
                onPanResponderMove: function onPanResponderMove(evt, gestureState) {
                    _this.updateView(gestureState.dx);
                },
                onPanResponderTerminationRequest: function onPanResponderTerminationRequest(evt, gestureState) {
                    return true;
                },
                onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {
                    var width = (_this.props.width - _this.imageW) * _this.state.process / 100 + gestureState.dx;

                    if (width < 0) {
                        width = 0;
                    }

                    if (width > _this.props.width - _this.imageW) {
                        width = _this.props.width - _this.imageW;
                    }

                    _this.onProcessChange(Math.floor(width * 100 / (_this.props.width - _this.imageW)));
                },
                onPanResponderTerminate: function onPanResponderTerminate(evt, gestureState) {},
                onShouldBlockNativeResponder: function onShouldBlockNativeResponder(evt, gestureState) {
                    return true;
                }
            });
            return _this;
        }

        babelHelpers.createClass(SliderView, [{
            key: "render",
            value: function render() {
                var _this2 = this;

                var bgStyle = {
                    left: this.imageW / 2,
                    top: (this.props.height - this.processHeight) / 2,
                    height: this.processHeight,
                    width: this.props.width - this.imageW
                };
                var coverStyle = {
                    left: this.imageW / 2,
                    top: (this.props.height - this.processHeight) / 2,
                    height: this.processHeight,
                    width: (this.props.width - this.imageW) * this.state.process / 100
                };
                var sliderStyle = {
                    width: this.imageW,
                    height: this.imageW,
                    top: (this.props.height - this.imageW) / 2,
                    left: coverStyle.width
                };
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: {
                            width: this.props.width,
                            height: this.props.height
                        }
                    },
                    _react2.default.createElement(_reactNative.View, {
                        style: [styles.processbg, bgStyle]
                    }),
                    _react2.default.createElement(_reactNative.View, {
                        style: [styles.processCover, coverStyle],
                        ref: function ref(c) {
                            return _this2.cover = c;
                        }
                    }),
                    _react2.default.createElement(_reactNative.Image, babelHelpers.extends({
                        style: [styles.sliderButton, sliderStyle]
                    }, this._panResponder.panHandlers, {
                        ref: function ref(c) {
                            return _this2.slider = c;
                        },
                        resizeMode: "contain",
                        source: _require(_dependencyMap[3])
                    }))
                );
            }
        }]);
        return SliderView;
    }(_react2.default.Component);

    SliderView.defaultProps = {
        process: 100
    };
    exports.default = SliderView;

    var styles = _reactNative.StyleSheet.create({
        processbg: {
            position: 'absolute',
            borderColor: 'transparent',
            borderRadius: 2,
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            backgroundColor: 'rgba(0,0,0,0.1)'
        },
        processCover: {
            position: 'absolute',
            borderColor: 'transparent',
            borderRadius: 2,
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            backgroundColor: '#5696ff'
        },
        sliderButton: {
            position: 'absolute'
        }
    });
},10358,[10297,10033,11251,10361],"projects/com.dreame.devices/main/widget/SliderView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 64,
      "height": 64,
      "scales": [1],
      "hash": "42a0c89717a105b3a7b514cc426269c0",
      "name": "slider",
      "type": "png"
   });
},10361,[10420],"projects/com.dreame.devices/resources/slider.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 45,
      "height": 45,
      "scales": [1],
      "hash": "ae21a7388b81577db7728495b04ef4fb",
      "name": "voice_reduce",
      "type": "png"
   });
},10364,[10420],"projects/com.dreame.devices/resources/voice_reduce.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 45,
      "height": 45,
      "scales": [1],
      "hash": "aaa0859413f2955166d59b913f9d525c",
      "name": "voice_add",
      "type": "png"
   });
},10367,[10420],"projects/com.dreame.devices/resources/voice_add.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _reactNativeUiKitten = _require(_dependencyMap[4]);

  var _SettingListItemView = _require(_dependencyMap[5]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _CopyMHDatePicker = _require(_dependencyMap[6]);

  var _CopyMHDatePicker2 = babelHelpers.interopRequireDefault(_CopyMHDatePicker);

  var _rmcPicker = _require(_dependencyMap[7]);

  var _Toast = _require(_dependencyMap[8]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var _ui = _require(_dependencyMap[9]);

  var _miot = _require(_dependencyMap[10]);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var did = _miot.Device.getDeviceWifi().deviceID;

  var NoDisturbPage = function (_React$Component) {
    babelHelpers.inherits(NoDisturbPage, _React$Component);

    function NoDisturbPage(props) {
      babelHelpers.classCallCheck(this, NoDisturbPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (NoDisturbPage.__proto__ || Object.getPrototypeOf(NoDisturbPage)).call(this, props));

      _this.getData = function () {
        _miot.Device.getDeviceWifi().callMethod("get_properties", [{
          "did": did,
          "siid": 20,
          "piid": 1
        }, {
          "did": did,
          "siid": 20,
          "piid": 2
        }, {
          "did": did,
          "siid": 20,
          "piid": 3
        }]).then(function (res) {
          if (res.code == 0) {
            var updateState = {};

            for (var i = 0; i < res.result.length; i++) {
              var item = res.result[i];

              if (item.code != 0) {
                continue;
              }

              switch (item.siid) {
                case 20:
                  if (item.piid == 1) {
                    updateState.switchState = item.value;
                  } else if (item.piid == 2) {
                    var times = item.value.split(":");

                    if (times[0].length == 1) {
                      times[0] = "0" + times[0];
                    }

                    if (times[1].length == 1) {
                      times[1] = "0" + times[1];
                    }

                    updateState.start = times;
                  } else if (item.piid == 3) {
                    var _times = item.value.split(":");

                    if (_times[0].length == 1) {
                      _times[0] = "0" + _times[0];
                    }

                    if (_times[1].length == 1) {
                      _times[1] = "0" + _times[1];
                    }

                    updateState.end = _times;
                  }

                  break;

                default:
                  break;
              }
            }

            gData.distrubData = updateState;

            _this.setState(updateState);
          }
        }).catch(function (err) {
          console.log('failed:', err);
        });
      };

      _this.setDisturbData = function (update) {
        _miot.Device.getDeviceWifi().callMethod("set_properties", [{
          "did": did,
          "siid": 20,
          "piid": 1,
          "value": update.switchState
        }, {
          "did": did,
          "siid": 20,
          "piid": 2,
          "value": update.start[0] + ":" + update.start[1]
        }, {
          "did": did,
          "siid": 20,
          "piid": 3,
          "value": update.end[0] + ":" + update.end[1]
        }]).then(function (res) {
          console.log("-----------", res);
        }).catch(function (err) {
          console.log('changeMode failed:', err);
        });
      };

      _this.showPicker = function (select) {
        _this.setState({
          popupVisibleType: select
        });
      };

      _this.handlePickedValue = function () {
        var index = _this.state.popupVisibleType;
        var data = _this.currentSelect;

        if (index == 1) {
          if (data[0] == _this.state.end[0] && data[1] == _this.state.end[1]) {
            _this.showToast((0, _MHLocalizableString.getString)('disturbTip'));

            return;
          }

          _this.state.start = data;
        } else {
          if (data[0] == _this.state.state[0] && data[1] == _this.state.state[1]) {
            _this.showToast((0, _MHLocalizableString.getString)('disturbTip'));

            return;
          }

          _this.state.end = data;
        }

        _this.hidePicker();

        _this.setDisturbData({
          switchState: _this.state.switchState,
          start: _this.state.start,
          end: _this.state.end
        });
      };

      _this.hidePicker = function () {
        console.log("===========hidePicker");

        _this.setState({
          popupVisibleType: 0
        });
      };

      _this.getShowDate = function (data) {
        var hour = data[0];
        var minute = data[1];
        return hour + ":" + minute;
      };

      _this.onSelect = function (res) {
        var index = _this.state.popupVisibleType;
        var data = res.rawArray;

        if (index == 1) {
          if (data[0] == _this.state.end[0] && data[1] == _this.state.end[1]) {
            _this.showToast((0, _MHLocalizableString.getString)('disturbTip'));

            return;
          }

          _this.state.start = data;
        } else {
          if (data[0] == _this.state.start[0] && data[1] == _this.state.start[1]) {
            _this.showToast((0, _MHLocalizableString.getString)('disturbTip'));

            return;
          }

          _this.state.end = data;
        }

        _this.setDisturbData({
          switchState: _this.state.switchState,
          start: _this.state.start,
          end: _this.state.end
        });
      };

      _this.showToast = function (msg) {
        _this.refs.toast.show(msg, 1200);
      };

      _this.state = {
        switchState: false,
        popupVisibleType: 0,
        pikerEndVisible: false,
        start: ["22", "00"],
        end: ["08", "00"]
      };

      if (gData.distrubData) {
        if (gData.distrubData.switchState != undefined) {
          _this.state.switchState = gData.distrubData.switchState;
        }

        _this.state.start = gData.distrubData.start;
        _this.state.end = gData.distrubData.end;
      }

      _this.getData();

      return _this;
    }

    babelHelpers.createClass(NoDisturbPage, [{
      key: "componentWillMount",
      value: function componentWillMount() {}
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {}
    }, {
      key: "generateMinutesFromRange",
      value: function generateMinutesFromRange(start, finish) {
        return Array.apply(null, Array(finish - start + 1)).map(function (_, i) {
          var value = start + i;

          if (value < 10) {
            return "0" + value;
          }

          return "" + value;
        });
      }
    }, {
      key: "generateHoursFromRange",
      value: function generateHoursFromRange(start, finish) {
        return Array.apply(null, Array(finish - start + 1)).map(function (_, i) {
          var value = start + i;

          if (value < 10) {
            return "0" + value;
          }

          return "" + value;
        });
      }
    }, {
      key: "renderNumberSpinner",
      value: function renderNumberSpinner() {
        var _this2 = this;

        var select = this.state.end;

        if (this.state.popupVisibleType == 1) {
          select = this.state.start;
        }

        this.currentSelect = [select[0], select[1]];
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.content
          },
          _react2.default.createElement(_ui.StringSpinner, {
            style: {
              width: width / 2,
              height: 250
            },
            dataSource: this.generateHoursFromRange(0, 23),
            defaultValue: select[0],
            onValueChanged: function onValueChanged(data) {
              _this2.currentSelect[0] = data.newValue;
            }
          }),
          _react2.default.createElement(_ui.StringSpinner, {
            style: {
              width: width / 2,
              height: 250
            },
            dataSource: this.generateHoursFromRange(0, 59),
            defaultValue: select[1],
            onValueChanged: function onValueChanged(data) {
              _this2.currentSelect[1] = data.newValue;
            }
          })
        );
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var hours = this.generateHoursFromRange(0, 23);
        var minutes = this.generateMinutesFromRange(0, 59);
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                flexDirection: 'row',
                paddingTop: 10,
                marginBottom: 10,
                paddingLeft: 25,
                paddingRight: 25,
                minHeight: 77,
                justifyContent: 'center',
                alignItems: 'center'
              }
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                style: {
                  flex: 1.0
                }
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 17,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,1)'
                  }
                },
                (0, _MHLocalizableString.getString)('disturbTime')
              ),
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    marginTop: 5,
                    fontSize: 13,
                    paddingRight: 5,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,0.4)'
                  }
                },
                (0, _MHLocalizableString.getString)('nodistrubTip')
              )
            ),
            _react2.default.createElement(_reactNativeUiKitten.RkSwitch, {
              style: {
                marginLeft: 25,
                borderRadius: 16,
                backgroundColor: '#f0f0f0'
              },
              tintColor: "#e3e3e3",
              onTintColor: "#5696ff",
              value: this.state.switchState,
              onValueChange: function onValueChange() {
                _this3.setDisturbData({
                  switchState: !_this3.state.switchState,
                  start: _this3.state.start,
                  end: _this3.state.end
                });

                _this3.setState({
                  switchState: !_this3.state.switchState
                });
              }
            })
          ),
          _react2.default.createElement(_reactNative.View, {
            style: [styles.line, {
              marginLeft: 25
            }]
          }),
          this.state.switchState && _react2.default.createElement(
            _reactNative.View,
            {
              style: {}
            },
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              leftText: (0, _MHLocalizableString.getString)('startTime'),
              rightText: this.getShowDate(this.state.start),
              onPress: function onPress() {
                _this3.showPicker(1);
              }
            }),
            _react2.default.createElement(_reactNative.View, {
              style: [styles.line, {
                marginLeft: 25
              }]
            }),
            _react2.default.createElement(_SettingListItemView2.default, {
              style: styles.listItem,
              leftText: (0, _MHLocalizableString.getString)('endTime'),
              rightText: this.getShowDate(this.state.end),
              onPress: function onPress() {
                _this3.showPicker(2);
              }
            }),
            _react2.default.createElement(_reactNative.View, {
              style: [styles.line, {
                marginLeft: 25
              }]
            }),
            _react2.default.createElement(_CopyMHDatePicker2.default, {
              key: "disStart",
              visible: this.state.popupVisibleType == 1,
              title: (0, _MHLocalizableString.getString)('startTime'),
              type: _CopyMHDatePicker2.default.TYPE.TIME24,
              current: this.state.start,
              confirmColor: "#5696ff",
              cancle: (0, _MHLocalizableString.getString)('cancle'),
              confirm: (0, _MHLocalizableString.getString)('sure'),
              onDismiss: function onDismiss(_) {
                return _this3.hidePicker();
              },
              onSelect: function onSelect(res) {
                return _this3.onSelect(res);
              }
            }),
            _react2.default.createElement(_CopyMHDatePicker2.default, {
              key: "disend",
              visible: this.state.popupVisibleType == 2,
              title: (0, _MHLocalizableString.getString)('endTime'),
              type: _CopyMHDatePicker2.default.TYPE.TIME24,
              current: this.state.end,
              confirmColor: "#5696ff",
              cancle: (0, _MHLocalizableString.getString)('cancle'),
              confirm: (0, _MHLocalizableString.getString)('sure'),
              onDismiss: function onDismiss(_) {
                return _this3.hidePicker();
              },
              onSelect: function onSelect(res) {
                return _this3.onSelect(res);
              }
            }),
            _react2.default.createElement(_Toast2.default, {
              ref: "toast",
              position: 'center',
              height: Const.contentViewHeight
            })
          )
        );
      }
    }]);
    return NoDisturbPage;
  }(_react2.default.Component);

  NoDisturbPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('disturbTime'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = NoDisturbPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: 'rgba(255,255,255,1)',
      flex: 1.0
    },
    listItem: {
      height: 55,
      paddingLeft: 25,
      paddingRight: 25,
      width: width
    },
    line: {
      height: 1 / _reactNative.PixelRatio.get(),
      width: width - 50,
      backgroundColor: 'rgba(0,0,0,0.1)'
    },
    root: {
      paddingTop: 100,
      flexDirection: 'row',
      justifyContent: 'center'
    },
    content: {
      padding: 100,
      height: 250,
      flexDirection: "row",
      justifyContent: 'center',
      alignItems: 'center'
    }
  });
},10370,[10297,10033,10121,10157,11251,10340,10373,10376,10343,10230,10074],"projects/com.dreame.devices/main/NoDisturbPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _singleDataSource;

  var _propTypes = _require(_dependencyMap[0]);

  var _propTypes2 = babelHelpers.interopRequireDefault(_propTypes);

  var _react = _require(_dependencyMap[1]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[2]);

  var _resources = _require(_dependencyMap[3]);

  var _Strings = _require(_dependencyMap[4]);

  var _Separator = _require(_dependencyMap[5]);

  var _Separator2 = babelHelpers.interopRequireDefault(_Separator);

  var _StringSpinner = _require(_dependencyMap[6]);

  var _StringSpinner2 = babelHelpers.interopRequireDefault(_StringSpinner);

  var TYPE = {
    SINGLE: 'single',
    TIME24: 'time24',
    TIME12: 'time12',
    DATE: 'date'
  };
  Object.freeze(TYPE);
  var SINGLE_TYPE = {
    MONTH: 'month',
    DAY: 'day',
    HOUR: 'hour',
    MINUTE: 'minute',
    SECOND: 'second'
  };
  Object.freeze(SINGLE_TYPE);

  function constructArray(length) {
    var zeroPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var fromZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var maxLength = (length - (fromZero ? 1 : 0)).toString().length;
    return Array.from({
      length: length
    }, function (v, i) {
      return ((zeroPrefix ? '0000000000000' : '') + (i + (fromZero ? 0 : 1))).slice(-maxLength);
    });
  }

  var screenBackgroundColor = 'rgba(0,0,0,0.4)';
  var margin = 10;
  var borderRadius = 15;
  var titleHeightThin = 66;
  var titleHeightFat = 85;
  var rowHeight = 52;
  var pickerContainerHeight = rowHeight * 5;
  var buttonHeight = 50;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var modalWidth = width - margin * 2;
  var pickerInnerStyle = {
    lineColor: _resources.Styles.common.hairlineColor,
    textColor: '#666666',
    fontSize: 15,
    selectTextColor: "#333333",
    selectFontSize: 20,
    unitTextColor: '#333333',
    unitFontSize: 10,
    rowHeight: rowHeight,
    selectBgColor: "#f3f3f3"
  };
  var months = constructArray(12, 1, 0);
  var days = constructArray(31, 1, 0);
  var hours24 = constructArray(24, 1, 1);
  var timeSystem = [_resources.strings.am, _resources.strings.pm];
  var hours12 = hours24.slice(1, 13);
  var minutes = constructArray(60, 1, 1);
  var singleDataSource = (_singleDataSource = {}, babelHelpers.defineProperty(_singleDataSource, SINGLE_TYPE.MONTH, months), babelHelpers.defineProperty(_singleDataSource, SINGLE_TYPE.DAY, days), babelHelpers.defineProperty(_singleDataSource, SINGLE_TYPE.HOUR, constructArray(24, 1, 0)), babelHelpers.defineProperty(_singleDataSource, SINGLE_TYPE.MINUTE, constructArray(60, 1, 0)), babelHelpers.defineProperty(_singleDataSource, SINGLE_TYPE.SECOND, constructArray(60, 1, 0)), _singleDataSource);
  Object.freeze(singleDataSource);
  var days31 = ['01', '03', '05', '07', '08', '10', '12'];
  var days30 = ['04', '06', '09', '11'];
  var defaultYearOffset = 15;

  var MHDatePicker = function (_React$Component) {
    babelHelpers.inherits(MHDatePicker, _React$Component);

    function MHDatePicker(props, context) {
      babelHelpers.classCallCheck(this, MHDatePicker);

      var _this = babelHelpers.possibleConstructorReturn(this, (MHDatePicker.__proto__ || Object.getPrototypeOf(MHDatePicker)).call(this, props, context));

      var _this$init = _this.init(props),
          currentArray = _this$init.currentArray,
          dataSourceArray = _this$init.dataSourceArray;

      var subtitle = _this.getSubtitle(currentArray);

      _this.state = {
        visible: _this.props.visible,
        dataSourceArray: dataSourceArray,
        currentArray: currentArray,
        subtitle: subtitle
      };
      return _this;
    }

    babelHelpers.createClass(MHDatePicker, [{
      key: "getSubtitle",
      value: function getSubtitle(arr) {
        var _TYPE$DATE$TYPE$TIME;

        if (this.props.type === TYPE.SINGLE) {
          var count = parseInt(arr[0]);
          var unit = count > 1 ? _resources.strings[this.props.singleType + 's'] : _resources.strings[this.props.singleType];
          return (0, _Strings.formatString)(_resources.strings.singleSubTitle, count, unit);
        }

        var time24SubTitle = _resources.strings.time24SubTitle || "{0}:{1}";
        var time12SubTitle = _resources.strings.time12SubTitle || "{0} {1}:{2}";
        return _Strings.formatString.apply(undefined, [(_TYPE$DATE$TYPE$TIME = {}, babelHelpers.defineProperty(_TYPE$DATE$TYPE$TIME, TYPE.DATE, _resources.strings.dateSubTitle), babelHelpers.defineProperty(_TYPE$DATE$TYPE$TIME, TYPE.TIME24, time24SubTitle), babelHelpers.defineProperty(_TYPE$DATE$TYPE$TIME, TYPE.TIME12, time12SubTitle), _TYPE$DATE$TYPE$TIME)[this.props.type]].concat(babelHelpers.toConsumableArray(arr)));
      }
    }, {
      key: "convert",
      value: function convert(cur) {
        var type = this.props.type;

        if (cur instanceof Date) {
          switch (type) {
            case TYPE.DATE:
              return this.convert([cur.getFullYear(), cur.getMonth() + 1, cur.getDate()]);

            case TYPE.TIME24:
              return this.convert([cur.getHours(), cur.getMinutes()]);

            case TYPE.TIME12:
              return this.convertTo12([cur.getHours(), cur.getMinutes()]);

            case TYPE.SINGLE:
              return ['01'];

            default:
              return ['01'];
          }
        } else if (cur instanceof Array) {
          switch (type) {
            case TYPE.DATE:
              return cur.slice(0, 3).map(function (v, i) {
                return i === 0 ? '' + v : ('0' + v).slice(-2);
              });

            case TYPE.TIME24:
              return cur.slice(0, 2).map(function (v) {
                return ('0' + v).slice(-2);
              });

            case TYPE.TIME12:
              return this.convertTo12(cur);

            case TYPE.SINGLE:
              return cur.slice(0, 1).map(function (v) {
                return ('0' + v).slice(-2);
              });

            default:
              return ['01'];
          }
        } else if (typeof cur === 'string' || typeof cur === 'number') {
            return [cur + ''];
          } else {
              return ['01'];
            }
      }
    }, {
      key: "convertTo12",
      value: function convertTo12(arr) {
        if (arr.length === 2) {
          var newArr = arr.map(function (v) {
            return parseInt(v);
          });

          if (newArr.every(function (v) {
            return Number.isInteger;
          })) {
            var res = void 0;

            if (newArr[0] === 0) {
              res = [_resources.strings.am, 12, newArr[1]];
            } else {
              var _timeSystem = newArr[0] > 11 ? _resources.strings.pm : _resources.strings.am;

              var hour = newArr[0] > 12 ? newArr[0] - 12 + '' : newArr[0] + '';
              var minute = newArr[1] + '';
              res = [_timeSystem, hour, minute];
            }

            return res.map(function (v, i) {
              return i > 0 ? ('0' + v).slice(-2) : v;
            });
          }
        }

        return this.convert(new Date());
      }
    }, {
      key: "slice",
      value: function slice(arr, head, tail) {
        if (head === undefined && tail === undefined) return arr;
        var index = arr.indexOf(('0' + head).slice(-2)) || 0;
        var lastIndex = arr.lastIndexOf(('0' + tail).slice(-2)) || arr.length - 1;
        return arr.slice(index, lastIndex + 1);
      }
    }, {
      key: "getYears",
      value: function getYears(min, max) {
        this.min = this.convert(min);
        this.max = this.convert(max);
        var minY = Number.parseInt(this.min[0]);
        var maxY = Number.parseInt(this.max[0]);
        return this.generateArray(minY, maxY);
      }
    }, {
      key: "generateArray",
      value: function generateArray(min, max) {
        if (min > max) {
          console.warn('max < min');
          return [];
        }

        return Array.from({
          length: max - min + 1
        }, function (v, i) {
          return i + min;
        }).map(function (v) {
          return v + '';
        });
      }
    }, {
      key: "init",
      value: function init(props) {
        var type = props.type,
            singleType = props.singleType,
            current = props.current,
            min = props.min,
            max = props.max;
        var currentArray = this.convert(current || new Date());

        switch (type) {
          case TYPE.DATE:
            var yearNow = new Date().getFullYear();
            var minDefault = new Date();
            minDefault.setFullYear(yearNow - defaultYearOffset);
            var maxDefault = new Date();
            maxDefault.setFullYear(yearNow + defaultYearOffset);
            var years = this.getYears(min || minDefault, max || maxDefault);
            var dataSourceArray = [years, months, days];
            this.updateDays(currentArray, dataSourceArray);
            this.unitArray = [_resources.strings.yearUnit, _resources.strings.monthUnit, _resources.strings.dayUnit];
            return {
              currentArray: currentArray,
              dataSourceArray: dataSourceArray
            };

          case TYPE.TIME24:
            this.unitArray = [_resources.strings.hourUnit, _resources.strings.minuteUnit];
            return {
              currentArray: currentArray,
              dataSourceArray: [hours24, minutes]
            };

          case TYPE.TIME12:
            this.unitArray = ['', _resources.strings.hourUnit, _resources.strings.minuteUnit];
            return {
              currentArray: currentArray,
              dataSourceArray: [timeSystem, hours12, minutes]
            };

          case TYPE.SINGLE:
          default:
            this.unitArray = [_resources.strings[singleType + 'Unit']];
            return {
              currentArray: currentArray,
              dataSourceArray: [this.slice(singleDataSource[singleType], min, max)]
            };
        }
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(newProps) {
        if (newProps.visible !== this.state.visible) {
          this.setState({
            visible: newProps.visible
          });
        }

        if (newProps.current === undefined || newProps.current !== this.props.current) {
          var currentArray = this.convert(newProps.current || new Date());
          this.setState({
            currentArray: currentArray,
            subtitle: this.getSubtitle(currentArray)
          });
        }
      }
    }, {
      key: "renderTitle",
      value: function renderTitle() {
        var height = {
          height: this.props.showSubtitle ? titleHeightFat : titleHeightThin
        };
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: [styles.titleContainer, height]
          },
          _react2.default.createElement(
            _reactNative.Text,
            {
              numberOfLines: 1,
              style: [_resources.Styles.common.title, styles.title]
            },
            this.props.title || ''
          ),
          this.props.showSubtitle ? _react2.default.createElement(
            _reactNative.Text,
            {
              numberOfLines: 1,
              style: styles.subtitle
            },
            this.state.subtitle
          ) : null
        );
      }
    }, {
      key: "renderContent",
      value: function renderContent() {
        var _this2 = this;

        var _state = this.state,
            currentArray = _state.currentArray,
            dataSourceArray = _state.dataSourceArray;
        var length = currentArray.length;
        var actualWidth = modalWidth - (length - 1) * _reactNative.StyleSheet.hairlineWidth;
        var normalWidth = actualWidth / length;
        var yearWidth = normalWidth + 10;
        var monthWidth = (actualWidth - yearWidth) / 2;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.pickerContainer
          },
          dataSourceArray.map(function (dataSource, index) {
            var style = {
              width: normalWidth
            };

            if (_this2.props.type === TYPE.DATE) {
              if (index === 0) style = {
                width: yearWidth
              };else style = {
                width: monthWidth
              };
            }

            return _react2.default.createElement(
              _reactNative.View,
              {
                style: [{
                  flexDirection: 'row'
                }, style]
              },
              _react2.default.createElement(_StringSpinner2.default, {
                key: index + _this2.unitArray[index],
                style: style,
                dataSource: dataSource,
                defaultValue: currentArray[index],
                pickerInnerStyle: pickerInnerStyle,
                onValueChanged: function onValueChanged(data) {
                  return _this2._onValueChanged(index, data);
                }
              }),
              index < length - 1 ? _react2.default.createElement(_Separator2.default, {
                type: "column",
                style: {
                  height: pickerContainerHeight
                }
              }) : null
            );
          })
        );
      }
    }, {
      key: "renderButton",
      value: function renderButton() {
        var _this3 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.buttons
          },
          _react2.default.createElement(
            _reactNative.TouchableHighlight,
            {
              style: [styles.button, {
                borderBottomLeftRadius: borderRadius
              }],
              onPress: function onPress(_) {
                return _this3.dismiss();
              },
              underlayColor: "rgba(0,0,0,.05)"
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: styles.buttonText
              },
              this.props.cancle || _resources.strings.cancel
            )
          ),
          _react2.default.createElement(_Separator2.default, {
            type: "column",
            style: {
              height: buttonHeight
            }
          }),
          _react2.default.createElement(
            _reactNative.TouchableHighlight,
            {
              style: [styles.button, {
                borderBottomRightRadius: borderRadius
              }],
              onPress: function onPress(_) {
                return _this3.confirm();
              },
              underlayColor: "rgba(0,0,0,.05)"
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: [styles.buttonText, {
                  color: this.props.confirmColor
                }]
              },
              this.props.confirm || _resources.strings.ok
            )
          )
        );
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        return _react2.default.createElement(
          _reactNative.Modal,
          {
            animationType: this.props.animationType,
            transparent: true,
            visible: this.state.visible,
            onRequestClose: function onRequestClose(_) {
              return _this4.dismiss();
            }
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: styles.background
            },
            _react2.default.createElement(
              _reactNative.TouchableWithoutFeedback,
              {
                onPress: function onPress(_) {
                  return _this4.dismiss();
                }
              },
              _react2.default.createElement(_reactNative.View, {
                style: {
                  width: width,
                  height: height
                }
              })
            ),
            _react2.default.createElement(
              _reactNative.View,
              {
                style: styles.modal
              },
              this.renderTitle(),
              _react2.default.createElement(_Separator2.default, null),
              this.renderContent(),
              _react2.default.createElement(_Separator2.default, null),
              this.renderButton()
            )
          )
        );
      }
    }, {
      key: "isLeapYear",
      value: function isLeapYear(y) {
        return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0 && y % 3200 !== 0;
      }
    }, {
      key: "compareDateArray",
      value: function compareDateArray(arrA, arrB) {
        return arrA.join('') - arrB.join('');
      }
    }, {
      key: "updateDays",
      value: function updateDays(newCurrentArray, newDataSourceArray) {
        var _newCurrentArray = babelHelpers.slicedToArray(newCurrentArray, 3),
            year = _newCurrentArray[0],
            month = _newCurrentArray[1],
            day = _newCurrentArray[2];

        if (days31.includes(month)) {
          newDataSourceArray[2] = days;
        } else if (days30.includes(month)) {
          newDataSourceArray[2] = days.slice(0, 30);
        } else {
          if (this.isLeapYear(parseInt(year))) {
            newDataSourceArray[2] = days.slice(0, 29);
          } else {
            newDataSourceArray[2] = days.slice(0, 28);
          }
        }

        if (!newDataSourceArray[2].includes(day)) {
          newCurrentArray[2] = newDataSourceArray[2][newDataSourceArray[2].length - 1];
        }
      }
    }, {
      key: "_onValueChanged",
      value: function _onValueChanged(index, data) {
        var _this5 = this;

        var newCurrentArray = [].concat(babelHelpers.toConsumableArray(this.state.currentArray));
        newCurrentArray[index] = data.newValue;
        var newDataSourceArray = [].concat(babelHelpers.toConsumableArray(this.state.dataSourceArray));
        this.setState({
          currentArray: newCurrentArray,
          subtitle: this.getSubtitle(newCurrentArray)
        }, function (_) {
          if (_this5.props.type === TYPE.DATE) {
            var needUpdate = false;

            if (_this5.compareDateArray(newCurrentArray, _this5.max) > 0) {
              newCurrentArray = _this5.max;
              needUpdate = true;
            }

            if (_this5.compareDateArray(newCurrentArray, _this5.min) < 0) {
              newCurrentArray = _this5.min;
              needUpdate = true;
            }

            _this5.updateDays(newCurrentArray, newDataSourceArray);

            if (newDataSourceArray[2].length !== _this5.state.dataSourceArray[2].length) {
              needUpdate = true;
            }

            needUpdate && _this5.setState({
              subtitle: _this5.getSubtitle(newCurrentArray),
              currentArray: newCurrentArray,
              dataSourceArray: newDataSourceArray
            });
          }
        });
      }
    }, {
      key: "dismiss",
      value: function dismiss() {
        this.setState({
          visible: false
        });
        this.props.onDismiss && this.props.onDismiss();
      }
    }, {
      key: "array2Date",
      value: function array2Date() {
        var currentArray = this.state.currentArray;
        var date = new Date();

        switch (this.props.type) {
          case TYPE.DATE:
            date.setFullYear(currentArray[0]);
            date.setMonth(parseInt(currentArray[1]) - 1);
            date.setDate(parseInt(currentArray[2]));
            break;

          case TYPE.TIME24:
            date.setHours(currentArray[0]);
            date.setMinutes(currentArray[1]);
            break;

          case TYPE.TIME12:
            var hour = parseInt(currentArray[1]);

            if (currentArray[0] === _resources.strings.am) {
              hour = hour === 12 ? 0 : hour;
            } else {
              hour = hour < 12 ? hour + 12 : hour;
            }

            date.setHours(hour);
            date.setMinutes(currentArray[2]);
            break;

          case TYPE.SINGLE:
          default:
            return null;
        }

        return date;
      }
    }, {
      key: "confirm",
      value: function confirm() {
        if (this.props.onSelect) {
          this.props.onSelect({
            rawArray: this.state.currentArray,
            rawString: this.state.subtitle,
            date: this.array2Date()
          });
        }

        this.dismiss();
      }
    }]);
    return MHDatePicker;
  }(_react2.default.Component);

  MHDatePicker.propTypes = {
    animationType: _propTypes2.default.string,
    visible: _propTypes2.default.bool,
    title: _propTypes2.default.string,
    showSubtitle: _propTypes2.default.bool,
    confirmColor: _propTypes2.default.string,
    cancle: _propTypes2.default.string,
    confirm: _propTypes2.default.string,
    type: _propTypes2.default.oneOf([TYPE.DATE, TYPE.SINGLE, TYPE.TIME12, TYPE.TIME24]),
    singleType: _propTypes2.default.oneOf([SINGLE_TYPE.MONTH, SINGLE_TYPE.DAY, SINGLE_TYPE.HOUR, SINGLE_TYPE.MINUTE, SINGLE_TYPE.SECOND]),
    current: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.string), _propTypes2.default.arrayOf(_propTypes2.default.number), _propTypes2.default.instanceOf(Date)]),
    min: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.string), _propTypes2.default.arrayOf(_propTypes2.default.number), _propTypes2.default.instanceOf(Date)]),
    max: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.string), _propTypes2.default.arrayOf(_propTypes2.default.number), _propTypes2.default.instanceOf(Date)]),
    onSelect: _propTypes2.default.func,
    onDismiss: _propTypes2.default.func
  };
  MHDatePicker.defaultProps = {
    animationType: 'fade',
    visible: false,
    title: '开启时间',
    showSubtitle: true,
    confirmColor: _resources.Styles.common.MHGreen,
    type: TYPE.TIME24,
    singleType: SINGLE_TYPE.MINUTE,
    onSelect: function onSelect(obj) {
      return console.log(obj);
    }
  };
  MHDatePicker.TYPE = TYPE;
  MHDatePicker.SINGLE_TYPE = SINGLE_TYPE;
  exports.default = MHDatePicker;

  var styles = _reactNative.StyleSheet.create({
    background: {
      flex: 1,
      backgroundColor: screenBackgroundColor
    },
    modal: {
      position: 'absolute',
      bottom: 20,
      width: modalWidth,
      marginHorizontal: margin,
      backgroundColor: '#fff',
      borderRadius: borderRadius
    },
    titleContainer: {
      justifyContent: 'center',
      alignItems: 'center'
    },
    title: {
      fontFamily: 'D-DINCondensed-Bold'
    },
    subtitle: {
      width: modalWidth,
      textAlign: 'center',
      fontSize: 13,
      color: '#666'
    },
    pickerContainer: {
      flexDirection: 'row',
      height: pickerContainerHeight,
      justifyContent: 'space-between'
    },
    buttons: {
      height: buttonHeight,
      flexDirection: 'row',
      backgroundColor: 'transparent',
      justifyContent: 'space-between'
    },
    button: {
      flex: 1,
      backgroundColor: 'transparent',
      justifyContent: 'center',
      alignItems: 'center'
    },
    buttonText: {
      fontSize: 14,
      lineHeight: 19,
      color: '#666',
      fontFamily: 'D-DINCondensed-Bold'
    }
  });
},10373,[10318,10297,10033,10077,10320,10332,10365],"projects/com.dreame.devices/main/widget/CopyMHDatePicker.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _Picker = _require(_dependencyMap[0]);

  Object.defineProperty(exports, 'default', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_Picker)['default'];
    }
  });

  var _Popup = _require(_dependencyMap[1]);

  Object.defineProperty(exports, 'Popup', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_Popup)['default'];
    }
  });

  var _PopupStyles = _require(_dependencyMap[2]);

  Object.defineProperty(exports, 'PopupStyles', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_PopupStyles)['default'];
    }
  });

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      'default': obj
    };
  }
},10376,[13465,10379,10391],"node_modules/rmc-picker/lib/index.native.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = _interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _PopupMixin = _require(_dependencyMap[2]);

    var _PopupMixin2 = _interopRequireDefault(_PopupMixin);

    var _Modal = _require(_dependencyMap[3]);

    var _Modal2 = _interopRequireDefault(_Modal);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            'default': obj
        };
    }

    var getModal = function getModal(props, visible, _ref) {
        var getContent = _ref.getContent,
            hide = _ref.hide,
            onDismiss = _ref.onDismiss,
            onOk = _ref.onOk;
        var styles = props.styles,
            title = props.title,
            okText = props.okText,
            dismissText = props.dismissText;
        var titleEl = typeof title === 'string' ? _react2['default'].createElement(_reactNative.Text, {
            style: [styles.title]
        }, title) : title;
        var okEl = typeof okText === 'string' ? _react2['default'].createElement(_reactNative.Text, {
            style: [styles.actionText, styles.okText]
        }, okText) : okText;
        var dismissEl = typeof dismissText === 'string' ? _react2['default'].createElement(_reactNative.Text, {
            style: [styles.actionText, styles.dismissText]
        }, dismissText) : dismissText;
        return _react2['default'].createElement(_Modal2['default'], {
            animationType: 'slide-up',
            wrapStyle: styles.modal,
            visible: visible,
            onClose: hide
        }, _react2['default'].createElement(_reactNative.View, {
            style: [styles.header]
        }, _react2['default'].createElement(_reactNative.TouchableHighlight, {
            onPress: onDismiss,
            style: [styles.headerItem],
            activeOpacity: props.actionTextActiveOpacity,
            underlayColor: props.actionTextUnderlayColor
        }, dismissEl), _react2['default'].createElement(_reactNative.View, {
            style: [styles.headerItem]
        }, titleEl), _react2['default'].createElement(_reactNative.TouchableHighlight, {
            onPress: onOk,
            style: [styles.headerItem],
            activeOpacity: props.actionTextActiveOpacity,
            underlayColor: props.actionTextUnderlayColor
        }, okEl)), getContent());
    };

    exports['default'] = (0, _PopupMixin2['default'])(getModal, {
        actionTextUnderlayColor: '#ddd',
        actionTextActiveOpacity: 1,
        triggerType: 'onPress',
        styles: {},
        WrapComponent: _reactNative.View
    });
    module.exports = exports['default'];
},10379,[10297,10033,10382,10388],"node_modules/rmc-picker/lib/Popup.native.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _extends2 = _require(_dependencyMap[0]);

    var _extends3 = _interopRequireDefault(_extends2);

    var _defineProperty2 = _require(_dependencyMap[1]);

    var _defineProperty3 = _interopRequireDefault(_defineProperty2);

    var _classCallCheck2 = _require(_dependencyMap[2]);

    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

    var _createClass2 = _require(_dependencyMap[3]);

    var _createClass3 = _interopRequireDefault(_createClass2);

    var _possibleConstructorReturn2 = _require(_dependencyMap[4]);

    var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

    var _inherits2 = _require(_dependencyMap[5]);

    var _inherits3 = _interopRequireDefault(_inherits2);

    exports['default'] = PopupMixin;

    var _react = _require(_dependencyMap[6]);

    var _react2 = _interopRequireDefault(_react);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            'default': obj
        };
    }

    function PopupMixin(getModal, platformProps) {
        return _a = function (_React$Component) {
            (0, _inherits3['default'])(_a, _React$Component);

            function _a(props) {
                (0, _classCallCheck3['default'])(this, _a);

                var _this = (0, _possibleConstructorReturn3['default'])(this, (_a.__proto__ || Object.getPrototypeOf(_a)).call(this, props));

                _this.onPickerChange = function (pickerValue) {
                    if (_this.state.pickerValue !== pickerValue) {
                        _this.setState({
                            pickerValue: pickerValue
                        });

                        var _this$props = _this.props,
                            picker = _this$props.picker,
                            pickerValueChangeProp = _this$props.pickerValueChangeProp;

                        if (picker && picker.props[pickerValueChangeProp]) {
                            picker.props[pickerValueChangeProp](pickerValue);
                        }
                    }
                };

                _this.saveRef = function (picker) {
                    _this.picker = picker;
                };

                _this.onTriggerClick = function (e) {
                    var child = _this.props.children;
                    var childProps = child.props || {};

                    if (childProps[_this.props.triggerType]) {
                        childProps[_this.props.triggerType](e);
                    }

                    _this.fireVisibleChange(!_this.state.visible);
                };

                _this.onOk = function () {
                    _this.props.onOk(_this.picker && _this.picker.getValue());

                    _this.fireVisibleChange(false);
                };

                _this.getContent = function () {
                    if (_this.props.picker) {
                        var _React$cloneElement;

                        var pickerValue = _this.state.pickerValue;

                        if (pickerValue === null) {
                            pickerValue = _this.props.value;
                        }

                        return _react2['default'].cloneElement(_this.props.picker, (_React$cloneElement = {}, (0, _defineProperty3['default'])(_React$cloneElement, _this.props.pickerValueProp, pickerValue), (0, _defineProperty3['default'])(_React$cloneElement, _this.props.pickerValueChangeProp, _this.onPickerChange), (0, _defineProperty3['default'])(_React$cloneElement, 'ref', _this.saveRef), _React$cloneElement));
                    } else {
                        return _this.props.content;
                    }
                };

                _this.onDismiss = function () {
                    _this.props.onDismiss();

                    _this.fireVisibleChange(false);
                };

                _this.hide = function () {
                    _this.fireVisibleChange(false);
                };

                _this.state = {
                    pickerValue: 'value' in _this.props ? _this.props.value : null,
                    visible: _this.props.visible || false
                };
                return _this;
            }

            (0, _createClass3['default'])(_a, [{
                key: 'componentWillReceiveProps',
                value: function componentWillReceiveProps(nextProps) {
                    if ('value' in nextProps) {
                        this.setState({
                            pickerValue: nextProps.value
                        });
                    }

                    if ('visible' in nextProps) {
                        this.setVisibleState(nextProps.visible);
                    }
                }
            }, {
                key: 'setVisibleState',
                value: function setVisibleState(visible) {
                    this.setState({
                        visible: visible
                    });

                    if (!visible) {
                        this.setState({
                            pickerValue: null
                        });
                    }
                }
            }, {
                key: 'fireVisibleChange',
                value: function fireVisibleChange(visible) {
                    if (this.state.visible !== visible) {
                        if (!('visible' in this.props)) {
                            this.setVisibleState(visible);
                        }

                        this.props.onVisibleChange(visible);
                    }
                }
            }, {
                key: 'getRender',
                value: function getRender() {
                    var props = this.props;
                    var children = props.children;

                    if (!children) {
                        return getModal(props, this.state.visible, {
                            getContent: this.getContent,
                            onOk: this.onOk,
                            hide: this.hide,
                            onDismiss: this.onDismiss
                        });
                    }

                    var _props = this.props,
                        WrapComponent = _props.WrapComponent,
                        disabled = _props.disabled;
                    var child = children;
                    var newChildProps = {};

                    if (!disabled) {
                        newChildProps[props.triggerType] = this.onTriggerClick;
                    }

                    return _react2['default'].createElement(WrapComponent, {
                        style: props.wrapStyle
                    }, _react2['default'].cloneElement(child, newChildProps), getModal(props, this.state.visible, {
                        getContent: this.getContent,
                        onOk: this.onOk,
                        hide: this.hide,
                        onDismiss: this.onDismiss
                    }));
                }
            }, {
                key: 'render',
                value: function render() {
                    return this.getRender();
                }
            }]);
            return _a;
        }(_react2['default'].Component), _a.defaultProps = (0, _extends3['default'])({
            onVisibleChange: function onVisibleChange(_) {},
            okText: 'Ok',
            dismissText: 'Dismiss',
            title: '',
            onOk: function onOk(_) {},
            onDismiss: function onDismiss() {}
        }, platformProps), _a;

        var _a;
    }

    module.exports = exports['default'];
},10382,[13201,10385,13318,13321,13333,13435,10297],"node_modules/rmc-picker/lib/PopupMixin.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  "use strict";

  exports.__esModule = true;

  var _defineProperty = _require(_dependencyMap[0]);

  var _defineProperty2 = _interopRequireDefault(_defineProperty);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  exports.default = function (obj, key, value) {
    if (key in obj) {
      (0, _defineProperty2.default)(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };
},10385,[13324],"node_modules/babel-runtime/helpers/defineProperty.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _classCallCheck2 = _require(_dependencyMap[0]);

    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

    var _createClass2 = _require(_dependencyMap[1]);

    var _createClass3 = _interopRequireDefault(_createClass2);

    var _possibleConstructorReturn2 = _require(_dependencyMap[2]);

    var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

    var _inherits2 = _require(_dependencyMap[3]);

    var _inherits3 = _interopRequireDefault(_inherits2);

    var _react = _require(_dependencyMap[4]);

    var _react2 = _interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[5]);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            'default': obj
        };
    }

    var styles = _reactNative.StyleSheet.create({
        wrap: {
            flex: 1,
            backgroundColor: 'rgba(0,0,0,0)'
        },
        mask: {
            backgroundColor: 'black',
            opacity: .5
        },
        content: {
            backgroundColor: 'white'
        },
        absolute: {
            position: 'absolute',
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        }
    });

    var screen = _reactNative.Dimensions.get('window');

    var RCModal = function (_React$Component) {
        (0, _inherits3['default'])(RCModal, _React$Component);

        function RCModal(props) {
            (0, _classCallCheck3['default'])(this, RCModal);

            var _this = (0, _possibleConstructorReturn3['default'])(this, (RCModal.__proto__ || Object.getPrototypeOf(RCModal)).call(this, props));

            _this.animateMask = function (visible) {
                _this.stopMaskAnim();

                _this.state.opacity.setValue(_this.getOpacity(!visible));

                _this.animMask = _reactNative.Animated.timing(_this.state.opacity, {
                    toValue: _this.getOpacity(visible),
                    duration: _this.props.animationDuration
                });

                _this.animMask.start(function () {
                    _this.animMask = null;
                });
            };

            _this.stopMaskAnim = function () {
                if (_this.animMask) {
                    _this.animMask.stop();

                    _this.animMask = null;
                }
            };

            _this.stopDialogAnim = function () {
                if (_this.animDialog) {
                    _this.animDialog.stop();

                    _this.animDialog = null;
                }
            };

            _this.animateDialog = function (visible) {
                _this.stopDialogAnim();

                _this.animateMask(visible);

                var _this$props = _this.props,
                    animationType = _this$props.animationType,
                    animationDuration = _this$props.animationDuration;
                animationDuration = animationDuration;

                if (animationType !== 'none') {
                    if (animationType === 'slide-up' || animationType === 'slide-down') {
                        _this.state.position.setValue(_this.getPosition(!visible));

                        _this.animDialog = _reactNative.Animated.timing(_this.state.position, {
                            toValue: _this.getPosition(visible),
                            duration: animationDuration,
                            easing: visible ? _reactNative.Easing.elastic(0.8) : undefined
                        });
                    } else if (animationType === 'fade') {
                        _this.animDialog = _reactNative.Animated.parallel([_reactNative.Animated.timing(_this.state.opacity, {
                            toValue: _this.getOpacity(visible),
                            duration: animationDuration,
                            easing: visible ? _reactNative.Easing.elastic(0.8) : undefined
                        }), _reactNative.Animated.spring(_this.state.scale, {
                            toValue: _this.getScale(visible)
                        })]);
                    }

                    _this.animDialog.start(function () {
                        _this.animDialog = null;

                        if (!visible) {
                            _this.setState({
                                modalVisible: false
                            });
                        }

                        if (_this.props.onAnimationEnd) {
                            _this.props.onAnimationEnd(visible);
                        }
                    });
                } else {
                    if (!visible) {
                        _this.setState({
                            modalVisible: false
                        });
                    }
                }
            };

            _this.close = function () {
                _this.animateDialog(false);
            };

            _this.onMaskClose = function () {
                if (_this.props.maskClosable && _this.props.onClose) {
                    _this.props.onClose();
                }
            };

            _this.getPosition = function (visible) {
                if (visible) {
                    return 0;
                }

                return _this.props.animationType === 'slide-down' ? -screen.height : screen.height;
            };

            _this.getScale = function (visible) {
                return visible ? 1 : 1.05;
            };

            _this.getOpacity = function (visible) {
                return visible ? 1 : 0;
            };

            var visible = props.visible;
            _this.state = {
                position: new _reactNative.Animated.Value(_this.getPosition(visible)),
                scale: new _reactNative.Animated.Value(_this.getScale(visible)),
                opacity: new _reactNative.Animated.Value(_this.getOpacity(visible)),
                modalVisible: visible
            };
            return _this;
        }

        (0, _createClass3['default'])(RCModal, [{
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps) {
                if (this.shouldComponentUpdate(nextProps, null)) {
                    this.setState({
                        modalVisible: true
                    });
                }
            }
        }, {
            key: 'shouldComponentUpdate',
            value: function shouldComponentUpdate(nextProps, nextState) {
                if (this.props.visible || this.props.visible !== nextProps.visible) {
                    return true;
                }

                if (nextState) {
                    if (nextState.modalVisible !== this.state.modalVisible) {
                        return true;
                    }
                }

                return false;
            }
        }, {
            key: 'componentDidMount',
            value: function componentDidMount() {
                if (this.props.animateAppear && this.props.animationType !== 'none') {
                    this.componentDidUpdate({});
                }
            }
        }, {
            key: 'componentDidUpdate',
            value: function componentDidUpdate(prevProps) {
                var props = this.props;

                if (prevProps.visible !== props.visible) {
                    this.animateDialog(props.visible);
                }
            }
        }, {
            key: 'render',
            value: function render() {
                var props = this.props;

                if (!this.state.modalVisible) {
                    return null;
                }

                var animationStyleMap = {
                    none: {},
                    'slide-up': {
                        transform: [{
                            translateY: this.state.position
                        }]
                    },
                    'slide-down': {
                        transform: [{
                            translateY: this.state.position
                        }]
                    },
                    fade: {
                        transform: [{
                            scale: this.state.scale
                        }],
                        opacity: this.state.opacity
                    }
                };
                return _react2['default'].createElement(_reactNative.Modal, {
                    visible: true,
                    transparent: true,
                    onRequestClose: this.props.onClose,
                    supportedOrientations: ['portrait', 'landscape']
                }, _react2['default'].createElement(_reactNative.View, {
                    style: [styles.wrap, props.wrapStyle]
                }, _react2['default'].createElement(_reactNative.TouchableWithoutFeedback, {
                    onPress: this.onMaskClose
                }, _react2['default'].createElement(_reactNative.Animated.View, {
                    style: [styles.absolute, {
                        opacity: this.state.opacity
                    }]
                }, _react2['default'].createElement(_reactNative.View, {
                    style: [styles.absolute, props.maskStyle]
                }))), _react2['default'].createElement(_reactNative.Animated.View, {
                    style: [styles.content, props.style, animationStyleMap[props.animationType]]
                }, this.props.children)));
            }
        }]);
        return RCModal;
    }(_react2['default'].Component);

    exports['default'] = RCModal;
    RCModal.defaultProps = {
        wrapStyle: styles.wrap,
        maskStyle: styles.mask,
        animationType: 'slide-up',
        animateAppear: false,
        animationDuration: 300,
        visible: false,
        maskClosable: true,
        onClose: function onClose() {},
        onAnimationEnd: function onAnimationEnd(_visible) {}
    };
    module.exports = exports['default'];
},10388,[13318,13321,13333,13435,10297,10033],"node_modules/rmc-dialog/lib/Modal.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _extends2 = _require(_dependencyMap[0]);

    var _extends3 = _interopRequireDefault(_extends2);

    var _reactNative = _require(_dependencyMap[1]);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            'default': obj
        };
    }

    var textStyle = {
        color: '#0ae',
        fontSize: 18,
        textAlign: 'center'
    };

    var styles = _reactNative.StyleSheet.create({
        modal: {
            flexDirection: 'column',
            justifyContent: 'flex-end'
        },
        header: {
            height: 44,
            alignItems: 'center',
            flexDirection: 'row',
            justifyContent: 'center',
            borderBottomWidth: 1,
            borderBottomColor: '#e7e7e7'
        },
        headerItem: {
            height: 44,
            alignItems: 'center',
            justifyContent: 'center',
            flex: 1
        },
        actionText: textStyle,
        okText: {},
        dismissText: {},
        title: (0, _extends3['default'])({}, textStyle, {
            color: '#666'
        })
    });

    exports['default'] = styles;
    module.exports = exports['default'];
},10391,[13201,10033],"node_modules/rmc-picker/lib/PopupStyles.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _miot = _require(_dependencyMap[2]);

  var _TitleBarBlack = _require(_dependencyMap[3]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[4]);

  var _SettingListItemView = _require(_dependencyMap[5]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var GeneralSettingPage = function (_React$Component) {
    babelHelpers.inherits(GeneralSettingPage, _React$Component);

    function GeneralSettingPage(props) {
      babelHelpers.classCallCheck(this, GeneralSettingPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (GeneralSettingPage.__proto__ || Object.getPrototypeOf(GeneralSettingPage)).call(this, props));

      _this.renameRobot = function () {
        _miot.Host.ui.openChangeDeviceName();
      };

      _this.shareRobot = function () {
        _miot.Host.ui.openShareDevicePage();
      };

      _this.locationManager = function () {
        _miot.Host.ui.openRoomManagementPage();
      };

      _this.checkVersion = function () {
        _miot.Host.ui.openDeviceUpgradePage();
      };

      _this.deleteDevice = function () {
        _miot.Host.ui.openDeleteDevice();
      };

      _this.addDesktop = function () {
        _miot.Host.ui.openAddToDesktopPage();
      };

      _this.networkInfo = function () {
        _this.props.navigation.navigate("netInfo");
      };

      _this.deviceTimeZone = function () {
        _miot.Host.ui.openDeviceTimeZoneSettingPage();
      };

      _this.feedback = function () {
        _miot.Host.ui.openFeedbackInput();
      };

      _this.security = function () {
        _miot.Host.ui.openSecuritySetting();
      };

      _this.state = {
        name: _miot.Device.name
      };
      return _this;
    }

    babelHelpers.createClass(GeneralSettingPage, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var _this2 = this;

        this._deviceNameChangedListener = _miot.DeviceEvent.deviceNameChanged.addListener(function (device) {
          _this2.setState({
            name: device.name
          });
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._deviceNameChangedListener) {
          this._deviceNameChangedListener.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var hasNewFirmware = false;
        var params = this.props.navigation.state.params;

        if (params) {
          hasNewFirmware = params.hasNewFirmware === true;
        }

        return _react2.default.createElement(
          _reactNative.ScrollView,
          {
            style: styles.container
          },
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('securitySetting'),
            onPress: this.security
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('feedback'),
            onPress: this.feedback
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('addDesktop'),
            onPress: this.addDesktop
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          })
        );
      }
    }]);
    return GeneralSettingPage;
  }(_react2.default.Component);

  GeneralSettingPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('moreSetting'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = GeneralSettingPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: '#fff'
    },
    listItem: {
      height: 55,
      paddingLeft: 25,
      paddingRight: 25,
      flex: 1.0
    },
    line: {
      height: 1 / _reactNative.PixelRatio.get(),
      flex: 1.0,
      marginLeft: 25,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10394,[10297,10033,10074,10121,10157,10340],"projects/com.dreame.devices/main/GeneralSettingPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _RemoteView = _require(_dependencyMap[4]);

  var _RemoteView2 = babelHelpers.interopRequireDefault(_RemoteView);

  var _miot = _require(_dependencyMap[5]);

  var _LoadingDialog = _require(_dependencyMap[6]);

  var _LoadingDialog2 = babelHelpers.interopRequireDefault(_LoadingDialog);

  var _CopyMessageDialog = _require(_dependencyMap[7]);

  var _CopyMessageDialog2 = babelHelpers.interopRequireDefault(_CopyMessageDialog);

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var did = _miot.Device.getDeviceWifi().deviceID;

  var RemoteControlPage = function (_React$Component) {
    babelHelpers.inherits(RemoteControlPage, _React$Component);

    function RemoteControlPage(props) {
      babelHelpers.classCallCheck(this, RemoteControlPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (RemoteControlPage.__proto__ || Object.getPrototypeOf(RemoteControlPage)).call(this, props));

      _this.showTips = function () {
        _this.setState({
          showLoading: false,
          showMessage: true
        });
      };

      _this.goBack = function () {
        _this.setState({
          showMessage: false,
          showLoading: false
        });

        _this.props.navigation.goBack();
      };

      _this.handleSetViewport = function (e) {
        _this.setState({
          mainHeight: e.nativeEvent.layout.height
        });
      };

      _this.dismissLoad = function () {
        _this.setState({
          showLoading: false
        });
      };

      _this.state = {
        mainHeight: height,
        showLoading: true,
        showMessage: false
      };
      return _this;
    }

    babelHelpers.createClass(RemoteControlPage, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        var _this2 = this;

        this.didFocusListener = this.props.navigation.addListener('willFocus', function () {
          _this2.setState({
            showLoading: true
          });

          _miot.Device.getDeviceWifi().localPing().then(function (res) {
            if (res == true) {
              _this2.setState({
                showLoading: false
              });
            } else {
              _this2.showTips();
            }
          }).catch(function (err) {
            _this2.showTips();
          });
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.didFocusListener) {
          this.didFocusListener.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container,
            onLayout: this.handleSetViewport
          },
          _react2.default.createElement(_RemoteView2.default, {
            width: width,
            height: this.state.mainHeight
          }),
          _react2.default.createElement(_LoadingDialog2.default, {
            visible: this.state.showLoading,
            cancelable: false,
            timeout: Const.loadingTimeOut,
            onDismiss: this.dismissLoad,
            message: (0, _MHLocalizableString.getString)('remoteTip2')
          }),
          _react2.default.createElement(_CopyMessageDialog2.default, {
            visible: this.state.showMessage,
            title: (0, _MHLocalizableString.getString)('prompt'),
            message: (0, _MHLocalizableString.getString)('remoteTips'),
            buttons: [{
              text: (0, _MHLocalizableString.getString)('sure'),
              style: {
                color: '#5696ff'
              },
              callback: function callback(_) {
                _this3.goBack();
              }
            }],
            onDismiss: this.goBack
          })
        );
      }
    }]);
    return RemoteControlPage;
  }(_react2.default.Component);

  RemoteControlPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;

    var stop = function stop() {
      _miot.Device.getDeviceWifi().callMethod("action", {
        "did": did,
        "siid": 18,
        "aiid": 2,
        "in": []
      }).then(function (res) {
        console.log("-----------", res);
      }).catch(function (err) {
        console.log('startClean failed:', err);
      });
    };

    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('remoteControl'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = RemoteControlPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: '#fff',
      flex: 1.0
    },
    listItem: {
      height: 50,
      flex: 1.0
    },
    line: {
      height: 1,
      flex: 1.0,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10397,[10297,10033,10121,10157,10400,10074,10740,10289],"projects/com.dreame.devices/main/RemoteControlPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _glReact = _require(_dependencyMap[2]);

  var _glReact2 = babelHelpers.interopRequireDefault(_glReact);

  var _glReactNative = _require(_dependencyMap[3]);

  var _miot = _require(_dependencyMap[4]);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      height = _Dimensions$get.height;

  var shaders = _glReact2.default.Shaders.create({
    controlGL: {
      frag: "\nprecision highp float;\nvarying vec2 uv;\n\nuniform vec2 dim;\nuniform float r;\nuniform int touchId;\n\nuniform sampler2D bg;\nuniform sampler2D left;\nuniform sampler2D right;\nuniform sampler2D forward;\n\n\nvoid main () {\n    vec2 uv_ = uv*dim;\n    vec4 startColor = vec4(0.95,0.972,1.0,1.0);\n    vec4 endColor = vec4(1.0,1.0,1.0,1.0);\n    gl_FragColor = mix(startColor,endColor,uv.y);\n    vec2 center = dim/2.0;\n\n    vec2 cr = abs(uv_ - center);\n    if(cr.x<r && cr.y<r){\n      vec2 p = (uv_ - center + r)/(2.0 * r);\n      vec4 rc = texture2D(bg,p); \n      gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n      if(touchId == 1){\n        vec4 f = texture2D(forward,p); \n        gl_FragColor = vec4(mix(gl_FragColor.rgb,f.rgb,f.a),1.0);\n      }else if(touchId == 2){\n        vec4 l = texture2D(left,p); \n        gl_FragColor = vec4(mix(gl_FragColor.rgb,l.rgb,l.a),1.0);\n      }else if(touchId == 3){\n        vec4 r = texture2D(right,p); \n        gl_FragColor = vec4(mix(gl_FragColor.rgb,r.rgb,r.a),1.0);\n      }\n    }\n  \n}\n    "
    }
  });

  var Action = {
    ACTION_NONE: 0,
    ACTION_TOUCH: 1
  };

  var RemoteView = function (_React$Component) {
    babelHelpers.inherits(RemoteView, _React$Component);

    function RemoteView(props) {
      babelHelpers.classCallCheck(this, RemoteView);

      var _this = babelHelpers.possibleConstructorReturn(this, (RemoteView.__proto__ || Object.getPrototypeOf(RemoteView)).call(this, props));

      _this.initialize = function () {
        _this.action = Action.ACTION_NONE;
        _this._panResponder = _reactNative.PanResponder.create({
          onStartShouldSetPanResponder: function onStartShouldSetPanResponder(evt, gestureState) {
            console.log("onStartShouldSetPanResponder");
            return false;
          },
          onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture(evt, gestureState) {
            var dis = _this.calculateDistance(evt);

            console.log("onStartShouldSetPanResponderCapture", dis, _this.maxDis, _this.minDis, _this.state.r);

            if (dis < _this.maxDis && dis > _this.minDis) {
              var touchId = _this.calculateDirection(evt);

              if (touchId != 0) {
                _this.action = Action.ACTION_TOUCH;

                _this.setState({
                  touchId: touchId
                });

                _this.startRemote(touchId);

                return true;
              }
            }

            return false;
          },
          onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {
            return false;
          },
          onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture(evt, gestureState) {
            return false;
          },
          onPanResponderGrant: function onPanResponderGrant(evt, gestureState) {},
          onPanResponderMove: function onPanResponderMove(evt, gestureState) {},
          onPanResponderTerminationRequest: function onPanResponderTerminationRequest(evt, gestureState) {
            return true;
          },
          onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {
            console.log("onPanResponderRelease");

            if (_this.action == Action.ACTION_TOUCH) {
              _this.setState({
                touchId: 0
              });

              _this.action = Action.ACTION_NONE;

              _this.stopRemote();
            }
          },
          onPanResponderTerminate: function onPanResponderTerminate(evt, gestureState) {},
          onShouldBlockNativeResponder: function onShouldBlockNativeResponder(evt, gestureState) {
            return true;
          }
        });
      };

      _this.calculateDistance = function (evt) {
        var x = evt.nativeEvent.locationX;
        var y = evt.nativeEvent.locationY;
        console.log(x, y);
        var dis = Math.sqrt(Math.pow(x - _this.props.width / 2, 2) + Math.pow(y - _this.props.height / 2, 2));
        return dis;
      };

      _this.calculateDirection = function (evt) {
        var x = evt.nativeEvent.locationX;
        var y = evt.nativeEvent.locationY;
        var center = {
          x: _this.props.width / 2,
          y: _this.props.height / 2
        };
        var w = _this.props.width;
        var h = _this.props.height;
        var y_ = Math.abs(y - center.y);
        var x_ = Math.abs(x - center.x);

        if (y < center.y) {
          if (y_ > x_) {
            return 1;
          } else {
            if (x < center.x) {
              return 2;
            } else {
              return 3;
            }
          }
        } else {
          if (y_ < x_) {
            if (x < center.x) {
              return 2;
            } else {
              return 3;
            }
          }
        }

        return 0;
      };

      _this.startRemote = function (touchId) {
        _this.touchId = touchId;

        if (_this.interval) {
          clearInterval(_this.interval);
          _this.interval = null;
        }

        _this.sendRemoteCtrl(_this.touchId);

        _this.interval = setInterval(function () {
          _this.sendRemoteCtrl(_this.touchId);
        }, 500);
      };

      _this.stopRemote = function () {
        if (_this.interval) {
          clearInterval(_this.interval);
          _this.interval = null;
        }

        _this.touchId = 0;

        _miot.Device.getDeviceWifi().callMethodFromLocal("action", {
          "did": did,
          "siid": 21,
          "aiid": 2,
          "in": []
        }).then(function (res) {
          console.log("-----------stop", res);
        }).catch(function (err) {
          console.log('startClean failed:', err);
        });
      };

      _this.sendRemoteCtrl = function (touchId) {
        var v = 0;
        var wv = 0;

        if (touchId == 1) {
          v = 300;
          wv = 0;
        } else if (touchId == 2) {
          v = 0;
          wv = 120;
        } else if (touchId == 3) {
          v = 0;
          wv = -120;
        } else {
          return;
        }

        _miot.Device.getDeviceWifi().callMethodFromLocal("action", {
          "did": did,
          "siid": 21,
          "aiid": 1,
          "in": [{
            "piid": 1,
            "value": '' + wv
          }, {
            "piid": 2,
            "value": '' + v
          }]
        }).then(function (res) {
          console.log("-----------start", res);
        }).catch(function (err) {
          console.log('startClean failed:', err);
        });
      };

      _this.getTouchImage = function () {
        if (_this.state.touchId == 1) {
          return _require(_dependencyMap[5]);
        } else if (_this.state.touchId == 2) {
          return _require(_dependencyMap[6]);
        } else {
          return _require(_dependencyMap[7]);
        }
      };

      _this.state = {
        touch: [0, 0],
        isTouch: 0,
        touchId: 0,
        r: 0.7333333333333333 * _this.props.width / 2
      };
      _this.minDis = 13 * _this.state.r / 40;
      _this.maxDis = 37 * _this.state.r / 40;

      _this.initialize();

      return _this;
    }

    babelHelpers.createClass(RemoteView, [{
      key: "componentWillMount",
      value: function componentWillMount() {}
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {}
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            width = _props.width,
            height = _props.height;
        var dim = [width, height];
        var _state = this.state,
            touchId = _state.touchId,
            r = _state.r;
        var imageWidth = r * 2;
        var left = (width - imageWidth) / 2;
        var top = (height - imageWidth) / 2;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: {
              width: width,
              height: height,
              backgroundColor: "#FFFFFF"
            }
          },
          _react2.default.createElement(_reactNative.Image, {
            style: {
              width: imageWidth,
              height: imageWidth,
              position: "absolute",
              left: left,
              top: top
            },
            resizeMode: "contain",
            source: _require(_dependencyMap[8])
          }),
          this.state.touchId > 0 ? _react2.default.createElement(_reactNative.Image, {
            style: {
              width: imageWidth,
              height: imageWidth,
              position: "absolute",
              left: left,
              top: top
            },
            resizeMode: "contain",
            source: this.getTouchImage()
          }) : null,
          _react2.default.createElement(_reactNative.View, babelHelpers.extends({}, this._panResponder.panHandlers, {
            style: {
              width: width,
              height: height,
              backgroundColor: "#00000000",
              position: "absolute"
            }
          }))
        );
      }
    }]);
    return RemoteView;
  }(_react2.default.Component);

  exports.default = RemoteView;
},10400,[10297,10033,13489,13480,10074,10403,10406,10409,10412],"projects/com.dreame.devices/main/widget/RemoteView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 792,
      "height": 792,
      "scales": [1],
      "hash": "214ae277899fe8b5d7a4e64883e1169c",
      "name": "remote_forward",
      "type": "png"
   });
},10403,[10420],"projects/com.dreame.devices/resources/remote_forward.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 792,
      "height": 792,
      "scales": [1],
      "hash": "4c2f58a6b99dddebae9ed87a18f5504b",
      "name": "remote_left",
      "type": "png"
   });
},10406,[10420],"projects/com.dreame.devices/resources/remote_left.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 792,
      "height": 792,
      "scales": [1],
      "hash": "3500b9536acaffc39bf1480eb7dee176",
      "name": "remote_right",
      "type": "png"
   });
},10409,[10420],"projects/com.dreame.devices/resources/remote_right.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 792,
      "height": 792,
      "scales": [1],
      "hash": "9f3762ddae5bac8a1fd20afc9f6a55c4",
      "name": "remote_bg",
      "type": "png"
   });
},10412,[10420],"projects/com.dreame.devices/resources/remote_bg.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _reactNativeUiKitten = _require(_dependencyMap[5]);

  var _ui = _require(_dependencyMap[6]);

  var _miot = _require(_dependencyMap[7]);

  var _CopyMessageDialog = _require(_dependencyMap[8]);

  var _CopyMessageDialog2 = babelHelpers.interopRequireDefault(_CopyMessageDialog);

  var _Toast = _require(_dependencyMap[9]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var repeatData = [(0, _MHLocalizableString.getString)("once"), (0, _MHLocalizableString.getString)("everyDay"), (0, _MHLocalizableString.getString)("workDay"), (0, _MHLocalizableString.getString)("weekend"), (0, _MHLocalizableString.getString)("custom")];
  var modeData = [(0, _MHLocalizableString.getString)("modeQuiet"), (0, _MHLocalizableString.getString)("modeStandard"), (0, _MHLocalizableString.getString)("modeMedium"), (0, _MHLocalizableString.getString)("modeStrong")];
  var repeatValue = ["0000000", "1111111", "0111110", "1000001"];
  var week = [(0, _MHLocalizableString.getString)("Sunday"), (0, _MHLocalizableString.getString)("Monday"), (0, _MHLocalizableString.getString)("Tuesday"), (0, _MHLocalizableString.getString)("Wednesday"), (0, _MHLocalizableString.getString)("Thursday"), (0, _MHLocalizableString.getString)("Friday"), (0, _MHLocalizableString.getString)("Saturday")];
  var repeatKey = {
    "0000000": 0,
    "1111111": 1,
    "0111110": 2,
    "1000001": 3
  };

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var MyListItem = function (_React$PureComponent) {
    babelHelpers.inherits(MyListItem, _React$PureComponent);

    function MyListItem(props) {
      babelHelpers.classCallCheck(this, MyListItem);

      var _this = babelHelpers.possibleConstructorReturn(this, (MyListItem.__proto__ || Object.getPrototypeOf(MyListItem)).call(this, props));

      _this._onPress = function () {
        _this.props.onPressItem(_this.props.id);
      };

      _this._onLongPress = function () {
        _this.props.onLongPress(_this.props.id);
      };

      _this._onSwitchChange = function (id) {
        if (_this.props.onSwitchChange) {
          _this.props.onSwitchChange(id);
        }
      };

      _this.createType = function (item) {};

      _this.createMode = function (item) {
        var currentMode = modeData[item.mode];
        return currentMode;
      };

      _this.createDesc = function (item) {
        var repeatDataSelect = "";

        if (repeatKey[item.week] != undefined) {
          var repeatCheck = repeatKey[item.week];
          repeatDataSelect = repeatData[repeatCheck];
        } else {
          for (var i in week) {
            var isChecked = item.week.charAt(i) === "1";

            if (isChecked) {
              repeatDataSelect = repeatDataSelect + week[i] + " ";
            }
          }
        }

        return repeatDataSelect;
      };

      _this.state = props.itemData;
      _this.isPressed = false;
      return _this;
    }

    babelHelpers.createClass(MyListItem, [{
      key: "_buttonPressIn",
      value: function _buttonPressIn() {
        this.isPressed = true;

        if (this.cover) {
          this.cover.setNativeProps({
            style: {
              borderColor: 'rgba(0,0,0,0.05)',
              backgroundColor: 'rgba(0,0,0,0.05)'
            }
          });
        }
      }
    }, {
      key: "_buttonPressOut",
      value: function _buttonPressOut() {
        this.isPressed = false;

        if (this.cover) {
          this.cover.setNativeProps({
            style: {
              borderColor: 'rgba(255,255,255,0)',
              backgroundColor: 'rgba(255,255,255,0)'
            }
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        if (this.state != this.props.itemData) {
          this.state = this.props.itemData;
        }

        var itemData = this.state;
        var cheight = 88;

        var lineHeight = 1 / _reactNative.PixelRatio.get();

        if (itemData.isLast == true) {
          return _react2.default.createElement(_reactNative.View, {
            style: {
              flexDirection: "row",
              height: cheight,
              paddingLeft: 30,
              paddingRight: 30
            }
          });
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: {
              flexDirection: "row",
              height: cheight,
              paddingLeft: 30,
              paddingRight: 30
            },
            alignItems: "center"
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              flex: 1.0,
              alignContent: "flex-start"
            },
            _react2.default.createElement(
              _reactNative.View,
              {
                flexDirection: "row",
                alignItems: "baseline",
                alignContent: "stretch"
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 22,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,1)'
                  }
                },
                itemData.time + " "
              ),
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 14,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,0.7)',
                    paddingBottom: 4
                  }
                },
                (0, _MHLocalizableString.getString)("timingStart")
              )
            ),
            _react2.default.createElement(
              _reactNative.View,
              {
                flexDirection: "row",
                marginTop: 2
              },
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 14,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,0.6)'
                  }
                },
                this.createMode(itemData)
              ),
              _react2.default.createElement(_reactNative.View, {
                style: {
                  backgroundColor: 'rgba(0,0,0,0.2)'
                },
                width: Const.onePixel,
                height: 14,
                marginLeft: 5,
                marginTop: 3,
                marginRight: 5
              }),
              _react2.default.createElement(
                _reactNative.Text,
                {
                  style: {
                    fontSize: 14,
                    fontFamily: Const.fontFamily,
                    color: 'rgba(0,0,0,0.6)'
                  }
                },
                this.createDesc(itemData)
              )
            )
          ),
          _react2.default.createElement(
            _reactNative.TouchableWithoutFeedback,
            {
              onPress: this._onPress,
              onLongPress: this._onLongPress,
              onPressIn: this._buttonPressIn.bind(this),
              onPressOut: this._buttonPressOut.bind(this)
            },
            _react2.default.createElement(_reactNative.View, {
              style: [{
                position: 'absolute',
                top: 0,
                left: 0,
                width: width,
                height: cheight
              }, this.isPressed ? {
                backgroundColor: 'rgba(255,255,255,0.5)'
              } : {
                backgroundColor: 'rgba(255,255,255,0)'
              }],
              ref: function ref(c) {
                return _this2.cover = c;
              }
            })
          ),
          _react2.default.createElement(_reactNativeUiKitten.RkSwitch, {
            style: {
              marginLeft: 5,
              borderRadius: 16,
              backgroundColor: '#f0f0f0'
            },
            tintColor: "#e3e3e3",
            onTintColor: "#5696ff",
            value: itemData.enable,
            onValueChange: function onValueChange() {
              var cEnable = !itemData.enable;
              _this2.props.itemData.enable = cEnable;

              _this2._onSwitchChange(itemData.id);
            }
          }),
          _react2.default.createElement(_reactNative.View, {
            style: {
              position: 'absolute',
              top: cheight - 2 * lineHeight,
              left: 30,
              height: lineHeight,
              width: width - 30,
              backgroundColor: 'rgba(0,0,0,0.1)'
            }
          })
        );
      }
    }]);
    return MyListItem;
  }(_react2.default.PureComponent);

  var TimingTaskPage = function (_React$PureComponent2) {
    babelHelpers.inherits(TimingTaskPage, _React$PureComponent2);

    function TimingTaskPage(props) {
      babelHelpers.classCallCheck(this, TimingTaskPage);

      var _this3 = babelHelpers.possibleConstructorReturn(this, (TimingTaskPage.__proto__ || Object.getPrototypeOf(TimingTaskPage)).call(this, props));

      _initialiseProps.call(_this3);

      _this3.height = height - 100;
      var tasks = [];
      _this3.taskStr = "";

      if (gData.tasks) {
        _this3.taskStr = gData.tasks;
        tasks = _this3.calculateTasks(_this3.taskStr);
      }

      ;
      _this3.state = {
        height: height - 100,
        tasks: tasks,
        deleteTaskVisible: false
      };
      return _this3;
    }

    babelHelpers.createClass(TimingTaskPage, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this4 = this;

        this.willBlurListener = this.props.navigation.addListener('willBlur', function () {});
        this.didFocusListener = this.props.navigation.addListener('willFocus', function () {
          _this4.initTImings();
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        var listDatas = [];

        if (this.state.tasks.length > 0) {
          listDatas = listDatas.concat(this.state.tasks);
          listDatas.push({
            id: "last",
            isLast: true
          });
        }

        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container,
            onLayout: this.handleSetViewport
          },
          _react2.default.createElement(_CopyMessageDialog2.default, {
            title: (0, _MHLocalizableString.getString)('prompt'),
            visible: this.state.deleteTaskVisible,
            message: (0, _MHLocalizableString.getString)('deleteMsg'),
            buttons: [{
              text: (0, _MHLocalizableString.getString)('cancle')
            }, {
              text: (0, _MHLocalizableString.getString)('confirm'),
              style: {
                color: '#5696ff'
              },
              callback: function callback(_) {
                _this5.deleteTask(_this5.deleteId);

                _this5.deleteId = undefined;

                _this5.setState({
                  deleteTaskVisible: false
                });
              }
            }],
            onDismiss: function onDismiss() {
              _this5.deleteId = undefined;

              _this5.setState({
                deleteTaskVisible: false
              });
            }
          }),
          _react2.default.createElement(_reactNative.FlatList, {
            data: listDatas,
            extraData: this.state,
            keyExtractor: this._keyExtractor,
            renderItem: this._renderItem,
            ListEmptyComponent: this._emptyComponent
          }),
          _react2.default.createElement(_ui.ImageButton, {
            ref: function ref(c) {
              return _this5.addBtn = c;
            },
            onPress: this._addTiming,
            style: {
              position: 'absolute',
              top: this.state.height - 85,
              left: width - 85,
              height: 75,
              width: 75
            },
            source: _require(_dependencyMap[10]),
            highlightedSource: _require(_dependencyMap[11])
          }),
          _react2.default.createElement(_Toast2.default, {
            ref: "toast",
            position: 'center',
            height: Const.contentViewHeight
          })
        );
      }
    }]);
    return TimingTaskPage;
  }(_react2.default.PureComponent);

  TimingTaskPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('cleanTiming'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  var _initialiseProps = function _initialiseProps() {
    var _this6 = this;

    this.initTImings = function () {
      _miot.Device.getDeviceWifi().callMethod("get_properties", [{
        "did": did,
        "siid": 18,
        "piid": 5
      }]).then(function (res) {
        console.log("initData:", res);

        if (res.code == 0 && res.result.length == 1) {
          var item = res.result[0];

          if (item.code === 0 && item.siid === 18 && item.piid === 5) {
            _this6.taskStr = item.value;
            gData.tasks = _this6.taskStr;

            var tasks = _this6.calculateTasks(_this6.taskStr);

            console.log("tasks:", tasks);

            _this6.setState({
              tasks: tasks
            });
          }
        }
      }).catch(function (err) {
        console.log('failed:', err);
      });
    };

    this.calculateTasks = function (task) {
      var taskStrs = task.split(",");
      var taskDatas = [];

      for (var i = 0; i < taskStrs.length; i++) {
        var item = taskStrs[i];

        if (item.indexOf("-") > 0) {
          var datas = item.split("-");

          if (datas.length === 8) {
            var taskItem = {
              id: datas[0],
              enable: datas[1] == "1",
              ts: datas[2],
              time: datas[3],
              week: _this6.calculateWeek(datas[4]),
              loop: datas[5],
              mode: parseInt(datas[6]),
              area: parseInt(datas[7])
            };
            taskDatas.push(taskItem);
          }
        }
      }

      return taskDatas;
    };

    this.calculateWeek = function (week) {
      var weekTmp = "";
      var currentLen = week.length;

      for (var i = 0; i < 7 - currentLen; i++) {
        weekTmp = weekTmp + "0";
      }

      weekTmp = weekTmp + week;
      return weekTmp;
    };

    this._keyExtractor = function (item, index) {
      return item.id;
    };

    this._onPressItem = function (id) {
      _this6.props.navigation.navigate("addTiming", {
        isEdit: true,
        id: id,
        tasks: _this6.taskStr
      });
    };

    this._onLongPress = function (id) {
      _this6.deleteId = id;

      _this6.setState({
        deleteTaskVisible: true
      });
    };

    this._onSwitchChange = function (id) {
      _this6.updateTiming(id);
    };

    this.updateTiming = function () {
      var value = '';
      var length = _this6.state.tasks.length;
      var tasksClone = [];

      for (var i = 0; i < length; i++) {
        var item = _this6.state.tasks[i];
        tasksClone.push({
          id: item.id,
          enable: item.enable,
          ts: item.ts,
          time: item.time,
          week: item.week,
          loop: item.loop,
          mode: item.mode,
          area: item.area
        });
        var itemStr = item.id + "-" + (item.enable === true ? "1" : "0") + "-" + item.ts + "-" + item.time + "-" + item.week + "-" + item.loop + "-" + item.mode + "-" + item.area;
        value = value + itemStr;

        if (i != length - 1) {
          value = value + ",";
        }
      }

      console.log("update", _this6.state.tasks, value);

      _this6.setState({
        tasks: tasksClone
      });

      _miot.Device.getDeviceWifi().callMethod("set_properties", [{
        "did": did,
        "siid": 18,
        "piid": 5,
        "value": value
      }]).then(function (res) {
        console.log("-----------", value, res);
        gData.tasks = value;
      }).catch(function (err) {
        console.log('changeMode failed:', err);
      });
    };

    this._renderItem = function (_ref2) {
      var item = _ref2.item;
      return _react2.default.createElement(MyListItem, {
        id: item.id,
        onPressItem: _this6._onPressItem,
        onLongPress: _this6._onLongPress,
        onSwitchChange: _this6._onSwitchChange,
        itemData: item
      });
    };

    this.showToast = function (msg) {
      if (_this6.refs.toast) {
        _this6.refs.toast.show(msg, 1200);
      }
    };

    this._addTiming = function () {
      var num = _this6.state.tasks.length;

      if (num >= 10) {
        _this6.showToast((0, _MHLocalizableString.getString)('timingNumTip'));

        return;
      }

      _this6.props.navigation.navigate("addTiming", {
        isEdit: false,
        id: -1,
        tasks: _this6.taskStr
      });
    };

    this._emptyComponent = function () {
      return _react2.default.createElement(
        _reactNative.View,
        {
          width: width,
          height: height - 300,
          alignItems: "center",
          justifyContent: "center"
        },
        _react2.default.createElement(_reactNative.Image, {
          resizeMode: "contain",
          style: {
            width: 30,
            height: 30
          },
          source: _require(_dependencyMap[12])
        }),
        _react2.default.createElement(
          _reactNative.Text,
          {
            style: {
              fontSize: 16,
              marginTop: 5,
              fontFamily: Const.fontFamily,
              color: 'rgba(0,0,0,0.4)'
            }
          },
          (0, _MHLocalizableString.getString)('noTiming')
        )
      );
    };

    this.deleteTask = function (id) {
      _miot.Device.getDeviceWifi().callMethod("set_properties", [{
        "did": did,
        "siid": 18,
        "piid": 8,
        "value": parseInt(id)
      }]).then(function (res) {
        console.log("-----------", res, id);

        _this6.initTImings();
      }).catch(function (err) {
        console.log('changeMode failed:', err);
      });
    };

    this.handleSetViewport = function (e) {
      _this6.setState({
        height: e.nativeEvent.layout.height
      });
    };
  };

  exports.default = TimingTaskPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: 'rgba(255,255,255,1)',
      flex: 1.0
    },
    cardStyle: {
      flexDirection: "row"
    },
    listItem: {
      height: 50,
      width: width - 40,
      marginLeft: 20
    },
    line: {
      height: 1,
      width: width,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10415,[10297,10033,10121,10157,10340,11251,10230,10074,10289,10343,10418,10421,10424],"projects/com.dreame.devices/main/TimingTaskPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 202,
      "height": 202,
      "scales": [1],
      "hash": "0ef9f9f4704edcacd69808edafdf9b59",
      "name": "add_timing_task_normal",
      "type": "png"
   });
},10418,[10420],"projects/com.dreame.devices/resources/add_timing_task_normal.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 202,
      "height": 202,
      "scales": [1],
      "hash": "90cc4a91f5a3368884f383707af27acc",
      "name": "add_timing_task_press",
      "type": "png"
   });
},10421,[10420],"projects/com.dreame.devices/resources/add_timing_task_press.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 70,
    "height": 70,
    "scales": [1],
    "hash": "930d7c88dca9a171c109fd2ad2857388",
    "name": "empty_task",
    "type": "jpg"
  });
},10424,[10420],"projects/com.dreame.devices/resources/empty_task.jpg");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _AddTimingItemView = _require(_dependencyMap[4]);

  var _AddTimingItemView2 = babelHelpers.interopRequireDefault(_AddTimingItemView);

  var _miot = _require(_dependencyMap[5]);

  var _CopyMHDatePicker = _require(_dependencyMap[6]);

  var _CopyMHDatePicker2 = babelHelpers.interopRequireDefault(_CopyMHDatePicker);

  var _ChoiceDialog = _require(_dependencyMap[7]);

  var _ChoiceDialog2 = babelHelpers.interopRequireDefault(_ChoiceDialog);

  var _Toast = _require(_dependencyMap[8]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var modalWidth = width - 42;
  var optionHeight = 50;
  var selectHeight = 50;
  var titleHeight = 60;
  var buttonHeight = 55;
  var repeatData = [(0, _MHLocalizableString.getString)("once"), (0, _MHLocalizableString.getString)("everyDay"), (0, _MHLocalizableString.getString)("workDay"), (0, _MHLocalizableString.getString)("weekend"), (0, _MHLocalizableString.getString)("custom")];
  var modeData = [(0, _MHLocalizableString.getString)("modeQuiet"), (0, _MHLocalizableString.getString)("modeStandard"), (0, _MHLocalizableString.getString)("modeMedium"), (0, _MHLocalizableString.getString)("modeStrong")];
  var repeatValue = ["0000000", "1111111", "0111110", "1000001"];
  var week = [(0, _MHLocalizableString.getString)("Sunday"), (0, _MHLocalizableString.getString)("Monday"), (0, _MHLocalizableString.getString)("Tuesday"), (0, _MHLocalizableString.getString)("Wednesday"), (0, _MHLocalizableString.getString)("Thursday"), (0, _MHLocalizableString.getString)("Friday"), (0, _MHLocalizableString.getString)("Saturday")];
  var repeatKey = {
    "0000000": 0,
    "1111111": 1,
    "0111110": 2,
    "1000001": 3
  };

  var AddTimingPage = function (_React$Component) {
    babelHelpers.inherits(AddTimingPage, _React$Component);

    function AddTimingPage(props) {
      babelHelpers.classCallCheck(this, AddTimingPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (AddTimingPage.__proto__ || Object.getPrototypeOf(AddTimingPage)).call(this, props));

      _initialiseProps.call(_this);

      _this.state = {
        pikerStartVisible: false,
        repeatVisible: false,
        customVisiable: false,
        modeVisible: false,
        repeat: "0000000",
        start: ["00", "00"],
        modeSelect: 1
      };

      _this.init();

      var date = new Date(Date.now() + 60000);
      var hour = date.getHours();
      var minute = date.getMinutes();

      if (hour < 10) {
        _this.state.start[0] = "0" + hour;
      } else {
        _this.state.start[0] = "" + hour;
      }

      if (minute < 10) {
        _this.state.start[1] = "0" + minute;
      } else {
        _this.state.start[1] = "" + minute;
      }

      _this.customWeek = [];
      _this.customDialogData = [];

      for (var i in week) {
        _this.customWeek.push({
          dateKey: week[i],
          isChecked: false
        });

        _this.customDialogData.push({
          title: week[i]
        });
      }

      _this.id = -1;
      var params = _this.props.navigation.state.params;
      _this.tasks = _this.calculateTasks(params.tasks);

      if (params.isEdit === false) {
        _this.id = _this.createId();
      } else {
        _this.id = parseInt(params.id);

        for (var _i = 0; _i < _this.tasks.length; _i++) {
          if (_this.tasks[_i].id == _this.id) {
            _this.editItem = _this.tasks[_i];
            _this.state.repeat = _this.editItem.week;
            _this.state.modeSelect = _this.editItem.mode;

            var times = _this.editItem.time.split(":");

            if (times[0].length == 1) {
              times[0] = "0" + times[0];
            }

            if (times[1].length == 1) {
              times[1] = "0" + times[1];
            }

            _this.state.start = times;

            if (repeatKey[_this.state.repeat] == undefined) {
              for (var _i2 in _this.customWeek) {
                var isChecked = _this.state.repeat.charAt(_i2) == "1";
                _this.customWeek[_i2].isChecked = isChecked;
              }
            }

            break;
          }
        }
      }

      _this.props.navigation.setParams({
        confirmTiming: _this.confirmTiming
      });

      return _this;
    }

    babelHelpers.createClass(AddTimingPage, [{
      key: "hasIndexSelect",
      value: function hasIndexSelect(result, index) {
        for (var j = 0; j < result.length; j++) {
          if (result[j] == index) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var repeatCheck = 4;
        var currentMode = modeData[this.state.modeSelect];
        var modeSelectArray = [this.state.modeSelect];
        var repeatDataSelect = "";
        var customDialogCheck = [];

        if (repeatKey[this.state.repeat] != undefined) {
          repeatCheck = repeatKey[this.state.repeat];
          repeatDataSelect = repeatData[repeatCheck];
        } else {
          for (var i in this.customWeek) {
            var isChecked = this.state.repeat.charAt(i) == "1";

            if (isChecked) {
              repeatDataSelect = repeatDataSelect + this.customWeek[i].dateKey + " ";
            }
          }
        }

        if (this.state.customVisiable) {
          for (var _i3 = 0; _i3 < 7; _i3++) {
            var _isChecked = this.state.repeat.charAt(_i3) == "1";

            if (_isChecked) {
              console.log("type:", typeof _i3);
              customDialogCheck.push(_i3);
            }
          }
        }

        console.log(customDialogCheck);
        this.repeatCheckTmp = [repeatCheck];
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container
          },
          _react2.default.createElement(_CopyMHDatePicker2.default, {
            key: "tastStart",
            visible: this.state.pikerStartVisible,
            title: (0, _MHLocalizableString.getString)('startTime'),
            type: _CopyMHDatePicker2.default.TYPE.TIME24,
            current: this.state.start,
            confirmColor: "#5696ff",
            cancle: (0, _MHLocalizableString.getString)('cancle'),
            confirm: (0, _MHLocalizableString.getString)('sure'),
            onDismiss: function onDismiss(_) {
              return _this2.hidePicker();
            },
            onSelect: function onSelect(res) {
              return _this2.onSelect(res);
            }
          }),
          _react2.default.createElement(_ChoiceDialog2.default, {
            key: "multi",
            type: _ChoiceDialog2.default.TYPE.MULTIPLE,
            visible: this.state.customVisiable,
            title: (0, _MHLocalizableString.getString)('custom'),
            options: this.customDialogData,
            selectedIndexArray: customDialogCheck,
            color: "#5696ff",
            buttons: [{
              text: (0, _MHLocalizableString.getString)('sure'),
              style: {
                color: '#5696ff'
              },
              callback: function callback(result) {
                var repeat = "";

                for (var _i4 in _this2.customDialogData) {
                  if (_this2.hasIndexSelect(result, _i4)) {
                    repeat = repeat + "1";
                  } else {
                    repeat = repeat + "0";
                  }
                }

                console.log("customSelest", result, repeat);

                _this2.setState({
                  repeat: repeat,
                  customVisiable: false
                });
              }
            }],
            onDismiss: function onDismiss(_) {
              _this2.setState({
                customVisiable: false
              });
            }
          }),
          _react2.default.createElement(_ChoiceDialog2.default, {
            key: "repeat",
            type: _ChoiceDialog2.default.TYPE.SINGLE,
            visible: this.state.repeatVisible,
            title: (0, _MHLocalizableString.getString)('repeat'),
            options: this.repeatDialogData,
            selectedIndexArray: this.repeatCheckTmp,
            color: "#5696ff",
            icon: _require(_dependencyMap[9]),
            onDismiss: function onDismiss(_) {
              _this2.setState({
                repeatVisible: false
              });
            },
            onSelect: function onSelect(result) {
              var select = result[0];

              if (select < 4) {
                _this2.state.repeat = repeatValue[select];
              } else {
                _this2.state.customVisiable = true;
              }
            }
          }),
          _react2.default.createElement(_ChoiceDialog2.default, {
            key: "repeatMode",
            type: _ChoiceDialog2.default.TYPE.SINGLE,
            visible: this.state.modeVisible,
            title: (0, _MHLocalizableString.getString)('cleanMode'),
            options: this.modeDialogData,
            selectedIndexArray: modeSelectArray,
            color: "#5696ff",
            icon: _require(_dependencyMap[9]),
            onDismiss: function onDismiss(_) {
              _this2.setState({
                modeVisible: false
              });
            },
            onSelect: function onSelect(result) {
              _this2.state.modeSelect = result[0];
            }
          }),
          _react2.default.createElement(_AddTimingItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('startTime'),
            desc: this.getShowDate(this.state.start),
            onPress: this.startTime
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_AddTimingItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('repeat'),
            desc: repeatDataSelect,
            onPress: this.setRepeat
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_AddTimingItemView2.default, {
            style: styles.listItem,
            leftText: (0, _MHLocalizableString.getString)('cleanMode'),
            desc: currentMode,
            onPress: this.selectmode
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_Toast2.default, {
            ref: "toast",
            position: 'center',
            height: Const.contentViewHeight
          })
        );
      }
    }]);
    return AddTimingPage;
  }(_react2.default.Component);

  AddTimingPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('cleanTiming'),
          style: {
            backgroundColor: '#fff'
          },
          onPressRight3: function onPressRight3() {
            navigation.state["params"].confirmTiming();
          },
          showLine: true,
          onPressLeft2: function onPressLeft2() {
            navigation.goBack();
          }
        })
      )
    };
  };

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.init = function () {
      _this3.repeatDialogData = [];

      for (var i in repeatData) {
        _this3.repeatDialogData.push({
          title: repeatData[i]
        });
      }

      _this3.modeDialogData = [];

      for (var _i5 in modeData) {
        _this3.modeDialogData.push({
          title: modeData[_i5]
        });
      }
    };

    this.createId = function () {
      while (true) {
        var id = Math.floor(Math.random() * 100);

        if (id == 0) {
          continue;
        }

        var hasId = false;

        for (var i = 0; i < _this3.tasks.length; i++) {
          if (_this3.tasks[i].id == id) {
            hasId = true;
          }
        }

        if (!hasId) {
          return id;
        }
      }
    };

    this.calculateTasks = function (task) {
      if (!task) {
        return [];
      }

      var taskStrs = task.split(",");
      var taskDatas = [];

      for (var i = 0; i < taskStrs.length; i++) {
        var item = taskStrs[i];

        if (item.indexOf("-") > 0) {
          var datas = item.split("-");

          if (datas.length === 8) {
            var taskItem = {
              id: parseInt(datas[0]),
              enable: datas[1] == "1",
              ts: datas[2],
              time: datas[3],
              week: _this3.calculateWeek(datas[4]),
              loop: datas[5],
              mode: parseInt(datas[6]),
              area: parseInt(datas[7])
            };
            taskDatas.push(taskItem);
          }
        }
      }

      return taskDatas;
    };

    this.calculateWeek = function (week) {
      var weekTmp = "";
      var currentLen = week.length;

      for (var i = 0; i < 7 - currentLen; i++) {
        weekTmp = weekTmp + "0";
      }

      weekTmp = weekTmp + week;
      return weekTmp;
    };

    this.confirmTiming = function () {
      var loop = 1;

      if (repeatKey[_this3.state.repeat] === 0) {
        loop = 0;
      }

      var timing = _this3.id + "-1-" + Math.floor(Date.now() / 1000) + "-" + _this3.state.start[0] + ":" + _this3.state.start[1] + "-" + _this3.state.repeat + "-" + loop + "-" + _this3.state.modeSelect + "-0";

      _miot.Device.getDeviceWifi().callMethod("set_properties", [{
        "did": did,
        "siid": 18,
        "piid": 5,
        "value": timing
      }]).then(function (res) {
        console.log("----", res);

        _this3.props.navigation.goBack();
      }).catch(function (err) {
        _this3.showToast((0, _MHLocalizableString.getString)('networkTimeout'));
      });
    };

    this.showToast = function (msg) {
      if (_this3.refs.toast) {
        _this3.refs.toast.show(msg, 1200);
      }
    };

    this.startTime = function () {
      _this3.setState({
        pikerStartVisible: true
      });
    };

    this.setRepeat = function () {
      _this3.setState({
        repeatVisible: true
      });
    };

    this.selectmode = function () {
      _this3.setState({
        modeVisible: true
      });
    };

    this.repeatCheck = function (check) {
      _this3.setState({
        repeatVisible: false
      });
    };

    this.repeatCancle = function () {
      _this3.setState({
        repeatVisible: false
      });
    };

    this.handlePickedValue = function () {
      var data = _this3.currentSelect;

      _this3.setState({
        pikerStartVisible: false,
        start: [data[0], data[1]]
      });
    };

    this.hidePicker = function () {
      _this3.setState({
        pikerStartVisible: false
      });
    };

    this.getShowDate = function (data) {
      var hour = data[0];

      if (hour.length == 1) {
        hour = "0" + hour;
      }

      var minute = data[1];

      if (minute.length == 1) {
        minute = "0" + minute;
      }

      return hour + ":" + minute;
    };

    this.onSelect = function (res) {
      _this3.setState({
        start: [res.rawArray[0], res.rawArray[1]]
      });
    };
  };

  exports.default = AddTimingPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: 'rgba(255,255,255,1)',
      flex: 1.0
    },
    listItem: {
      height: 66,
      width: width,
      paddingLeft: 27,
      paddingRight: 27
    },
    line: {
      height: 1 / _reactNative.PixelRatio.get(),
      width: width - 20,
      marginLeft: 20,
      backgroundColor: 'rgba(0,0,0,0.1)'
    },
    root: {
      paddingTop: 100,
      flexDirection: 'row',
      justifyContent: 'center'
    },
    content: {
      padding: 100,
      height: 250,
      flexDirection: "row",
      justifyContent: 'center',
      alignItems: 'center'
    }
  });
},10427,[10297,10033,10121,10157,10430,10074,10373,10734,10343,10433],"projects/com.dreame.devices/main/AddTimingPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _reactNativeUiKitten = _require(_dependencyMap[2]);

    var AddTimingItemView = function (_React$Component) {
        babelHelpers.inherits(AddTimingItemView, _React$Component);

        function AddTimingItemView(props) {
            babelHelpers.classCallCheck(this, AddTimingItemView);

            var _this = babelHelpers.possibleConstructorReturn(this, (AddTimingItemView.__proto__ || Object.getPrototypeOf(AddTimingItemView)).call(this, props));

            _this.handleSetViewport = function (e) {
                var mainProps = {};
                var layout = e.nativeEvent.layout;
                mainProps.width = layout.width;
                mainProps.height = layout.height;

                if (_this.cover) {
                    _this.cover.setNativeProps({
                        style: mainProps
                    });
                }
            };

            _this.isPressed = false;
            _this.state = {
                switchState: _this.props.switchState
            };
            return _this;
        }

        babelHelpers.createClass(AddTimingItemView, [{
            key: "setSwitchState",
            value: function setSwitchState(state) {
                this.setState({
                    switchState: state
                });
            }
        }, {
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.isPressed = true;

                if (this.props.onPress && this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(0,0,0,0.05)',
                            backgroundColor: 'rgba(0,0,0,0.05)'
                        }
                    });
                }
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.isPressed = false;

                if (this.props.onPress && this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(255,255,255,0)',
                            backgroundColor: 'rgba(255,255,255,0)'
                        }
                    });
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: [styles.cardStyle, this.props.style],
                        onLayout: this.handleSetViewport,
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            flex: 1.0
                        },
                        _react2.default.createElement(
                            _reactNative.View,
                            {
                                flexDirection: "row"
                            },
                            _react2.default.createElement(
                                _reactNative.Text,
                                {
                                    style: {
                                        fontSize: 16.5,
                                        fontFamily: Const.fontFamily,
                                        color: 'rgba(0,0,0,0.95)'
                                    }
                                },
                                this.props.leftText
                            ),
                            this.props.showDot && _react2.default.createElement(_reactNative.Image, {
                                style: {
                                    width: 10,
                                    height: 10,
                                    marginLeft: 5,
                                    marginTop: -5,
                                    resizeMode: 'contain'
                                },
                                source: _require(_dependencyMap[3])
                            })
                        ),
                        this.props.desc && _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13,
                                    marginTop: 2,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.4)'
                                }
                            },
                            this.props.desc
                        )
                    ),
                    this.props.showSwitch && _react2.default.createElement(_reactNativeUiKitten.RkSwitch, {
                        style: {
                            borderRadius: 16,
                            backgroundColor: '#f0f0f0'
                        },
                        tintColor: "#e3e3e3",
                        onTintColor: "#5696ff",
                        value: this.state.switchState,
                        onValueChange: function onValueChange() {
                            _this2.setState({
                                switchState: !_this2.state.switchState
                            });

                            if (_this2.props.onValueChange) {
                                _this2.props.onValueChange(_this2.state.switchState);
                            }
                        }
                    }),
                    this.props.rightText && _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: {
                                fontSize: 15,
                                fontFamily: Const.fontFamily,
                                color: 'rgba(0,0,0,0.4)'
                            }
                        },
                        this.props.rightText
                    ),
                    _react2.default.createElement(_reactNative.Image, {
                        style: {
                            width: this.props.hideArrow === true ? 0 : 15,
                            height: this.props.hideArrow === true ? 0 : 15
                        },
                        resizeMode: "contain",
                        source: _require(_dependencyMap[4])
                    }),
                    !this.props.showSwitch && _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this.props.onPress,
                            onPressIn: this._buttonPressIn.bind(this),
                            onPressOut: this._buttonPressOut.bind(this)
                        },
                        _react2.default.createElement(_reactNative.View, {
                            style: [styles.coverStyle, this.isPressed ? {
                                backgroundColor: 'rgba(0,0,0,0.05)'
                            } : {
                                backgroundColor: 'rgba(255,255,255,0)'
                            }],
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        })
                    )
                );
            }
        }]);
        return AddTimingItemView;
    }(_react2.default.Component);

    AddTimingItemView.defaultProps = {
        onPress: null,
        switchState: false
    };
    exports.default = AddTimingItemView;

    var styles = _reactNative.StyleSheet.create({
        cardStyle: {
            flexDirection: "row"
        },
        coverStyle: {
            left: 0,
            top: 0,
            position: 'absolute',
            borderColor: 'transparent',
            borderWidth: _reactNative.StyleSheet.hairlineWidth
        }
    });
},10430,[10297,10033,11251,10154,10283],"projects/com.dreame.devices/main/widget/AddTimingItemView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 6,
    "height": 10,
    "scales": [2, 3],
    "hash": "b9d1806ae030b926c7875ca28e19fa69",
    "name": "select_icon",
    "type": "png"
  });
},10433,[10420],"projects/com.dreame.devices/resources/select_icon@2x.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _miot = _require(_dependencyMap[5]);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var repairUsersUrl = "https://cnbj2.fds.api.xiaomi.com/productinfo/afterSaleUsers.json";
  var otaUrl3 = "https://cnbj2.fds.api.xiaomi.com/productinfo/log/otalist1.json";

  var NetInfoPage = function (_React$Component) {
    babelHelpers.inherits(NetInfoPage, _React$Component);

    function NetInfoPage(props) {
      babelHelpers.classCallCheck(this, NetInfoPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (NetInfoPage.__proto__ || Object.getPrototypeOf(NetInfoPage)).call(this, props));

      _this.getMemoryUser = function () {
        _miot.Device.getDeviceWifi().callMethod("get_properties", [{
          "did": did,
          "siid": 99,
          "piid": 2
        }]).then(function (res) {
          if (res.code == 0 && res.result.length > 0 && res.result[0].code == 0) {
            var value = res.result[0].value;

            if (value.indexOf("-") > 0) {
              var datas = value.split("-");
              var used = Math.floor(parseInt(datas[0]) / 1024);
              var maxUsed = Math.floor(parseInt(datas[1]) / 1024);

              _this.setState({
                showMemory: used + "M/" + maxUsed + "M"
              });
            }
          } else {
            return Promise.reject({
              err: "onRefreshData err"
            });
          }
        }).catch(function (err) {});
      };

      _this.loadOtaList = function () {
        var url = otaUrl3 + "?" + Date.now();
        fetch(url).then(function (res) {
          return res.json();
        }).then(function (data) {
          if (data.code == 0 && data.data) {
            _this.setState({
              otalist: data.data,
              hasDebuglist: data.data.length > 0
            });
          }
        }).catch(function (e) {});
      };

      _this.loadRepairUsers = function () {
        fetch(repairUsersUrl).then(function (res) {
          return res.json();
        }).then(function (data) {
          if (Array.isArray(data.data) && data.data.indexOf(_miot.Service.account.ID) >= 0) {
            _this.setState({
              isRepairUser: true
            });
          }
        }).catch(function (e) {});
      };

      _this.onItemClick = function (index) {
        var item = _this.state.otalist[index];
        var url = item.url;
        var md5 = item.md5;

        _miot.Device.getDeviceWifi().callMethod("miIO.ota", {
          "app_url": url,
          "file_md5": md5,
          "proc": "dnld install",
          "mode": "normal",
          "install": "1"
        }).then(function (res) {
          _reactNative.Alert.alert(JSON.stringify(res));
        }).catch(function (err) {
          _reactNative.Alert.alert("err:" + JSON.stringify(err));
        });
      };

      _this.gotoCalibration = function () {
        _this.props.navigation.navigate("calibration");
      };

      _this.state = {
        hasDebug: false,
        version: "",
        otalist: [],
        hasDebug2: false,
        version2: ""
      };
      return _this;
    }

    babelHelpers.createClass(NetInfoPage, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.willBlurListener) {
          this.willBlurListener.remove();
        }

        if (this.didFocusListener) {
          this.didFocusListener.remove();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.loadOtaList();
        this.loadRepairUsers();
        this.getMemoryUser();
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return _react2.default.createElement(
          _reactNative.ScrollView,
          {
            style: styles.container
          },
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "WIFI名称",
            rightText: _miot.Device.SSID,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "RSSI",
            rightText: _miot.Device.RSSI,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "当前模式",
            rightText: _miot.Device.location == 1 ? "局域网模式" : "远程模式",
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "IP地址",
            rightText: _miot.Device.IP,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "MAC地址",
            rightText: _miot.Device.mac,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "\u8BBE\u5907id",
            rightText: did,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          !!this.state.showMemory ? _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "\u5F53\u524D\u5185\u5B58/\u6700\u9AD8\u5185\u5B58",
            rightText: this.state.showMemory
          }) : null,
          !!this.state.showMemory ? _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }) : null,
          this.state.isRepairUser ? _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "\u4F20\u611F\u5668\u6807\u5B9A",
            onPress: this.gotoCalibration
          }) : null,
          this.state.isRepairUser ? _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }) : null,
          this.state.otalist.map(function (item, index) {
            var w = (_this2.props.width - 70) / 4;
            return _react2.default.createElement(_SettingListItemView2.default, {
              key: 'dash' + index,
              style: styles.listItem,
              leftText: "OTA to ",
              rightText: item.version,
              onPress: function onPress() {
                _this2.onItemClick(index);
              },
              hideArrow: true
            });
          })
        );
      }
    }]);
    return NetInfoPage;
  }(_react2.default.Component);

  NetInfoPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: '网络信息',
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = NetInfoPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: '#fff'
    },
    listItem: {
      height: 50,
      marginLeft: 20,
      marginRight: 20,
      flex: 1.0
    },
    line: {
      height: 1,
      flex: 1.0,
      marginLeft: 20,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10436,[10297,10033,10121,10157,10340,10074],"projects/com.dreame.devices/main/NetInfoPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _TitleBarBlack = _require(_dependencyMap[2]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[3]);

    var _reactNativeUiKitten = _require(_dependencyMap[4]);

    var _TextButton = _require(_dependencyMap[5]);

    var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

    var _miot = _require(_dependencyMap[6]);

    var _id = _require(_dependencyMap[7]);

    var _id2 = babelHelpers.interopRequireDefault(_id);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var ListItem = function (_React$PureComponent) {
        babelHelpers.inherits(ListItem, _React$PureComponent);
        babelHelpers.createClass(ListItem, [{
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.isPressed = true;

                if (this.props.onPress && this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(0,0,0,0.05)',
                            backgroundColor: 'rgba(0,0,0,0.05)'
                        }
                    });
                }
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.isPressed = false;

                if (this.props.onPress && this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            borderColor: 'rgba(255,255,255,0)',
                            backgroundColor: 'rgba(255,255,255,0)'
                        }
                    });
                }
            }
        }]);

        function ListItem(props) {
            babelHelpers.classCallCheck(this, ListItem);

            var _this = babelHelpers.possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).call(this, props));

            _this._onPress = function () {
                _this.props.onPress();
            };

            _this.imageW = 115;
            _this.cellHeight = (Const.contentViewHeight - 2 / _reactNative.PixelRatio.get()) / 3;
            return _this;
        }

        babelHelpers.createClass(ListItem, [{
            key: "render",
            value: function render() {
                var _this2 = this;

                var remaining = this.props.remaining;
                var datas = remaining.split('-');
                var all = parseInt(datas[0]);
                var remain = parseInt(datas[1]);
                var percentage = "--";
                var color = "#5696ff";
                var remainHour = "--";

                if (all != 0) {
                    remainHour = Math.floor(remain / 60) + "";
                    var num = Math.floor(remain * 100 / all);

                    if (_miot.Host.locale.language === "tr") {
                        percentage = "%" + num;
                    } else {
                        percentage = num + "%";
                    }

                    if (num <= 0) {
                        color = "#ed1d24";
                    } else if (num <= 5) {
                        color = "#fbb900";
                    }
                }

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: {
                            flexDirection: "row",
                            height: this.cellHeight,
                            paddingLeft: 38,
                            paddingRight: 20
                        },
                        alignItems: "center"
                    },
                    _react2.default.createElement(_reactNative.Image, {
                        source: this.props.nomalImage,
                        style: {
                            width: this.imageW,
                            height: this.imageW
                        },
                        resizeMode: "contain"
                    }),
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            flex: 1.0,
                            marginLeft: 25,
                            alignContent: "flex-start"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 28,
                                    fontFamily: Const.fontFamily,
                                    color: color
                                }
                            },
                            percentage
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 20,
                                    marginTop: 5,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.9)'
                                }
                            },
                            this.props.type
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13,
                                    marginTop: 5,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.75)'
                                }
                            },
                            (0, _MHLocalizableString.getString)(this.props.desckey, {
                                time: remainHour
                            })
                        )
                    ),
                    _react2.default.createElement(_reactNative.Image, {
                        style: {
                            width: 15,
                            height: 15
                        },
                        resizeMode: "contain",
                        source: _require(_dependencyMap[8])
                    }),
                    _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this._onPress,
                            onPressIn: this._buttonPressIn.bind(this),
                            onPressOut: this._buttonPressOut.bind(this)
                        },
                        _react2.default.createElement(_reactNative.View, {
                            style: [{
                                left: 0,
                                top: 0,
                                position: 'absolute',
                                width: width,
                                height: this.cellHeight,
                                borderColor: 'transparent',
                                borderWidth: _reactNative.StyleSheet.hairlineWidth
                            }, this.isPressed ? {
                                backgroundColor: 'rgba(0,0,0,0.05)'
                            } : {
                                backgroundColor: 'rgba(0,0,0,0)'
                            }],
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        })
                    )
                );
            }
        }]);
        return ListItem;
    }(_react2.default.PureComponent);

    var MaterialPage = function (_React$Component) {
        babelHelpers.inherits(MaterialPage, _React$Component);

        function MaterialPage(props) {
            babelHelpers.classCallCheck(this, MaterialPage);

            var _this3 = babelHelpers.possibleConstructorReturn(this, (MaterialPage.__proto__ || Object.getPrototypeOf(MaterialPage)).call(this, props));

            _this3.handleSetViewport = function (e) {};

            _this3.gotoShop = function () {};

            _this3.gotoMaterialInfo = function (piid, name, type) {
                if (_this3.state[type] == "0-0") {
                    return;
                }

                _this3.props.navigation.navigate("materialInfo", {
                    piid: piid,
                    name: name,
                    value: _this3.state[type]
                });
            };

            _this3._buttonPressIn = function () {
                console.log("-------in");
            };

            _this3._buttonPressOut = function () {
                console.log("-------_buttonPressOut");
            };

            _this3.state = {
                heap: '0-0',
                slidBrush: '0-0',
                rollingBrush: '0-0'
            };

            _miot.Device.getDeviceWifi().callMethod("get_properties", [{
                "did": did,
                "siid": 19,
                "piid": 1
            }, {
                "did": did,
                "siid": 19,
                "piid": 2
            }, {
                "did": did,
                "siid": 19,
                "piid": 3
            }]).then(function (res) {
                if (res.code == 0) {
                    var updateState = {};

                    for (var i = 0; i < res.result.length; i++) {
                        var item = res.result[i];

                        if (item.code != 0) {
                            continue;
                        }

                        switch (item.siid) {
                            case 19:
                                if (item.piid == 1) {
                                    updateState.heap = item.value;
                                } else if (item.piid == 2) {
                                    updateState.slidBrush = item.value;
                                } else if (item.piid == 3) {
                                    updateState.rollingBrush = item.value;
                                }

                                break;

                            default:
                                break;
                        }
                    }

                    _this3.setState(updateState);
                }
            }).catch(function (err) {});

            return _this3;
        }

        babelHelpers.createClass(MaterialPage, [{
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.willBlurListener) {
                    this.willBlurListener.remove();
                }

                if (this.didFocusListener) {
                    this.didFocusListener.remove();
                }

                this.msgSubscription && this.msgSubscription.remove();
                this.propChangeListener && this.propChangeListener.remove();
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this4 = this;

                this.willBlurListener = this.props.navigation.addListener('willBlur', function () {});
                this.didFocusListener = this.props.navigation.addListener('willFocus', function () {});
                this.propChangeListener = _miot.DeviceEvent.deviceReceivedMessages.addListener(function (device, messages) {
                    var prop = null;
                    var updateState = {};

                    if (messages.has('prop.19.1')) {
                        prop = messages.get('prop.19.1');

                        if (prop.length > 0) {
                            updateState.heap = prop[0];
                        }
                    } else if (messages.has('prop.19.2')) {
                        prop = messages.get('prop.19.2');

                        if (prop.length > 0) {
                            updateState.slidBrush = prop[0];
                        }
                    } else if (messages.has('prop.19.3')) {
                        prop = messages.get('prop.19.3');

                        if (prop.length > 0) {
                            updateState.rollingBrush = prop[0];
                        }
                    }

                    _this4.setState(updateState);
                });

                _miot.Device.getDeviceWifi().subscribeMessages('prop.19.1', 'prop.19.2', 'prop.19.3').then(function (subcription) {
                    _this4.msgSubscription = subcription;
                    console.log('subscribe success');
                }).catch(function () {
                    return console.log('subscribe failed');
                });
            }
        }, {
            key: "render",
            value: function render() {
                var _this5 = this;

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container,
                        onLayout: this.handleSetViewport
                    },
                    _react2.default.createElement(ListItem, {
                        style: styles.listItem,
                        nomalImage: _require(_dependencyMap[9]),
                        type: (0, _MHLocalizableString.getString)('heap'),
                        desckey: "brushExpireDesc",
                        remaining: this.state.heap,
                        onPress: function onPress() {
                            _this5.gotoMaterialInfo(1, (0, _MHLocalizableString.getString)('heap'), "heap");
                        }
                    }),
                    _react2.default.createElement(_reactNative.View, {
                        style: styles.line
                    }),
                    _react2.default.createElement(ListItem, {
                        style: styles.listItem,
                        type: (0, _MHLocalizableString.getString)('slidBrush'),
                        desckey: "brushExpireDesc",
                        remaining: this.state.slidBrush,
                        nomalImage: _require(_dependencyMap[10]),
                        onPress: function onPress() {
                            _this5.gotoMaterialInfo(2, (0, _MHLocalizableString.getString)('slidBrush'), "slidBrush");
                        }
                    }),
                    _react2.default.createElement(_reactNative.View, {
                        style: styles.line
                    }),
                    _react2.default.createElement(ListItem, {
                        style: styles.listItem,
                        type: (0, _MHLocalizableString.getString)('rollingBrush'),
                        desckey: "brushExpireDesc",
                        remaining: this.state.rollingBrush,
                        nomalImage: _require(_dependencyMap[11]),
                        onPress: function onPress() {
                            _this5.gotoMaterialInfo(3, (0, _MHLocalizableString.getString)('rollingBrush'), "rollingBrush");
                        }
                    })
                );
            }
        }]);
        return MaterialPage;
    }(_react2.default.Component);

    MaterialPage.navigationOptions = function (_ref) {
        var navigation = _ref.navigation;
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: (0, _MHLocalizableString.getString)('materialTime'),
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: true,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    }
                })
            )
        };
    };

    exports.default = MaterialPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: '#fff',
            flex: 1.0
        },
        listItem: {
            height: 50,
            marginLeft: 20,
            marginRight: 20,
            flex: 1.0
        },
        line: {
            height: 1 / _reactNative.PixelRatio.get(),
            flex: 1.0,
            backgroundColor: 'rgba(0,0,0,0.1)'
        }
    });
},10439,[10297,10033,10121,10157,11251,10346,10074,10116,10283,10442,10445,10448],"projects/com.dreame.devices/main/MaterialPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 800,
      "height": 800,
      "scales": [1],
      "hash": "d78225810e1edaec0b73cb2be676df62",
      "name": "material_strainer",
      "type": "png"
   });
},10442,[10420],"projects/com.dreame.devices/resources/material_strainer.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 800,
      "height": 800,
      "scales": [1],
      "hash": "165a689d3be88656c3b63b88c5cf141b",
      "name": "material_side_brush",
      "type": "png"
   });
},10445,[10420],"projects/com.dreame.devices/resources/material_side_brush.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 800,
      "height": 800,
      "scales": [1],
      "hash": "4960aad27dc9dc33bcd2eae272d15482",
      "name": "material_rolling_brush",
      "type": "png"
   });
},10448,[10420],"projects/com.dreame.devices/resources/material_rolling_brush.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _TitleBarBlack = _require(_dependencyMap[2]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[3]);

    var _reactNativeUiKitten = _require(_dependencyMap[4]);

    var _miot = _require(_dependencyMap[5]);

    var _Toast = _require(_dependencyMap[6]);

    var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

    var _CopyMessageDialog = _require(_dependencyMap[7]);

    var _CopyMessageDialog2 = babelHelpers.interopRequireDefault(_CopyMessageDialog);

    var _TextButton = _require(_dependencyMap[8]);

    var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var MaterialInfoPage = function (_React$Component) {
        babelHelpers.inherits(MaterialInfoPage, _React$Component);

        function MaterialInfoPage(props) {
            babelHelpers.classCallCheck(this, MaterialInfoPage);

            var _this = babelHelpers.possibleConstructorReturn(this, (MaterialInfoPage.__proto__ || Object.getPrototypeOf(MaterialInfoPage)).call(this, props));

            _initialiseProps.call(_this);

            var params = _this.props.navigation.state.params;
            _this.piid = params.piid;
            var value = params.value;
            var name = params.name;
            var datas = value.split('-');
            var all = parseInt(datas[0]);
            var remain = parseInt(datas[1]);
            var percentage = "";
            var remainDay = "";
            var allHour = Math.floor(all / 60);
            var color = "#5696ff";

            if (all != 0) {
                remainDay = Math.floor(remain / 60) + "";
                var num = Math.floor(remain * 100 / all);
                percentage = num + "";

                if (num <= 0) {
                    color = "#ed1d24";
                } else if (num <= 5) {
                    color = "#fbb900";
                }
            }

            _this.imageRes = _require(_dependencyMap[9]);

            if (_this.piid == 1) {
                _this.imageRes = _require(_dependencyMap[9]);
                _this.tipTitle = (0, _MHLocalizableString.getString)('resetHeapTitle');
                _this.tipMessage = (0, _MHLocalizableString.getString)('resetHeapMessage');
            } else if (_this.piid == 2) {
                _this.tipTitle = (0, _MHLocalizableString.getString)('resetSlidBrushTitle');
                _this.tipMessage = (0, _MHLocalizableString.getString)('resetSlidBrushMessage');
                _this.imageRes = _require(_dependencyMap[10]);
            } else if (_this.piid == 3) {
                _this.tipTitle = (0, _MHLocalizableString.getString)('resetRollingBrushTitle');
                _this.tipMessage = (0, _MHLocalizableString.getString)('resetRollingBrushMessage');
                _this.imageRes = _require(_dependencyMap[11]);
            }

            _this.state = {
                all: allHour,
                remainDay: remainDay,
                percentage: percentage,
                name: name,
                color: color,
                tipDialogShow: false
            };
            return _this;
        }

        babelHelpers.createClass(MaterialInfoPage, [{
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.willBlurListener) {
                    this.willBlurListener.remove();
                }

                if (this.didFocusListener) {
                    this.didFocusListener.remove();
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                this.willBlurListener = this.props.navigation.addListener('willBlur', function () {});
                this.didFocusListener = this.props.navigation.addListener('willFocus', function () {});
            }
        }, {
            key: "renderRemain",
            value: function renderRemain(marginScale) {
                var _this2 = this;

                if (_miot.Host.locale.language == "ko") {
                    return _react2.default.createElement(
                        _reactNative.View,
                        {
                            flexDirection: "row",
                            width: width,
                            alignItems: "baseline",
                            marginTop: 35 * marginScale,
                            justifyContent: "center"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 44,
                                    color: this.state.color,
                                    fontFamily: "Kmedium"
                                },
                                onLayout: this.handleSetRemain
                            },
                            this.state.percentage
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: [styles.unit, {
                                    fontFamily: Const.fontFamily,
                                    color: this.state.color
                                }],
                                ref: function ref(c) {
                                    return _this2.unitView = c;
                                }
                            },
                            "%"
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 35,
                                    color: this.state.color,
                                    fontWeight: "500",
                                    marginLeft: 15,
                                    fontFamily: Const.fontFamily,
                                    paddingBottom: 4
                                }
                            },
                            (0, _MHLocalizableString.getString)('remain')
                        )
                    );
                }

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        flexDirection: "row",
                        width: width,
                        alignItems: "baseline",
                        marginTop: 35 * marginScale,
                        justifyContent: "center"
                    },
                    _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: {
                                fontSize: 35,
                                color: this.state.color,
                                fontWeight: "500",
                                fontFamily: Const.fontFamily,
                                marginRight: _miot.Host.locale.language === "tr" ? 10 : 0,
                                paddingBottom: 4
                            }
                        },
                        (0, _MHLocalizableString.getString)('remain')
                    ),
                    _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: {
                                fontSize: 44,
                                color: this.state.color,
                                fontFamily: "Kmedium"
                            },
                            onLayout: this.handleSetRemain
                        },
                        this.state.percentage
                    ),
                    _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: [styles.unit, {
                                fontFamily: Const.fontFamily,
                                color: this.state.color
                            }],
                            ref: function ref(c) {
                                return _this2.unitView = c;
                            }
                        },
                        "%"
                    )
                );
            }
        }, {
            key: "render",
            value: function render() {
                var _this3 = this;

                var marginScale = Const.contentViewHeight / 688.3636;
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                flex: 1.0
                            }
                        },
                        this.renderRemain(marginScale),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 15,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.8)',
                                    marginBottom: 10,
                                    width: width,
                                    textAlign: 'center'
                                }
                            },
                            (0, _MHLocalizableString.getString)('remainDay', {
                                hour: this.state.remainDay
                            })
                        ),
                        _react2.default.createElement(_reactNative.Image, {
                            source: this.imageRes,
                            style: {
                                width: width * marginScale,
                                height: 800 * width * marginScale / 1594,
                                marginLeft: (width - width * marginScale) / 2,
                                marginTop: 45 * marginScale
                            },
                            resizeMode: "contain"
                        }),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13,
                                    marginTop: Math.floor(20 * marginScale),
                                    marginLeft: 50,
                                    marginRight: 50,
                                    lineHeight: 15,
                                    flex: 1.0,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.6)'
                                }
                            },
                            this.marerialDesc()
                        )
                    ),
                    _react2.default.createElement(_TextButton2.default, {
                        style: {
                            width: width - 52,
                            height: 48,
                            marginLeft: 26,
                            marginBottom: 26,
                            borderColor: 'rgba(0,0,0,0.2)',
                            borderWidth: _reactNative.StyleSheet.hairlineWidth
                        },
                        normalColor: "rgba(0,0,0,0)",
                        pressColor: "#f2f2f2",
                        text: this.resetMarerialString(),
                        onPress: this.showTip,
                        textStyle: {
                            color: "rgba(0,0,0,0.7)",
                            fontFamily: Const.fontFamily,
                            fontSize: 13
                        }
                    }),
                    _react2.default.createElement(_Toast2.default, {
                        ref: "toast",
                        position: 'center',
                        height: Const.contentViewHeight
                    }),
                    _react2.default.createElement(_CopyMessageDialog2.default, {
                        visible: this.state.tipDialogShow,
                        title: this.tipTitle,
                        message: this.tipMessage,
                        buttons: [{
                            text: (0, _MHLocalizableString.getString)('cancle'),
                            callback: function callback(_) {
                                return _this3.dismissTip();
                            }
                        }, {
                            text: (0, _MHLocalizableString.getString)('sure'),
                            style: {
                                color: '#5696ff'
                            },
                            callback: function callback(_) {
                                _this3.dialogConfium();

                                _this3.dismissTip();
                            }
                        }],
                        onDismiss: this.dismissTip
                    })
                );
            }
        }]);
        return MaterialInfoPage;
    }(_react2.default.Component);

    MaterialInfoPage.navigationOptions = function (_ref) {
        var navigation = _ref.navigation;
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: navigation.state["params"].name,
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: false,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    }
                })
            )
        };
    };

    var _initialiseProps = function _initialiseProps() {
        var _this4 = this;

        this.gotoShop = function () {};

        this.resetMarerial = function () {
            var all = _this4.state.all * 60;
            var value = all + "-" + all;

            _miot.Device.getDeviceWifi().callMethod("set_properties", [{
                "did": did,
                "siid": 19,
                "piid": _this4.piid,
                "value": value
            }]).then(function (res) {
                var remainDay = _this4.state.all + "";

                _this4.setState({
                    remainDay: remainDay,
                    percentage: "100",
                    color: "#5696ff"
                });
            }).catch(function (err) {
                _this4.showToast((0, _MHLocalizableString.getString)('resetFail'));

                console.log('changeMode failed:', err);
            });
        };

        this.resetMarerialString = function () {
            return (0, _MHLocalizableString.getString)('materialReset', {
                name: _this4.state.name
            });
        };

        this.marerialDesc = function () {
            if (_this4.piid == 1) {
                return (0, _MHLocalizableString.getString)("heapDesc", {
                    time: _this4.state.all
                });
            } else if (_this4.piid == 2) {
                return (0, _MHLocalizableString.getString)("slidBrushDesc", {
                    time: _this4.state.all
                });
            } else if (_this4.piid == 3) {
                return (0, _MHLocalizableString.getString)("rollingBrushDesc", {
                    time: _this4.state.all
                });
            }

            return "";
        };

        this.handleSetRemain = function (e) {
            var mainProps = {};
            var layout = e.nativeEvent.layout;
            mainProps.top = layout.y + 10;

            if (_miot.Host.locale.language === "tr") {
                mainProps.left = layout.x - 10;
            } else {
                mainProps.left = layout.x + layout.width;
            }

            if (_this4.unitView) {
                _this4.unitView.setNativeProps({
                    style: mainProps
                });
            }
        };

        this.showToast = function (msg) {
            if (_this4.refs.toast) {
                _this4.refs.toast.show(msg, 1200);
            }
        };

        this.showTip = function () {
            _this4.setState({
                tipDialogShow: true
            });
        };

        this.dialogConfium = function () {
            _this4.resetMarerial();
        };

        this.dismissTip = function () {
            _this4.setState({
                tipDialogShow: false
            });
        };
    };

    exports.default = MaterialInfoPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: '#fff',
            flex: 1.0
        },
        listItem: {
            height: 50,
            marginLeft: 20,
            marginRight: 20,
            flex: 1.0
        },
        line: {
            height: 1,
            flex: 1.0,
            backgroundColor: 'rgba(0,0,0,0.1)'
        },
        unit: {
            right: 0,
            left: 0,
            top: 0,
            bottom: 0,
            fontSize: 14,
            position: 'absolute',
            backgroundColor: 'transparent'
        }
    });
},10451,[10297,10033,10121,10157,11251,10074,10343,10289,10346,10454,10457,10460],"projects/com.dreame.devices/main/MaterialInfoPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 1594,
    "height": 800,
    "scales": [1],
    "hash": "6b6269cf1e43899dbbea2c8554161bd5",
    "name": "material_strainer_big",
    "type": "png"
  });
},10454,[10420],"projects/com.dreame.devices/resources/material_strainer_big.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 1594,
      "height": 800,
      "scales": [1],
      "hash": "c1bafbbf4b6dba134c030e96243c10a1",
      "name": "material_side_brush_big",
      "type": "png"
   });
},10457,[10420],"projects/com.dreame.devices/resources/material_side_brush_big.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 1594,
    "height": 800,
    "scales": [1],
    "hash": "9fa79b13d2cffe97fe3f88383547e28b",
    "name": "material_rolling_brush_big",
    "type": "png"
  });
},10460,[10420],"projects/com.dreame.devices/resources/material_rolling_brush_big.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _TitleBarBlack = _require(_dependencyMap[2]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[3]);

    var _AreaEditMap = _require(_dependencyMap[4]);

    var _AreaEditMap2 = babelHelpers.interopRequireDefault(_AreaEditMap);

    var _ImageTextButton = _require(_dependencyMap[5]);

    var _ImageTextButton2 = babelHelpers.interopRequireDefault(_ImageTextButton);

    var _Toast = _require(_dependencyMap[6]);

    var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

    var _ui = _require(_dependencyMap[7]);

    var _rmcPicker = _require(_dependencyMap[8]);

    var _GridView = _require(_dependencyMap[9]);

    var _GridView2 = babelHelpers.interopRequireDefault(_GridView);

    var _miot = _require(_dependencyMap[10]);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var imgHeight = 50;

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width;

    var AreaEditPage = function (_React$Component) {
        babelHelpers.inherits(AreaEditPage, _React$Component);

        function AreaEditPage(props) {
            babelHelpers.classCallCheck(this, AreaEditPage);

            var _this = babelHelpers.possibleConstructorReturn(this, (AreaEditPage.__proto__ || Object.getPrototypeOf(AreaEditPage)).call(this, props));

            _this.handleSetViewport = function (evt) {
                var mainHeight = evt.nativeEvent.layout.height;

                if (_this.state.mainHeight != mainHeight) {
                    _miot.Host.storage.set("contentViewHeight", '' + mainHeight);

                    _this.setState({
                        mainHeight: mainHeight
                    });
                }
            };

            _this.merge = function () {
                if (_this.AreaCleanMap) {
                    _this.AreaCleanMap.merge();
                }
            };

            _this.showToast = function (msg) {
                _this.refs.toast.show(msg, 1200);
            };

            _this.split = function () {
                if (_this.AreaCleanMap) {
                    _this.AreaCleanMap.split();

                    _this.setState({
                        split: true
                    });
                }
            };

            _this.cancle = function () {
                if (_this.AreaCleanMap) {
                    _this.AreaCleanMap.setType(0);

                    _this.setState({
                        split: false
                    });
                }
            };

            _this.confium = function () {
                if (_this.AreaCleanMap) {
                    var points = _this.AreaCleanMap.getSplitPoints();

                    _this.AreaCleanMap.setType(0);

                    _this.setState({
                        split: false
                    });
                }
            };

            _this.rename = function () {
                if (_this.AreaCleanMap) {
                    _this.AreaCleanMap.rename();

                    _this.setState({
                        showRename: true
                    });
                }
            };

            _this.hideRename = function () {
                _this.setState({
                    showRename: false
                });
            };

            _this.handleRename = function () {};

            _this.renderRenameView = function () {
                var areaNames = [];
                areaNames = areaNames.concat((0, _MHLocalizableString.getString)('areaNames'));
                areaNames.push((0, _MHLocalizableString.getString)('defaultArea'));
                areaNames.push((0, _MHLocalizableString.getString)('addArea'));
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.renameDialog
                    },
                    _react2.default.createElement(_GridView2.default, {
                        style: {
                            width: width,
                            height: 250,
                            backgroundColor: "#fff"
                        },
                        array: areaNames,
                        width: width
                    })
                );
            };

            _this.state = {
                mainHeight: 0,
                bottomHeight: 100,
                showRename: false,
                split: false
            };

            if (Const.contentViewHeight) {
                _this.state.mainHeight = Const.contentViewHeight;
            }

            return _this;
        }

        babelHelpers.createClass(AreaEditPage, [{
            key: "render",
            value: function render() {
                var _this2 = this;

                console.log("------", this.state.mainHeight);
                var bottomW = width - 60;
                var buttonW = Math.floor(bottomW / 3);
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container,
                        onLayout: this.handleSetViewport
                    },
                    _react2.default.createElement(_rmcPicker.Popup, {
                        styles: _rmcPicker.PopupStyles,
                        style: styles.root,
                        okText: (0, _MHLocalizableString.getString)('confirm'),
                        dismissText: (0, _MHLocalizableString.getString)('cancle'),
                        visible: this.state.showRename,
                        onDismiss: this.hideRename,
                        onOk: this.handleRename,
                        content: this.renderRenameView()
                    }),
                    this.state.mainHeight > 0 ? _react2.default.createElement(_AreaEditMap2.default, {
                        ref: function ref(_ref) {
                            _this2.AreaCleanMap = _ref;
                        },
                        width: width,
                        showToast: this.showToast,
                        height: this.state.mainHeight - this.state.bottomHeight
                    }) : _react2.default.createElement(_reactNative.View, {
                        style: styles.map
                    }),
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: styles.bottom
                        },
                        !this.state.split ? _react2.default.createElement(
                            _reactNative.View,
                            {
                                style: styles.bottomChild,
                                flexDirection: "row",
                                width: bottomW,
                                paddingLeft: 30,
                                height: this.state.bottomHeight
                            },
                            _react2.default.createElement(_ImageTextButton2.default, {
                                onPress: this.merge,
                                style: {
                                    width: buttonW,
                                    height: 100
                                },
                                source: _require(_dependencyMap[11]),
                                text: (0, _MHLocalizableString.getString)('areaMerge')
                            }),
                            _react2.default.createElement(_ImageTextButton2.default, {
                                onPress: this.split,
                                style: {
                                    width: buttonW,
                                    height: 100
                                },
                                source: _require(_dependencyMap[12]),
                                text: (0, _MHLocalizableString.getString)('areaSplit')
                            }),
                            _react2.default.createElement(_ImageTextButton2.default, {
                                onPress: this.rename,
                                style: {
                                    width: buttonW,
                                    height: 100
                                },
                                source: _require(_dependencyMap[13]),
                                text: (0, _MHLocalizableString.getString)('areaRename')
                            })
                        ) : _react2.default.createElement(
                            _reactNative.View,
                            {
                                style: styles.bottomChild,
                                flexDirection: "row",
                                width: width,
                                height: this.state.bottomHeight,
                                paddingTop: this.state.bottomHeight - imgHeight
                            },
                            _react2.default.createElement(_ui.ImageButton, {
                                onPress: this.cancle,
                                style: styles.img,
                                source: _require(_dependencyMap[14]),
                                highlightedSource: _require(_dependencyMap[15])
                            }),
                            _react2.default.createElement(
                                _reactNative.Text,
                                {
                                    style: [styles.titleText, {
                                        fontFamily: Const.fontFamily
                                    }]
                                },
                                (0, _MHLocalizableString.getString)('areaSplit')
                            ),
                            _react2.default.createElement(_ui.ImageButton, {
                                onPress: this.confium,
                                style: styles.img,
                                source: _require(_dependencyMap[16]),
                                highlightedSource: _require(_dependencyMap[17])
                            })
                        )
                    ),
                    _react2.default.createElement(_Toast2.default, {
                        ref: "toast",
                        position: 'center',
                        height: Const.contentViewHeight
                    })
                );
            }
        }]);
        return AreaEditPage;
    }(_react2.default.Component);

    AreaEditPage.navigationOptions = function (_ref2) {
        var navigation = _ref2.navigation;
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: (0, _MHLocalizableString.getString)('areaEdit'),
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: true,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    }
                })
            )
        };
    };

    exports.default = AreaEditPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: 'rgba(255,255,255,1.0)',
            flex: 1.0
        },
        map: {
            backgroundColor: 'rgba(0,0,255,1.0)',
            flex: 1.0
        },
        bottom: {
            height: 100,
            width: width,
            backgroundColor: 'rgba(255,255,255,1.0)'
        },
        bottomChild: {
            left: 0,
            top: 0,
            position: 'absolute'
        },
        img: {
            width: imgHeight,
            height: imgHeight,
            resizeMode: 'contain',
            marginLeft: 5,
            marginRight: 5
        },
        titleText: {
            color: 'rgba(0,0,0,0.9)',
            fontSize: 15,
            textAlignVertical: 'center',
            textAlign: 'center',
            flex: 1.0
        },
        renameDialog: {
            height: 250,
            backgroundColor: '#FFFFFF',
            flexDirection: "row",
            justifyContent: 'center',
            alignItems: 'center'
        },
        root: {
            paddingTop: 100,
            flexDirection: 'row',
            justifyContent: 'center'
        }
    });
},10463,[10297,10033,10121,10157,10466,10478,10343,10230,10376,10481,10074,10484,10487,10490,10124,10127,10142,10145],"projects/com.dreame.devices/main/AreaEditPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _glReact = _require(_dependencyMap[2]);

  var _glReact2 = babelHelpers.interopRequireDefault(_glReact);

  var _glReactNative = _require(_dependencyMap[3]);

  var _AreaSelectView = _require(_dependencyMap[4]);

  var _AreaSelectView2 = babelHelpers.interopRequireDefault(_AreaSelectView);

  var _reactNativeSvg = _require(_dependencyMap[5]);

  var _reactNativeSvg2 = babelHelpers.interopRequireDefault(_reactNativeSvg);

  var _id = _require(_dependencyMap[6]);

  var _id2 = babelHelpers.interopRequireDefault(_id);

  var _MHLocalizableString = _require(_dependencyMap[7]);

  var shaders = _glReact2.default.Shaders.create({
    testGL: {
      frag: "\n    precision highp float;\n    varying vec2 uv;\n\n    uniform sampler2D bg;\n\n    uniform sampler2D map;\n\n    uniform sampler2D map1;\n\n    uniform int index;\n\n    uniform vec2 mapPos;\n    uniform vec2 offset;\n    uniform float widthGridNum;\n    uniform float zoom;\n    uniform vec2 mapSize;\n\n\n    uniform vec2 dim;\n\n    float plot(vec2 st, float pct){\n      return  smoothstep( pct-0.002, pct, st.y) -\n              smoothstep( pct, pct+0.002, st.y);\n    }\n    \n    void main () {\n      float bw = 1.0/30.0;\n      float bh = dim.x/dim.y * bw;\n\n      gl_FragColor = texture2D(bg, vec2(fract(uv.x/bw),fract(uv.y/bh)));\n\n      float pieceWidth_ = dim.x/widthGridNum;\n      float pieceWidth = dim.x/widthGridNum*zoom;\n      vec2 mapSize_ = mapSize*pieceWidth;\n      float _widthGridNum = widthGridNum/zoom;\n\n      float heightGridNum = dim.y * _widthGridNum /dim.x;\n      float cx = 1.0/widthGridNum*zoom;\n      float cy = dim.x * cx / dim.y;\n\n      vec2 startMap = (mapPos+offset) / dim;\n      vec2 endMap = (mapPos+offset+mapSize_) / dim;\n      if(uv.x<startMap.x||uv.x>endMap.x||uv.y<startMap.y||uv.y>endMap.y){\n        // gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n      }else{\n          float xnum = (uv.x-startMap.x) / cx;\n          float xmin = floor(xnum);\n      \n          float ynum = (uv.y-startMap.y) / cy;\n          float ymin = floor(ynum);\n          if(index == 0){\n            vec4 c = texture2D(map, vec2((xmin+0.5)/mapSize.x,(ymin+0.5)/mapSize.y));\n            gl_FragColor = vec4(mix(gl_FragColor.rgb,c.rgb,c.a),1.0);\n    \n          }else{\n            vec4 c = texture2D(map1, vec2((xmin+0.5)/mapSize.x,(ymin+0.5)/mapSize.y));\n            gl_FragColor = vec4(mix(gl_FragColor.rgb,c.rgb,c.a),1.0);\n          }\n          \n      }\n\n    }\n\n    "
    },
    mapGL: {
      frag: "\nprecision highp float;\nvarying vec2 uv;\n\n\nuniform vec2 dim;\nuniform sampler2D map;\nuniform vec2 mapSize;\nuniform vec2 offset;\nuniform vec2 robotPos;\nuniform vec2 mapPos;\n\nuniform sampler2D bg;\n\nuniform sampler2D robot;\nuniform sampler2D cleaning;\nuniform sampler2D dock;\n\nuniform float widthGridNum;\nuniform float zoom;\nuniform float robotAngle;\nuniform float animScale;\n\nuniform int charge;\nuniform vec2 chargePos;\nuniform float chargeAngel;\n\n\n\n\nvoid main () {\n    float pieceWidth_ = dim.x/widthGridNum;\n    float pieceWidth = dim.x/widthGridNum*zoom;\n    vec2 mapSize_ = mapSize*pieceWidth;\n    float _widthGridNum = widthGridNum/zoom;\n    float heightGridNum = dim.y * _widthGridNum /dim.x;\n    float cx = 1.0/widthGridNum*zoom;\n    float cy = dim.x * cx / dim.y;\n\n    vec2 startMap = (mapPos+offset) / dim;\n    vec2 endMap = (mapPos+offset+mapSize_) / dim;\n\n\n    float bw = 1.0/30.0;\n    float bh = dim.x/dim.y * bw;\n\n    \n    gl_FragColor = texture2D(bg, vec2(fract(uv.x/bw),fract(uv.y/bh)));\n    \n    if(uv.x<startMap.x||uv.x>endMap.x||uv.y<startMap.y||uv.y>endMap.y){\n        // gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n    }else{\n        float xnum = (uv.x-startMap.x) / cx;\n        float xmin = floor(xnum);\n    \n        float ynum = (uv.y-startMap.y) / cy;\n        float ymin = floor(ynum);\n        vec4 c = texture2D(map, vec2((xmin+0.5)/mapSize.x,(ymin+0.5)/mapSize.y));\n        \n        gl_FragColor = vec4(mix(gl_FragColor.rgb,c.rgb,c.a),1.0);\n\n    }\n\n    if(charge == 1){\n        vec2 _chargePos = chargePos*mapSize_+mapPos+offset;\n        vec2 cr = abs(uv*dim - _chargePos);\n        float robotR = 10.0*zoom;\n        if(cr.x<robotR && cr.y<robotR){\n          mat2 rotation = mat2(cos(chargeAngel), -sin(chargeAngel), sin(chargeAngel), cos(chargeAngel));\n          vec2 p = ((uv*dim-(_chargePos-robotR))/(robotR*2.0) - vec2(0.5)) * rotation + vec2(0.5);\n          vec4 rc = texture2D(dock,p); \n          gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n        }\n    }\n    \n    vec2 _robotPos = robotPos*mapSize_+mapPos+offset;\n\n    float r =  distance(uv*dim,_robotPos);\n\n    float robotR = 15.0*zoom;\n    \n    if(r<robotR){\n      mat2 rotation = mat2(cos(robotAngle), -sin(robotAngle), sin(robotAngle), cos(robotAngle));\n      vec2 p = ((uv*dim-(_robotPos-robotR))/(robotR*2.0) - vec2(0.5)) * rotation + vec2(0.5);\n      vec4 rc = texture2D(robot,p); \n      gl_FragColor = vec4(mix(gl_FragColor.rgb,rc.rgb,rc.a),1.0);\n    \n    }\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n\n}\n    "
    }
  });

  var base64ImageData = "iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAC0lEQVR4AWOgAgAAAEQAAZ+iuIQAAAAASUVORK5CYII=";
  var Action = {
    ACTION_NONE: 0,
    ACTION_DOWN: 1,
    ACTION_CLICK: 2,
    ACTION_MOVE: 3,
    ACTION_ZOOM: 4,
    ACTION_DOUBLE_CLICK: 5,
    ACTION_MOVE_SPLIT_POINT: 6,
    ACTION_MOVE_LINE: 7
  };
  var MapType = {
    TYPE_NONE: 0,
    TYPE_SPLIT: 1,
    TYPE_MERGE: 2
  };

  var AreaEditMap = function (_React$Component) {
    babelHelpers.inherits(AreaEditMap, _React$Component);

    function AreaEditMap(props) {
      babelHelpers.classCallCheck(this, AreaEditMap);

      var _this = babelHelpers.possibleConstructorReturn(this, (AreaEditMap.__proto__ || Object.getPrototypeOf(AreaEditMap)).call(this, props));

      _initialiseProps.call(_this);

      _this.initialize(props);

      return _this;
    }

    babelHelpers.createClass(AreaEditMap, [{
      key: "componentWillMount",
      value: function componentWillMount() {}
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.lastClickEvent) {
          clearTimeout(this.lastClickEvent);
          this.lastClickEvent = null;
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {}
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            width = _props.width,
            height = _props.height;
        var _state = this.state,
            dim = _state.dim,
            map = _state.map,
            map1 = _state.map1,
            index = _state.index,
            mapSize = _state.mapSize,
            offset = _state.offset,
            zoom = _state.zoom,
            robotPos = _state.robotPos,
            mapPos = _state.mapPos,
            robotAngle = _state.robotAngle,
            widthGridNum = _state.widthGridNum,
            charge = _state.charge,
            chargePos = _state.chargePos,
            showLine = _state.showLine,
            line = _state.line,
            chargeAngel = _state.chargeAngel;
        var bg = this.bg;
        var robot = this.robot;
        var cleaning = this.cleaning;
        var dock = this.dock;
        return _react2.default.createElement(
          _reactNative.View,
          this._panResponder.panHandlers,
          _react2.default.createElement(
            _glReactNative.Surface,
            {
              ref: "surface",
              style: {
                backgroundColor: "transparent"
              },
              autoRedraw: true,
              preload: true,
              onLoad: function onLoad() {
                if (_this2.state.index != _this2.mapState.index) {
                  _this2.updateState({
                    index: _this2.mapState.index
                  });
                }
              },
              width: width,
              height: height
            },
            _react2.default.createElement(_glReact2.default.Node, {
              shader: shaders.testGL,
              uniforms: {
                dim: dim,
                bg: bg,
                map: map,
                map1: map1,
                index: index,
                mapSize: mapSize,
                offset: offset,
                zoom: zoom,
                widthGridNum: widthGridNum,
                mapPos: mapPos
              }
            })
          ),
          _react2.default.createElement(
            _reactNativeSvg2.default,
            {
              key: "tracesvg",
              style: {
                position: 'absolute',
                width: width,
                height: height,
                top: 0,
                left: 0,
                backgroundColor: 'rgba(255,0,0,0)'
              }
            },
            _react2.default.createElement(_reactNativeSvg.Polyline, {
              key: "traces",
              ref: function ref(c) {
                _this2.polyline = c;
              },
              x: offset[0] - (1 - zoom) * (mapSize[0] * width / widthGridNum) / 2,
              y: -offset[1] + (1 - zoom) * (mapSize[1] * width / widthGridNum) / 2,
              originX: width / 2,
              originY: height / 2,
              points: this.getSplitLines(),
              fill: "none",
              stroke: "red",
              strokeDasharray: "10,5",
              strokeWidth: "2",
              scale: zoom
            }),
            _react2.default.createElement(_reactNativeSvg.Circle, {
              key: "start",
              x: offset[0] - (1 - zoom) * (mapSize[0] * width / widthGridNum) / 2,
              y: -offset[1] + (1 - zoom) * (mapSize[1] * width / widthGridNum) / 2,
              originX: width / 2,
              originY: height / 2,
              cx: this.state.line[0].x,
              cy: this.state.line[0].y,
              scale: zoom,
              r: this.getPointR(),
              stroke: "white",
              strokeWidth: "2",
              fill: "red"
            }),
            _react2.default.createElement(_reactNativeSvg.Circle, {
              key: "end",
              x: offset[0] - (1 - zoom) * (mapSize[0] * width / widthGridNum) / 2,
              y: -offset[1] + (1 - zoom) * (mapSize[1] * width / widthGridNum) / 2,
              originX: width / 2,
              originY: height / 2,
              cx: this.state.line[1].x,
              cy: this.state.line[1].y,
              scale: zoom,
              r: this.getPointR(),
              stroke: "white",
              strokeWidth: "2",
              fill: "red"
            }),
            _react2.default.createElement(
              _reactNativeSvg.Text,
              {
                fill: "rgba(0,0,0,0.5)",
                fontSize: "12",
                style: {
                  fontFamily: Const.fontFamily
                },
                x: this.props.width / 2,
                y: this.props.height - 20,
                textAnchor: "middle"
              },
              (0, _MHLocalizableString.getString)('areaEditTip1')
            ),
            Object.keys(this.areaInfo).map(function (area, index) {
              var areaInfo = _this2.areaInfo[area];

              var center = _this2.calculateCenterPos(areaInfo);

              return areaInfo.isSelected === true ? _react2.default.createElement(
                _reactNativeSvg.G,
                {
                  key: "share" + area,
                  x: center.centerX,
                  y: center.centerY
                },
                _react2.default.createElement(_AreaSelectView2.default, {
                  name: "\u6D4B\u8BD5",
                  selectColor: areaInfo.color
                })
              ) : null;
            })
          )
        );
      }
    }]);
    return AreaEditMap;
  }(_react2.default.Component);

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.initialize = function (props) {
      _this3.mapDataUtil = mapDataUtil;
      _this3.state = {
        dim: [props.width, props.height],
        map: {
          uri: "data:image/png;base64," + base64ImageData
        },
        map1: {
          uri: "data:image/png;base64," + base64ImageData
        },
        index: 0,
        mapSize: [4, 4],
        offset: [0, 0],
        mapPos: _this3.calculateMapPos(30, [4, 4]),
        robotPos: [0.0, 0.0],
        zoom: 1.0,
        robotAngle: -0.0 * 2 * Math.PI,
        animScale: 2.0,
        charge: 0,
        chargePos: [0, 0],
        chargeAngel: 0,
        showLine: 0,
        line: [{
          x: 0,
          y: 0
        }, {
          x: 0,
          y: 0
        }],
        widthGridNum: 30
      };
      _this3.areaInfo = {};
      _this3.action = Action.ACTION_NONE;
      _this3.type = MapType.TYPE_NONE;
      _this3.bg = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[8]));
      _this3.robot = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[9]));
      _this3.cleaning = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[10]));
      _this3.dock = _reactNative.Image.resolveAssetSource(_require(_dependencyMap[11]));
      _this3.mapState = {
        needChange: false,
        index: 0
      };
      _this3.t0 = Date.now();

      _this3.onMapChange(true);

      _this3._panResponder = _reactNative.PanResponder.create({
        onStartShouldSetPanResponder: function onStartShouldSetPanResponder(evt, gestureState) {
          _this3.action = Action.ACTION_DOWN;
          _this3.distance = -1;
          _this3.lastPos = null;

          if (_this3.type == MapType.TYPE_SPLIT) {
            var pos = _this3.convertTouchPos({
              x: evt.nativeEvent.locationX,
              y: evt.nativeEvent.locationY
            });

            var dis = _this3.calculateTwoPoint(pos, _this3.state.line[0]);

            if (dis < 10) {
              _this3.action = Action.ACTION_MOVE_SPLIT_POINT;
              _this3.fixPoint = _this3.state.line[1];
              _this3.movePoint = pos;
              _this3.moveLine = _this3.state.line;
              return true;
            }

            dis = _this3.calculateTwoPoint(pos, _this3.state.line[1]);

            if (dis < 10) {
              _this3.action = Action.ACTION_MOVE_SPLIT_POINT;
              _this3.fixPoint = _this3.state.line[0];
              _this3.movePoint = pos;
              _this3.moveLine = _this3.state.line;
              return true;
            }

            var p1 = _this3.state.line[0];
            var p2 = _this3.state.line[1];

            if ((pos.x - p1.x) * (pos.x - p2.x) <= 0 || (pos.y - p1.y) * (pos.y - p2.y) <= 0) {
              var a = p2.y - p1.y;
              var b = p1.x - p2.x;
              var c = p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y);
              var d = Math.abs((a * pos.x + b * pos.y + c) / Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)));

              if (d < 8) {
                _this3.action = Action.ACTION_MOVE_LINE;
                _this3.moveLine = _this3.state.line;
                return true;
              }
            }
          }

          return true;
        },
        onStartShouldSetPanResponderCapture: function onStartShouldSetPanResponderCapture(evt, gestureState) {
          _this3.action = Action.ACTION_DOWN;
          _this3.distance = -1;
          _this3.lastPos = null;
          return false;
        },
        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {
          return false;
        },
        onMoveShouldSetPanResponderCapture: function onMoveShouldSetPanResponderCapture(evt, gestureState) {
          if (_this3.action == Action.ACTION_MOVE_SPLIT_POINT || _this3.action == Action.ACTION_MOVE_LINE) {
            return true;
          }

          if (gestureState.numberActiveTouches == 2) {
            _this3.action = Action.ACTION_ZOOM;
            _this3.distance = _this3.calculateDistance(evt.nativeEvent.touches);
            return true;
          } else if (gestureState.numberActiveTouches == 1) {
            var delta = 15;

            if (Math.abs(gestureState.dy) > delta || Math.abs(gestureState.dx) > delta) {
              _this3.lastPos = {
                x: gestureState.moveX,
                y: gestureState.moveY
              };
              _this3.action = Action.ACTION_MOVE;
              return true;
            }
          }

          return false;
        },
        onPanResponderGrant: function onPanResponderGrant(evt, gestureState) {},
        onPanResponderMove: function onPanResponderMove(evt, gestureState) {
          if (_this3.action == Action.ACTION_MOVE_SPLIT_POINT) {
            _this3.movePoint = _this3.convertTouchPos({
              x: evt.nativeEvent.locationX,
              y: evt.nativeEvent.locationY
            });
            var line = [];

            if (_this3.movePoint.x > _this3.fixPoint.x) {
              line.push(_this3.fixPoint);
              line.push(_this3.movePoint);
            } else {
              line.push(_this3.movePoint);
              line.push(_this3.fixPoint);
            }

            _this3.updateState({
              line: line
            });

            return;
          } else if (_this3.action == Action.ACTION_MOVE_LINE) {
            var dx = gestureState.dx / _this3.state.zoom;
            var dy = gestureState.dy / _this3.state.zoom;
            var _line2 = [];
            var p1 = _this3.moveLine[0];
            var p2 = _this3.moveLine[1];

            _line2.push({
              x: p1.x + dx,
              y: p1.y + dy
            });

            _line2.push({
              x: p2.x + dx,
              y: p2.y + dy
            });

            _this3.updateState({
              line: _line2
            });

            return;
          }

          if (gestureState.numberActiveTouches == 2) {
            var currentDis = _this3.calculateDistance(evt.nativeEvent.touches);

            if (_this3.action == Action.ACTION_ZOOM) {
              var zoom = currentDis / _this3.distance * _this3.state.zoom;

              if (zoom > 2) {
                zoom = 2;
              }

              if (zoom < 0.5) {
                zoom = 0.5;
              }

              var x_ = (zoom - _this3.state.zoom) * (_this3.state.mapSize[0] * _this3.props.width / _this3.state.widthGridNum) / 2;
              var y_ = (zoom - _this3.state.zoom) * (_this3.state.mapSize[1] * _this3.props.width / _this3.state.widthGridNum) / 2;
              var newOffset = [_this3.state.offset[0] - x_, _this3.state.offset[1] - y_];
              newOffset = _this3.calculateOffset(zoom, newOffset);

              _this3.updateState({
                zoom: zoom,
                offset: newOffset
              });

              _this3.distance = currentDis;
            } else {
              _this3.action = Action.ACTION_ZOOM;
              _this3.distance = currentDis;
            }
          } else if (gestureState.numberActiveTouches == 1) {
            if (_this3.action == Action.ACTION_MOVE) {
              var currentPos = {
                x: gestureState.moveX,
                y: gestureState.moveY
              };
              var delay = {
                x: currentPos.x - _this3.lastPos.x,
                y: currentPos.y - _this3.lastPos.y
              };
              var _newOffset = [_this3.state.offset[0] + delay.x, _this3.state.offset[1] - delay.y];
              _newOffset = _this3.calculateOffset(_this3.state.zoom, _newOffset);

              _this3.updateState({
                offset: _newOffset
              });

              _this3.lastPos = currentPos;
            } else if (_this3.action == Action.ACTION_ZOOM) {
              _this3.lastPos = {
                x: gestureState.moveX,
                y: gestureState.moveY
              };
              _this3.action = Action.ACTION_MOVE;
            } else {
              var delta = 15;

              if (Math.abs(gestureState.dy) > delta || Math.abs(gestureState.dx) > delta) {
                _this3.lastPos = {
                  x: gestureState.moveX,
                  y: gestureState.moveY
                };
                _this3.action = Action.ACTION_MOVE;
              }
            }
          } else if (gestureState.numberActiveTouches > 2) {
            _this3.action = Action.ACTION_NONE;
          }
        },
        onPanResponderTerminationRequest: function onPanResponderTerminationRequest(evt, gestureState) {
          return true;
        },
        onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {
          if (_this3.action == Action.ACTION_DOWN) {
            var currentTime = Date.now();

            if (_this3.lastAction == Action.ACTION_CLICK && currentTime - _this3.lastClickTime < 200) {
              _this3.lastAction = Action.ACTION_DOUBLE_CLICK;

              if (_this3.lastClickEvent) {
                clearTimeout(_this3.lastClickEvent);
                _this3.lastClickEvent = null;
              }

              _this3.updateState({
                zoom: 1.0,
                offset: [0, 0]
              });
            } else {
              _this3.lastAction = Action.ACTION_CLICK;
              _this3.lastClickPos = {
                x: evt.nativeEvent.locationX,
                y: evt.nativeEvent.locationY
              };
              _this3.lastClickEvent = setTimeout(_this3.onClickMap, 250);
            }

            _this3.lastClickTime = currentTime;
          } else {
            if (_this3.action == Action.ACTION_MOVE_LINE || _this3.action == Action.ACTION_MOVE_SPLIT_POINT) {
              var area = null;

              for (var key in _this3.areaInfo) {
                if (_this3.areaInfo[key].isSelected == true) {
                  area = key;
                  break;
                }
              }

              var nLine = _this3.calculateBound(_this3.state.line, area);

              if (!nLine) {
                nLine = _this3.moveLine;
              }

              _this3.updateState({
                line: nLine
              });
            }

            _this3.lastAction = Action.ACTION_NONE;
          }
        },
        onPanResponderTerminate: function onPanResponderTerminate(evt, gestureState) {},
        onShouldBlockNativeResponder: function onShouldBlockNativeResponder(evt, gestureState) {
          return true;
        }
      });
    };

    this.setType = function (type) {
      _this3.type = type;

      if (_this3.type == MapType.TYPE_NONE) {
        for (var area in _this3.areaInfo) {
          _this3.areaInfo[area].isSelected = false;
        }

        _this3.state.showLine = false;

        _this3.onMapChange(false);
      }
    };

    this.calculateMapPos = function (widthGridNum, mapSize) {
      var pieceWidth_ = _this3.props.width / widthGridNum;
      var mapPos = {
        x: (widthGridNum - mapSize[0]) * pieceWidth_ / 2.0,
        y: (_this3.props.height * widthGridNum / _this3.props.width - mapSize[1]) * pieceWidth_ / 2.0
      };
      return [mapPos.x, mapPos.y];
    };

    this.convertTouchPos = function (touchPos) {
      var widthGridNum = _this3.state.widthGridNum;

      var _pieceWidth = _this3.state.dim[0] / _this3.state.widthGridNum;

      var pieceWidth = _pieceWidth * _this3.state.zoom;
      var mapSize = {
        w: _this3.state.mapSize[0] * pieceWidth,
        h: _this3.state.mapSize[1] * pieceWidth
      };

      var mapPosArr = _this3.calculateMapPos(widthGridNum, _this3.state.mapSize);

      var mapPos = {
        x: mapPosArr[0],
        y: mapPosArr[1]
      };
      var startMap = {
        x: _this3.state.offset[0] + mapPos.x,
        y: _this3.state.offset[1] + mapPos.y
      };
      var spotPos = [(touchPos.x - startMap.x) / mapSize.w * _pieceWidth * _this3.state.mapSize[0] + mapPos.x, _this3.props.height - ((_this3.props.height - touchPos.y - startMap.y) / mapSize.h * _pieceWidth * _this3.state.mapSize[1] + mapPos.y)];
      return {
        x: spotPos[0],
        y: spotPos[1]
      };
    };

    this.onClickMap = function () {
      var widthGridNum = _this3.state.widthGridNum;
      var pieceWidth = _this3.state.dim[0] / _this3.state.widthGridNum * _this3.state.zoom;
      var mapSize = {
        w: _this3.state.mapSize[0] * pieceWidth,
        h: _this3.state.mapSize[1] * pieceWidth
      };

      var mapPosArr = _this3.calculateMapPos(widthGridNum, _this3.state.mapSize);

      var mapPos = {
        x: mapPosArr[0],
        y: mapPosArr[1]
      };
      var startMap = {
        x: _this3.state.offset[0] + mapPos.x,
        y: _this3.state.offset[1] + mapPos.y
      };
      var endMap = {
        x: startMap.x + mapSize.w,
        y: startMap.y + mapSize.h
      };
      var touchPos = {
        x: _this3.lastClickPos.x,
        y: _this3.props.height - _this3.lastClickPos.y
      };

      if (touchPos.x > startMap.x && touchPos.x < endMap.x && touchPos.y > startMap.y && touchPos.y < endMap.y) {
        var spotPos = [(touchPos.x - startMap.x) / mapSize.w, (touchPos.y - startMap.y) / mapSize.h];
        var x = Math.floor(spotPos[0] * _this3.state.mapSize[0]);
        var y = Math.floor(spotPos[1] * _this3.state.mapSize[1]);

        var clickArea = _this3.mapDataUtil.getAreaSelect(x, y);

        if (clickArea > 0) {
          if (_this3.areaInfo[clickArea] && _this3.areaInfo[clickArea].isSelected === true) {
            _this3.areaInfo[clickArea].isSelected = false;
          } else {
            if (_this3.type == MapType.TYPE_SPLIT) {
              for (var area in _this3.areaInfo) {
                _this3.areaInfo[area].isSelected = false;
              }
            }

            _this3.areaInfo[clickArea].isSelected = true;
          }

          _this3.onMapChange(false);

          if (_this3.type == MapType.TYPE_SPLIT) {
            _this3.split();
          }
        }
      } else {}
    };

    this.convertPos = function (pos) {
      var widthGridNum = _this3.state.widthGridNum;
      var pieceWidth = _this3.state.dim[0] / _this3.state.widthGridNum;
      var mapSize = {
        w: _this3.state.mapSize[0] * pieceWidth,
        h: _this3.state.mapSize[1] * pieceWidth
      };

      var mapPosArr = _this3.calculateMapPos(widthGridNum, _this3.state.mapSize);

      var mapPos = {
        x: mapPosArr[0],
        y: mapPosArr[1]
      };
      var startMap = {
        x: mapPos.x,
        y: mapPos.y
      };
      var touchPos = {
        x: pos.x,
        y: _this3.props.height - pos.y
      };
      var spotPos = [(touchPos.x - startMap.x) / mapSize.w, (touchPos.y - startMap.y) / mapSize.h];
      var x = Math.floor(spotPos[0] * _this3.state.mapSize[0]);
      var y = Math.floor(spotPos[1] * _this3.state.mapSize[1]);
      return {
        x: x,
        y: y
      };
    };

    this.onMapChange = function (isInit) {
      var areaSelect = {};

      for (var area in _this3.areaInfo) {
        if (_this3.areaInfo[area].isSelected == true) {
          areaSelect[area] = true;
        }
      }

      var mapData = _this3.mapDataUtil.getCleanMap2(areaSelect);

      if (!mapData) {
        return;
      }

      var areaInfo = {};

      for (var _area in mapData.areaInfo) {
        areaInfo[_area] = mapData.areaInfo[_area];

        if (_this3.areaInfo[_area]) {
          areaInfo[_area].isSelected = _this3.areaInfo[_area].isSelected;
        }
      }

      _this3.areaInfo = areaInfo;
      var wnum = mapData.width + 2;

      if (mapData.width / mapData.height < _this3.props.width / (_this3.props.height - _this3.cleanInfoHeight - _this3.openDrawerOffset)) {
        wnum = Math.ceil(_this3.props.width / (_this3.props.height - _this3.cleanInfoHeight - _this3.openDrawerOffset) * mapData.height) + 2;
      }

      if (wnum < 40) {
        wnum = 40;
      }

      _this3.mapInfo = {
        info: mapData.mapInfo,
        gridWidth: mapData.gridWidth,
        w: _this3.props.width / wnum * mapData.width,
        h: _this3.props.width / wnum * mapData.height
      };
      var rX = (mapData.robotPos.x - mapData.mapInfo.minX) / mapData.width / mapData.gridWidth;
      var rY = (mapData.robotPos.y - mapData.mapInfo.minY) / mapData.height / mapData.gridWidth;

      var mapPos = _this3.calculateMapPos(wnum, [mapData.width, mapData.height]);

      var traces = mapData.traces;
      var width = _this3.props.width;

      var calculateTracePos = function calculateTracePos(pos) {
        var x = (pos.x - mapData.mapInfo.minX) / 100 * (width / wnum) + mapPos[0];
        var y = _this3.props.height - (pos.y - mapData.mapInfo.minY) / 100 * (width / wnum) - mapPos[1];
        return {
          x: x,
          y: y
        };
      };

      var path = '';

      for (var i = 0; i < traces.length; i++) {
        var movePos = calculateTracePos(traces[i]);
        path = path + movePos.x + "," + movePos.y;

        if (i != traces.length - 1) {
          path = path + " ";
        }
      }

      if (traces.length > 1) {}

      var charge = 0;
      var chargePos = [0, 0];
      var cAngel = 0;

      if (mapData.chargePos && mapData.chargePos.x != 0x7fff) {
        charge = 1;
        var cX = (mapData.chargePos.x - mapData.mapInfo.minX) / mapData.width / mapData.gridWidth;
        var cY = (mapData.chargePos.y - mapData.mapInfo.minY) / mapData.height / mapData.gridWidth;
        chargePos = [cX, cY];
        cAngel = -mapData.chargePos.angle / 360 * 2 * Math.PI;
      }

      var map = {
        uri: "data:image/png;base64," + mapData.data
      };
      var update = {
        mapSize: [mapData.width, mapData.height],
        robotPos: [rX, rY],
        charge: charge,
        chargePos: chargePos,
        chargeAngel: cAngel,
        mapPos: mapPos,
        robotAngle: -mapData.robotPos.angle / 360 * 2 * Math.PI,
        widthGridNum: wnum
      };

      if (isInit) {
        update.map = map;
        _this3.state = babelHelpers.extends(_this3.state, update);
      } else {
        if (map.uri == _this3.state.map.uri) {
          update.index = 0;
          _this3.mapState.index = 0;
        } else if (map.uri == _this3.state.map1.uri) {
          update.index = 1;
          _this3.mapState.index = 1;
        } else {
          if (_this3.mapState.index == 0) {
            update.map1 = map;
            _this3.mapState.index = 1;
          } else {
            update.map = map;
            _this3.mapState.index = 0;
          }
        }

        _this3.updateState(update);
      }
    };

    this.updateState = function (updateState) {
      if (_this3.startAnim) {
        _this3.state = babelHelpers.extends(_this3.state, updateState);
      } else {
        _this3.setState(updateState);
      }
    };

    this.calculateOffset = function (zoom, newOffset) {
      if (newOffset[0] < -_this3.props.width) {
        newOffset[0] = -_this3.props.width;
      }

      if (newOffset[0] > _this3.props.width) {
        newOffset[0] = _this3.props.width;
      }

      if (newOffset[1] < -_this3.props.height) {
        newOffset[1] = -_this3.props.height;
      }

      if (newOffset[1] > _this3.props.height) {
        newOffset[1] = _this3.props.height;
      }

      return newOffset;
    };

    this.startAnimtion = function () {
      _this3.startAnim = true;
      requestAnimationFrame(_this3._rafLoop);
    };

    this.stopAnimation = function () {
      if (_this3.startAnim) {
        _this3.startAnim = false;
        cancelAnimationFrame(_this3._rafLoop);
      }
    };

    this.calculateDistance = function (touchs) {
      var pos1 = {
        x: touchs[0].locationX,
        y: touchs[0].locationY
      };
      var pos2 = {
        x: touchs[1].locationX,
        y: touchs[1].locationY
      };
      return _this3.calculateTwoPoint(pos1, pos2);
    };

    this.calculateTwoPoint = function (pos1, pos2) {
      return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
    };

    this.split = function () {
      _this3.type = MapType.TYPE_SPLIT;
      var selects = [];

      for (var key in _this3.areaInfo) {
        if (_this3.areaInfo[key].isSelected === true) {
          selects.push(key);
        }
      }

      if (selects.length != 1) {
        _this3.showToast('areaEditTip3');

        return;
      }

      var line = _this3.mapDataUtil.getAreaSplitLine(selects[0]);

      var p0 = line[0];
      var x1 = (p0.x - _this3.mapInfo.info.minX) / (_this3.mapInfo.info.maxX - _this3.mapInfo.info.minX) * _this3.mapInfo.w + _this3.state.mapPos[0];
      var y1 = _this3.props.height - ((p0.y - _this3.mapInfo.info.minY) / (_this3.mapInfo.info.maxY - _this3.mapInfo.info.minY) * _this3.mapInfo.h + _this3.state.mapPos[1]);
      var _line = [];

      _line.push({
        x: x1,
        y: y1
      });

      p0 = line[1];
      x1 = (p0.x - _this3.mapInfo.info.minX) / (_this3.mapInfo.info.maxX - _this3.mapInfo.info.minX) * _this3.mapInfo.w + _this3.state.mapPos[0];
      y1 = _this3.props.height - ((p0.y - _this3.mapInfo.info.minY) / (_this3.mapInfo.info.maxY - _this3.mapInfo.info.minY) * _this3.mapInfo.h + _this3.state.mapPos[1]);

      _line.push({
        x: x1,
        y: y1
      });

      var lineFind = _this3.calculateBound(_line, selects[0]);

      if (lineFind != null) {
        _line = lineFind;
      }

      _this3.setState({
        showLine: 1,
        line: _line
      });
    };

    this.calculateCenterPos = function (areaInfo) {
      var _cell = _this3.props.width / _this3.state.widthGridNum * _this3.state.zoom;

      var centerX = (areaInfo.x + areaInfo.w / 2) * _cell + _this3.state.offset[0] + _this3.state.mapPos[0];
      var centerY = _this3.props.height - ((areaInfo.y + areaInfo.h / 2) * _cell + _this3.state.offset[1] + _this3.state.mapPos[1]);
      return {
        centerX: centerX,
        centerY: centerY
      };
    };

    this.getCenterPoint = function (areaInfo, updateState) {
      if (!updateState) {
        updateState = _this3.state;
      }

      var _cell = _this3.props.width / updateState.widthGridNum;

      var bX = updateState.mapPos[0] + _cell * areaInfo.x;
      var bY = _this3.props.height - (updateState.mapPos[1] + _cell * (areaInfo.y + areaInfo.h));
      var areaBound = {
        left: bX,
        top: bY,
        right: bX + _cell * areaInfo.w,
        bottom: bY + _cell * areaInfo.h,
        centerX: bX + _cell * areaInfo.w / 2,
        centerY: bY + _cell * areaInfo.h / 2,
        color: areaInfo.color
      };
      return areaBound;
    };

    this.calculateBound = function (line, area) {
      var start = line[0];
      var end = line[1];

      if (start.x > end.x) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      var k = 0;

      if (end.x != start.x) {
        k = (end.y - start.y) / (end.x - start.x);
      }

      var areaInfo = _this3.mapDataUtil.getAreaInfo(area);

      if (areaInfo == null) {
        return;
      }

      var _cell = _this3.props.width / _this3.state.widthGridNum;

      var bX = _this3.state.mapPos[0] + _cell * areaInfo.x;
      var bY = _this3.props.height - (_this3.state.mapPos[1] + _cell * (areaInfo.y + areaInfo.h));
      var areaBound = {
        left: bX,
        top: bY,
        right: bX + _cell * areaInfo.w,
        bottom: bY + _cell * areaInfo.h
      };

      if (!_this3.judgeLine(line, areaBound)) {
        return null;
      }

      var _x = _this3.props.width / _this3.state.widthGridNum / 2;

      var lpos = _this3.convertPos(start);

      var areaValue = _this3.mapDataUtil.getAreaSelect(lpos.x, lpos.y);

      var findStart = null;

      if (areaValue == area) {
        findStart = start;
        var nx = start.x;
        var ny = start.y;

        while (true) {
          var x = nx;
          var y = ny;
          var needBreak = false;

          var npos = _this3.convertPos({
            x: x,
            y: y
          });

          if (Math.abs(k) <= 1 && end.x != start.x) {
            nx = x - _x;
            ny = start.y + k * (nx - start.x);

            if (nx < areaBound.left) {
              needBreak = true;
            }
          } else {
            if (start.y > end.y) {
              ny = y + _x;

              if (ny > areaBound.bottom) {
                needBreak = true;
              }
            } else {
              ny = y - _x;

              if (ny < areaBound.top) {
                needBreak = true;
              }
            }

            if (end.x != start.x) {
              nx = start.x + (ny - start.y) / k;
            }
          }

          if (npos.x != lpos.x || npos.y != lpos.y) {
            lpos = npos;
            areaValue = _this3.mapDataUtil.getAreaSelect(lpos.x, lpos.y);

            if (areaValue != area) {
              break;
            }

            findStart = {
              x: x,
              y: y
            };
          }

          if (needBreak) {
            break;
          }
        }
      } else {
        var _nx = start.x;
        var _ny = start.y;

        while (true) {
          var _x2 = _nx;
          var _y = _ny;
          var _needBreak = false;

          var _npos = _this3.convertPos({
            x: _x2,
            y: _y
          });

          if (_npos.x != lpos.x || _npos.y != lpos.y) {
            lpos = _npos;
            areaValue = _this3.mapDataUtil.getAreaSelect(lpos.x, lpos.y);
            console.log("------------startRight:", JSON.stringify(lpos), areaValue, _x2, _y);

            if (areaValue == area) {
              findStart = {
                x: _x2,
                y: _y
              };
              break;
            }
          }

          if (Math.abs(k) <= 1 && end.x != start.x) {
            _nx = _x2 + _x;
            _ny = start.y + k * (_nx - start.x);

            if (_nx > areaBound.right) {
              _needBreak = true;
            }
          } else {
            if (start.y > end.y) {
              _ny = _y - _x;

              if (_ny < areaBound.top) {
                _needBreak = true;
              }
            } else {
              _ny = _y + _x;

              if (_ny > areaBound.bottom) {
                _needBreak = true;
              }
            }

            if (end.x != start.x) {
              _nx = start.x + (_ny - start.y) / k;
            }
          }

          if (_needBreak) {
            break;
          }
        }
      }

      if (!findStart) {
        return null;
      }

      lpos = _this3.convertPos(end);
      areaValue = _this3.mapDataUtil.getAreaSelect(lpos.x, lpos.y);
      var findEnd = null;

      if (areaValue == area) {
        var _nx2 = end.x;
        var _ny2 = end.y;
        findEnd = end;

        while (true) {
          var _needBreak2 = false;
          var _x3 = _nx2;
          var _y2 = _ny2;

          var _npos2 = _this3.convertPos({
            x: _x3,
            y: _y2
          });

          if (_npos2.x != lpos.x || _npos2.y != lpos.y) {
            lpos = _npos2;
            areaValue = _this3.mapDataUtil.getAreaSelect(lpos.x, lpos.y);
            console.log("------------endRight:", JSON.stringify(lpos), areaValue, _x3, _y2);

            if (areaValue != area) {
              break;
            }

            findEnd = {
              x: _x3,
              y: _y2
            };
          }

          if (Math.abs(k) <= 1 && end.x != start.x) {
            _nx2 = _x3 + _x;
            _ny2 = start.y + k * (_nx2 - start.x);

            if (_nx2 > areaBound.right) {
              _needBreak2 = true;
            }
          } else {
            if (start.y > end.y) {
              _ny2 = _y2 - _x;

              if (_ny2 < areaBound.top) {
                _needBreak2 = true;
              }
            } else {
              _ny2 = _y2 + _x;

              if (_ny2 > areaBound.bottom) {
                _needBreak2 = true;
              }
            }

            if (end.x != start.x) {
              _nx2 = start.x + (_ny2 - start.y) / k;
            }
          }

          if (_needBreak2) {
            break;
          }
        }
      } else {
        var _nx3 = end.x;
        var _ny3 = end.y;

        while (true) {
          var _needBreak3 = false;
          var _x4 = _nx3;
          var _y3 = _ny3;

          var _npos3 = _this3.convertPos({
            x: _x4,
            y: _y3
          });

          if (_npos3.x != lpos.x || _npos3.y != lpos.y) {
            lpos = _npos3;
            areaValue = _this3.mapDataUtil.getAreaSelect(lpos.x, lpos.y);
            console.log("------------endLeft:", JSON.stringify(lpos), areaValue, _x4, _y3);

            if (areaValue == area) {
              findEnd = {
                x: _x4,
                y: _y3
              };
              break;
            }
          }

          if (Math.abs(k) <= 1 && end.x != start.x) {
            _nx3 = _x4 - _x;
            _ny3 = start.y + k * (_nx3 - start.x);

            if (_nx3 < areaBound.left) {
              _needBreak3 = true;
            }
          } else {
            if (start.y > end.y) {
              _ny3 = _y3 + _x;

              if (_ny3 > areaBound.bottom) {
                _needBreak3 = true;
              }
            } else {
              _ny3 = _y3 - _x;

              if (_ny3 < areaBound.top) {
                _needBreak3 = true;
              }
            }

            if (end.x != start.x) {
              _nx3 = start.x + (_ny3 - start.y) / k;
            }
          }

          if (_needBreak3) {
            break;
          }
        }
      }

      if (!findEnd) {
        return null;
      }

      return [findStart, findEnd];
    };

    this.judgeLine = function (line, rect) {
      for (var i = 0; i < line.length; i++) {
        var p = line[i];

        if (p.x >= rect.left && p.x <= rect.right && p.y >= rect.top && p.y <= rect.bottom) {
          return true;
        }
      }

      var judge = function judge(line1, line2) {
        var a = line1[0];
        var b = line1[1];
        var c = line2[0];
        var d = line2[1];
        var min = Math.min;
        var max = Math.max;

        if (!(min(a.x, b.x) <= max(c.x, d.x) && min(c.y, d.y) <= max(a.y, b.y) && min(c.x, d.x) <= max(a.x, b.x) && min(a.y, b.y) <= max(c.y, d.y))) {
          return false;
        }

        var u = void 0,
            v = void 0,
            w = void 0,
            z = void 0;
        u = (c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y);
        v = (d.x - a.x) * (b.y - a.y) - (b.x - a.x) * (d.y - a.y);
        w = (a.x - c.x) * (d.y - c.y) - (d.x - c.x) * (a.y - c.y);
        z = (b.x - c.x) * (d.y - c.y) - (d.x - c.x) * (b.y - c.y);
        return u * v <= 0.00000001 && w * z <= 0.00000001;
      };

      var line1 = [{
        x: rect.left,
        y: rect.bottom
      }, {
        x: rect.left,
        y: rect.top
      }];
      var line2 = [{
        x: rect.left,
        y: rect.bottom
      }, {
        x: rect.right,
        y: rect.bottom
      }];
      var line3 = [{
        x: rect.right,
        y: rect.top
      }, {
        x: rect.right,
        y: rect.bottom
      }];
      var line4 = [{
        x: rect.right,
        y: rect.top
      }, {
        x: rect.left,
        y: rect.top
      }];
      return judge(line, line1) || judge(line, line2) || judge(line, line3) || judge(line, line4);
    };

    this.getSplitPoints = function () {
      var line = _this3.state.line;

      if (line && line.length == 2) {
        var points = [];

        var _start = _this3.mapDataUtil.getMapDeviation();

        for (var i = 0; i < line.length; i++) {
          var p = _this3.convertPos(line[i]);

          points.push({
            x: _start.x + p.x,
            y: _start.y + p.y
          });
        }

        return points;
      }

      return null;
    };

    this.rename = function () {
      var selects = [];

      for (var key in _this3.areaInfo) {
        if (_this3.areaInfo[key].isSelected === true) {
          selects.push(key);
        }
      }

      if (selects.length == 0) {
        _this3.showToast((0, _MHLocalizableString.getString)('areaEditTip3'));

        return -1;
      }

      if (selects.length > 1) {
        _this3.showToast((0, _MHLocalizableString.getString)('areaEditTip4'));

        return -1;
      }

      return selects[0];
    };

    this.merge = function () {
      var selects = [];

      for (var key in _this3.areaInfo) {
        if (_this3.areaInfo[key].isSelected === true) {
          selects.push(key);
        }
      }

      if (selects.length != 2) {
        _this3.showToast((0, _MHLocalizableString.getString)('areaEditTip2'));

        return;
      }

      var check = _this3.mapDataUtil.checkAreasNear(selects);

      if (check) {} else {
        _this3.showToast((0, _MHLocalizableString.getString)('areaEditTip2'));
      }
    };

    this.showToast = function (msg) {
      if (_this3.props.showToast) {
        _this3.props.showToast(msg);
      }
    };

    this._rafLoop = function () {
      if (!_this3.startAnim) {
        return;
      }

      var current = Date.now();

      var _time = current - _this3.t0;

      var totleTime = 1000;

      if (_time > totleTime) {
        _this3.t0 = current;

        _this3.setState({
          animScale: 0.5
        });
      } else {
        _this3.setState({
          animScale: 2.0 - _time / totleTime * 1.5
        });
      }

      requestAnimationFrame(_this3._rafLoop);
    };

    this.getSplitLines = function () {
      if (_this3.state.showLine == 1) {
        var line = _this3.state.line;

        if (line.length < 2) {
          console.log("getSplitLines", line);
          return "0,0 0,0";
        }

        return line[0].x + "," + line[0].y + " " + line[1].x + "," + line[1].y;
      }

      return "0,0 0,0";
    };

    this.getPointR = function () {
      if (_this3.state.showLine == 1) {
        return 8;
      }

      return "0";
    };
  };

  module.exports = AreaEditMap;
},10466,[10297,10033,13489,13480,10469,11485,10116,10157,10181,10184,10190,10475],"projects/com.dreame.devices/main/DreameUtil/AreaEditMap.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _reactNativeSvg = _require(_dependencyMap[2]);

    var _reactNativeSvg2 = babelHelpers.interopRequireDefault(_reactNativeSvg);

    var AreaSelectView = function (_React$Component) {
        babelHelpers.inherits(AreaSelectView, _React$Component);

        function AreaSelectView(props) {
            babelHelpers.classCallCheck(this, AreaSelectView);

            var _this = babelHelpers.possibleConstructorReturn(this, (AreaSelectView.__proto__ || Object.getPrototypeOf(AreaSelectView)).call(this, props));

            _this.handleSetViewport = function (e) {
                var layout = e.nativeEvent.layout;
            };

            _this.state = {
                width: 0,
                height: 0
            };
            return _this;
        }

        babelHelpers.createClass(AreaSelectView, [{
            key: "render",
            value: function render() {
                var _this2 = this;

                var width = this.state.width;
                var centerX = (width + 20) / 2;
                var trianglePoints = centerX - 8 + ",16 " + (centerX + 8) + ",16 " + centerX + ",24";
                return _react2.default.createElement(
                    _reactNativeSvg.G,
                    {
                        x: -centerX,
                        y: -24
                    },
                    _react2.default.createElement(_reactNativeSvg.Circle, {
                        cx: "10",
                        cy: "10",
                        r: "10",
                        fill: "white"
                    }),
                    _react2.default.createElement(_reactNativeSvg.Polygon, {
                        ref: function ref(_ref) {
                            _this2.Triangle = _ref;
                        },
                        points: trianglePoints,
                        fill: "white"
                    }),
                    _react2.default.createElement(_reactNativeSvg.Circle, {
                        cx: "10",
                        cy: "10",
                        r: "8",
                        fill: this.props.selectColor
                    }),
                    _react2.default.createElement(_reactNativeSvg.Image, {
                        x: "2",
                        y: "2",
                        width: "16",
                        height: "16",
                        href: _require(_dependencyMap[3])
                    })
                );
            }
        }]);
        return AreaSelectView;
    }(_react2.default.Component);

    exports.default = AreaSelectView;
},10469,[10297,10033,11485,10472],"projects/com.dreame.devices/main/widget/AreaSelectView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 27,
      "height": 27,
      "scales": [1],
      "hash": "2a8a6f0812388ecb76b65f7447717dec",
      "name": "area_select",
      "type": "png"
   });
},10472,[10420],"projects/com.dreame.devices/resources/area_select.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 64,
      "height": 64,
      "scales": [1],
      "hash": "5a14c607821dc529d366aa28987fb81c",
      "name": "dock",
      "type": "png"
   });
},10475,[10420],"projects/com.dreame.devices/resources/dock.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var ImageTextButton = function (_React$Component) {
        babelHelpers.inherits(ImageTextButton, _React$Component);

        function ImageTextButton(props) {
            babelHelpers.classCallCheck(this, ImageTextButton);
            return babelHelpers.possibleConstructorReturn(this, (ImageTextButton.__proto__ || Object.getPrototypeOf(ImageTextButton)).call(this, props));
        }

        babelHelpers.createClass(ImageTextButton, [{
            key: "render",
            value: function render() {
                var imageW = 30;
                return _react2.default.createElement(
                    _reactNative.TouchableOpacity,
                    {
                        onPress: this.props.onPress
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: this.props.style,
                            justifyContent: "center",
                            alignItems: "center"
                        },
                        _react2.default.createElement(_reactNative.Image, {
                            source: this.props.source,
                            style: {
                                width: imageW,
                                height: imageW,
                                resizeMode: 'contain'
                            }
                        }),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13,
                                    marginTop: 5,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.6)'
                                }
                            },
                            this.props.text
                        )
                    )
                );
            }
        }]);
        return ImageTextButton;
    }(_react2.default.Component);

    exports.default = ImageTextButton;
},10478,[10297,10033],"projects/com.dreame.devices/main/widget/ImageTextButton.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var GridView = function (_React$Component) {
        babelHelpers.inherits(GridView, _React$Component);

        function GridView(props) {
            babelHelpers.classCallCheck(this, GridView);

            var _this = babelHelpers.possibleConstructorReturn(this, (GridView.__proto__ || Object.getPrototypeOf(GridView)).call(this, props));

            _this.onItemClick = function (index) {
                console.log("onitemclick", index);
            };

            _this.state = {
                selectTmp: -1
            };
            return _this;
        }

        babelHelpers.createClass(GridView, [{
            key: "render",
            value: function render() {
                var _this2 = this;

                var arr = this.props.array;
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: [styles.cardStyle, this.props.style],
                        onLayout: this.handleSetViewport,
                        alignItems: "center",
                        flexDirection: "row",
                        flex: 1.0
                    },
                    arr.map(function (item, index) {
                        var w = (_this2.props.width - 70) / 4;
                        return _react2.default.createElement(
                            _reactNative.TouchableOpacity,
                            {
                                key: 'dash' + index,
                                onPress: function onPress() {
                                    _this2.onItemClick(index);
                                },
                                style: [styles.dashItem, {
                                    top: Math.floor(index / 4) * 46 + 20,
                                    left: 20 + index % 4 * (w + 10),
                                    width: w
                                }]
                            },
                            _react2.default.createElement(
                                _reactNative.Text,
                                {
                                    style: [styles.text, {
                                        fontFamily: Const.fontFamily
                                    }]
                                },
                                " ",
                                item
                            )
                        );
                    })
                );
            }
        }]);
        return GridView;
    }(_react2.default.Component);

    exports.default = GridView;

    var styles = _reactNative.StyleSheet.create({
        cardStyle: {
            backgroundColor: '#ffffffff'
        },
        dashItem: {
            left: 0,
            top: 0,
            height: 36,
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            borderRadius: 5,
            borderColor: 'rgba(0,0,0,0.4)',
            position: 'absolute',
            justifyContent: 'center',
            alignItems: 'center'
        },
        text: {
            color: 'rgba(0,0,0,0.8)',
            fontSize: 13,
            textAlignVertical: 'center',
            textAlign: 'center'
        }
    });
},10481,[10297,10033],"projects/com.dreame.devices/main/widget/GridView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 52,
      "height": 49,
      "scales": [1],
      "hash": "d49c7830fd742d9184271145cb8d707a",
      "name": "area_merge",
      "type": "png"
   });
},10484,[10420],"projects/com.dreame.devices/resources/area_merge.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 56,
      "height": 56,
      "scales": [1],
      "hash": "858bc6c6c2f1607524531080836bdce8",
      "name": "area_split",
      "type": "png"
   });
},10487,[10420],"projects/com.dreame.devices/resources/area_split.png");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 52,
      "height": 52,
      "scales": [1],
      "hash": "bdabdb244d2152a128570e2ce346bf87",
      "name": "area_rename",
      "type": "png"
   });
},10490,[10420],"projects/com.dreame.devices/resources/area_rename.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _Toast = _require(_dependencyMap[4]);

  var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

  var _miot = _require(_dependencyMap[5]);

  var _LoadingDialog = _require(_dependencyMap[6]);

  var _LoadingDialog2 = babelHelpers.interopRequireDefault(_LoadingDialog);

  var _TextButton = _require(_dependencyMap[7]);

  var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

  var _ProcessView = _require(_dependencyMap[8]);

  var _ProcessView2 = babelHelpers.interopRequireDefault(_ProcessView);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var MyListItem = function (_React$Component) {
    babelHelpers.inherits(MyListItem, _React$Component);

    function MyListItem(props) {
      babelHelpers.classCallCheck(this, MyListItem);

      var _this = babelHelpers.possibleConstructorReturn(this, (MyListItem.__proto__ || Object.getPrototypeOf(MyListItem)).call(this, props));

      _this.onButtonPress = function () {
        if (_this.props.onButtonPress) {
          _this.props.onButtonPress(_this.props.itemData);
        }
      };

      _this.playVoice = function () {
        var itemData = _this.props.itemData;
        var filename = _this.filename;

        if (!filename) {
          return;
        }

        if (_this.download == 1) {
          return;
        } else if (_this.download == 0) {
          _this.download = 1;

          _miot.Host.file.downloadFile(itemData.listen + "?" + Date.now(), filename).then(function (res) {
            _this.download = 2;
            return _miot.Host.audio.startPlay(filename, {
              'updateAudioPlayerTimeInterval': 1,
              'audioPlayerUid': filename
            });
          }).then(function (res) {}).catch(function (err) {
            _this.download = 0;
          });
        } else {
          _miot.Host.audio.startPlay(filename, {
            'updateAudioPlayerTimeInterval': 1,
            'audioPlayerUid': filename
          }).then(function (res) {}).catch(function (err) {
            _this.download = 0;
          });
        }
      };

      _this.handleSetViewport = function (e) {
        var width = e.nativeEvent.layout.width;

        if (width > _this.props.btnMinWidth) {
          _this.props.onWidthChange(width);
        }
      };

      _this.renderButton = function () {
        var itemData = _this.props.itemData;
        var minWidth = _this.props.btnMinWidth;

        if (itemData.status == 'idel') {
          return _react2.default.createElement(_TextButton2.default, {
            style: {
              minWidth: minWidth,
              height: 27,
              borderColor: 'rgba(0,0,0,0.2)',
              borderWidth: _reactNative.StyleSheet.hairlineWidth
            },
            onLayout: _this.handleSetViewport,
            normalColor: "rgba(0,0,0,0)",
            pressColor: "#f2f2f2",
            text: (0, _MHLocalizableString.getString)('use'),
            onPress: _this.onButtonPress,
            textStyle: {
              color: "rgba(0,0,0,0.7)",
              paddingLeft: 5,
              paddingRight: 5,
              fontFamily: Const.fontFamily,
              fontSize: 11.56
            }
          });
        } else if (itemData.status == 'used') {
          return _react2.default.createElement(_TextButton2.default, {
            style: {
              minWidth: minWidth,
              height: 27
            },
            onLayout: _this.handleSetViewport,
            normalColor: "#5696ff",
            pressColor: "#3f85fb",
            text: (0, _MHLocalizableString.getString)('used'),
            textStyle: {
              color: "#FFFFFF",
              paddingLeft: 5,
              paddingRight: 5,
              includeFontPadding: false,
              fontFamily: Const.fontFamily,
              fontSize: 11.56
            }
          });
        } else if (itemData.status == 'downloading') {
          return _react2.default.createElement(_ProcessView2.default, {
            width: minWidth,
            height: 20,
            process: itemData.process
          });
        } else {
          return null;
        }
      };

      _this.initFileName();

      return _this;
    }

    babelHelpers.createClass(MyListItem, [{
      key: "initFileName",
      value: function initFileName() {
        var _this2 = this;

        var itemData = this.props.itemData;

        _miot.Host.crypto.encodeMD5(itemData.listen).then(function (filename) {
          _this2.filename = filename + ".mp3";
          _this2.download = 0;
        });
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        return this.props.itemData != nextProps.itemData || this.props.btnMinWidth != nextProps.btnMinWidth;
      }
    }, {
      key: "render",
      value: function render() {
        var itemData = this.props.itemData;
        var imageW = 50;
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: {
              flexDirection: "row",
              height: 85,
              paddingLeft: 15,
              paddingRight: 25
            },
            alignItems: "center"
          },
          _react2.default.createElement(
            _reactNative.View,
            {
              style: {
                width: imageW,
                height: imageW
              }
            },
            _react2.default.createElement(_reactNative.Image, {
              source: {
                uri: itemData.icon
              },
              style: {
                width: imageW,
                height: imageW
              },
              resizeMode: "contain"
            }),
            _react2.default.createElement(
              _reactNative.TouchableOpacity,
              {
                style: {
                  position: "absolute",
                  left: imageW / 2,
                  top: imageW / 2
                },
                onPress: this.playVoice
              },
              _react2.default.createElement(_reactNative.Image, {
                source: _require(_dependencyMap[9]),
                style: {
                  width: imageW / 2,
                  height: imageW / 2
                },
                resizeMode: "contain"
              })
            )
          ),
          _react2.default.createElement(
            _reactNative.View,
            {
              flex: 1.0,
              marginLeft: 10,
              justifyContent: "center"
            },
            _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  fontSize: 17,
                  fontFamily: Const.fontFamily,
                  color: 'rgba(0,0,0,1)'
                }
              },
              itemData.name
            ),
            !!itemData.desc ? _react2.default.createElement(
              _reactNative.Text,
              {
                style: {
                  fontSize: 15,
                  fontFamily: Const.fontFamily,
                  color: 'rgba(0,0,0,0.75)',
                  marginTop: 2
                }
              },
              itemData.desc
            ) : null
          ),
          this.renderButton(),
          _react2.default.createElement(_reactNative.View, {
            style: {
              left: 0,
              top: 85 - 2 / _reactNative.PixelRatio.get(),
              height: 1 / _reactNative.PixelRatio.get(),
              width: width,
              backgroundColor: 'rgba(0,0,0,0.1)',
              position: 'absolute'
            }
          })
        );
      }
    }]);
    return MyListItem;
  }(_react2.default.Component);

  var VoiceManagerPage = function (_React$Component2) {
    babelHelpers.inherits(VoiceManagerPage, _React$Component2);

    function VoiceManagerPage(props) {
      babelHelpers.classCallCheck(this, VoiceManagerPage);

      var _this3 = babelHelpers.possibleConstructorReturn(this, (VoiceManagerPage.__proto__ || Object.getPrototypeOf(VoiceManagerPage)).call(this, props));

      _this3.showToast = function (msg) {
        _this3.refs.toast.show(msg, 1200);
      };

      _this3.initVoice = function () {
        _miot.Device.getDeviceWifi().callMethod("get_properties", [{
          "did": did,
          "siid": 24,
          "piid": 3
        }]).then(function (res) {
          if (res.code == 0 && res.result.length == 1 && res.result[0].value) {
            _this3.usedVoice = res.result[0].value;
            return fetch(gData.voiceUrl);
          } else {
            return Promise.reject("get voice failed");
          }
        }).then(function (res) {
          return res.json();
        }).then(function (resData) {
          if (resData.code == 0) {
            var voices = [];

            for (var i = 0; i < resData.data.voices.length; i++) {
              var item = resData.data.voices[i];
              voices.push({
                listen: item.listen,
                icon: item.icon,
                download: item.download,
                id: item.id,
                status: _this3.usedVoice == item.id ? "used" : "idel",
                process: 0,
                md5sum: item.md5sum,
                size: item.size,
                name: item.name[_miot.Host.locale.language] ? item.name[_miot.Host.locale.language] : item.name["default"],
                desc: item.desc[_miot.Host.locale.language] ? item.desc[_miot.Host.locale.language] : item.desc["default"]
              });
            }

            _this3.setState({
              voices: voices,
              loadingVisible: false
            });
          }
        }).catch(function (err) {
          console.log('failed:', err);

          _this3.showToast((0, _MHLocalizableString.getString)('netErr'));

          _this3.setState({
            loadingVisible: false
          });
        });
      };

      _this3._keyExtractor = function (item, index) {
        return item.id;
      };

      _this3.onButtonPress = function (item) {
        if (_this3.using && _this3.using.status == "downloading") {
          return _this3.showToast((0, _MHLocalizableString.getString)('voiceTip'));
        }

        _miot.Device.getDeviceWifi().callMethod("action", {
          "did": did,
          "siid": 24,
          "aiid": 2,
          "in": [{
            "piid": 3,
            "value": item.id
          }, {
            "piid": 4,
            "value": item.download
          }, {
            "piid": 5,
            "value": item.md5sum
          }, {
            "piid": 6,
            "value": item.size
          }]
        }).then(function (res) {
          if (res.code == 0) {
            _this3.using = {
              id: item.id,
              status: "downloading",
              process: 0
            };
            var voices = [];

            for (var i = 0; i < _this3.state.voices.length; i++) {
              var _item = _this3.state.voices[i];
              var newItem = {
                listen: _item.listen,
                icon: _item.icon,
                download: _item.download,
                id: _item.id,
                status: _this3.usedVoice == _item.id ? "used" : "idel",
                process: 0,
                md5sum: _item.md5sum,
                size: _item.size,
                name: _item.name,
                desc: _item.desc
              };

              if (_this3.using.id == _item.id && _this3.using.status == 'downloading') {
                newItem.status = 'downloading';
                newItem.process = _this3.using.process;
              }

              voices.push(newItem);
            }

            _this3.setState({
              voices: voices
            });
          }
        }).catch(function (err) {
          console.log('startCharge failed:', err);
        });
      };

      _this3.onWidthChange = function (w) {
        if (w > _this3.state.btnMinWidth) {
          var nVoices = [];
          nVoices = nVoices.concat(_this3.state.voices);

          _this3.setState({
            btnMinWidth: Math.ceil(w),
            voices: nVoices
          });
        }
      };

      _this3._renderItem = function (_ref) {
        var item = _ref.item;
        return _react2.default.createElement(MyListItem, {
          id: item.id,
          btnMinWidth: _this3.state.btnMinWidth,
          onWidthChange: _this3.onWidthChange,
          onButtonPress: _this3.onButtonPress,
          itemData: item
        });
      };

      _this3.dismissLoad = function () {
        _this3.setState({
          loadingVisible: false
        });
      };

      _this3.height = height - 100;
      _this3.state = {
        height: height - 100,
        voices: [],
        currentVoice: "",
        btnMinWidth: 54,
        loadingVisible: true
      };

      _this3.initVoice();

      return _this3;
    }

    babelHelpers.createClass(VoiceManagerPage, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this4 = this;

        this.propChangeListener = _miot.DeviceEvent.deviceReceivedMessages.addListener(function (device, messages) {
          if (messages.has('event.24.1')) {
            var value = messages.get('event.24.1');
            console.log("value", JSON.stringify(value));
            var using = {};

            for (var i = 0; i < value.length; i++) {
              var item = value[i];

              if (item.piid == 3) {
                using.id = item.value;
              } else if (item.piid == 7) {
                using.status = item.value;
              } else if (item.piid == 8) {
                using.process = item.value;
              }
            }

            if (!_this4.using) {
              _this4.using = using;
            } else if (_this4.using.status == 'success') {
              return;
            }

            if (_this4.using.process > using.process) {
              return;
            }

            _this4.using = using;

            if (_this4.using.status == 'success') {
              _this4.usedVoice = _this4.using.id;
            }

            var voices = [];

            for (var _i = 0; _i < _this4.state.voices.length; _i++) {
              var _item2 = _this4.state.voices[_i];
              var newItem = {
                listen: _item2.listen,
                icon: _item2.icon,
                download: _item2.download,
                id: _item2.id,
                status: _this4.usedVoice == _item2.id ? "used" : "idel",
                process: 0,
                md5sum: _item2.md5sum,
                size: _item2.size,
                name: _item2.name,
                desc: _item2.desc
              };

              if (_this4.using.id == _item2.id && _this4.using.status == 'downloading') {
                newItem.status = 'downloading';
                newItem.process = _this4.using.process;
              }

              voices.push(newItem);
            }

            _this4.setState({
              voices: voices
            });

            if (_this4.using.status == 'fail') {
              _this4.showToast((0, _MHLocalizableString.getString)('voiceDownloadErr'));
            } else if (_this4.using.status == 'success') {
              _this4.using = undefined;
            }
          }
        });
        this.msgSubscription = null;

        _miot.Device.getDeviceWifi().subscribeMessages('event.24.1').then(function (subcription) {
          _this4.msgSubscription = subcription;
          console.log('voice subscribe success');
        }).catch(function () {
          return console.log('subscribe failed');
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.msgSubscription) {
          this.msgSubscription.remove();
        }

        if (this.propChangeListener) {
          this.propChangeListener.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        return _react2.default.createElement(
          _reactNative.View,
          {
            style: styles.container
          },
          _react2.default.createElement(_LoadingDialog2.default, {
            visible: this.state.loadingVisible,
            cancelable: false,
            timeout: Const.loadingTimeOut,
            onDismiss: this.dismissLoad,
            message: (0, _MHLocalizableString.getString)('loading')
          }),
          _react2.default.createElement(_reactNative.FlatList, {
            data: this.state.voices,
            keyExtractor: this._keyExtractor,
            renderItem: this._renderItem
          }),
          _react2.default.createElement(_Toast2.default, {
            ref: "toast",
            position: 'center',
            height: Const.contentViewHeight
          })
        );
      }
    }]);
    return VoiceManagerPage;
  }(_react2.default.Component);

  VoiceManagerPage.navigationOptions = function (_ref2) {
    var navigation = _ref2.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: (0, _MHLocalizableString.getString)('robotVoice'),
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = VoiceManagerPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: 'rgba(255,255,255,1)',
      flex: 1.0
    },
    cardStyle: {
      flexDirection: "row"
    },
    listItem: {
      height: 50,
      width: width - 40,
      marginLeft: 20
    },
    line: {
      height: 1,
      width: width,
      backgroundColor: 'rgba(0,0,0,0.1)'
    },
    textUse: {
      borderWidth: _reactNative.StyleSheet.hairlineWidth,
      borderRadius: 10,
      borderColor: 'rgba(0,0,0,0.3)',
      minWidth: 70,
      paddingTop: 8,
      paddingBottom: 8,
      textAlign: 'center',
      color: 'rgba(0,0,0,0.75)',
      fontSize: 14
    },
    textUsed: {
      borderWidth: _reactNative.StyleSheet.hairlineWidth,
      borderRadius: 10,
      borderColor: '#5696ff',
      width: 70,
      paddingTop: 8,
      paddingBottom: 8,
      textAlign: 'center',
      color: '#5696ff',
      fontSize: 14
    }
  });
},10493,[10297,10033,10121,10157,10343,10074,10740,10346,10496,10499],"projects/com.dreame.devices/main/VoiceManagerPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var ProcessView = function (_React$Component) {
        babelHelpers.inherits(ProcessView, _React$Component);

        function ProcessView(props) {
            babelHelpers.classCallCheck(this, ProcessView);

            var _this = babelHelpers.possibleConstructorReturn(this, (ProcessView.__proto__ || Object.getPrototypeOf(ProcessView)).call(this, props));

            _this.processHeight = 5;
            return _this;
        }

        babelHelpers.createClass(ProcessView, [{
            key: "render",
            value: function render() {
                var _this2 = this;

                var bgStyle = {
                    left: 2,
                    top: (this.props.height - this.processHeight) / 2,
                    height: this.processHeight,
                    width: this.props.width - 4
                };
                var coverStyle = {
                    left: 2,
                    top: (this.props.height - this.processHeight) / 2,
                    height: this.processHeight,
                    width: (this.props.width - 4) * this.props.process / 100
                };

                if (coverStyle.width < 8) {
                    coverStyle.width = 8;
                }

                console.log("-------------", this.props);
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: {
                            width: this.props.width,
                            height: this.props.height
                        }
                    },
                    _react2.default.createElement(_reactNative.View, {
                        style: [styles.processbg, bgStyle]
                    }),
                    _react2.default.createElement(_reactNative.View, {
                        style: [styles.processCover, coverStyle],
                        ref: function ref(c) {
                            return _this2.cover = c;
                        }
                    })
                );
            }
        }]);
        return ProcessView;
    }(_react2.default.Component);

    exports.default = ProcessView;

    var styles = _reactNative.StyleSheet.create({
        processbg: {
            position: 'absolute',
            borderColor: 'transparent',
            borderRadius: 2,
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            backgroundColor: '#F7F7F7'
        },
        processCover: {
            position: 'absolute',
            borderColor: 'transparent',
            borderRadius: 2,
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            backgroundColor: '#5696ff'
        }
    });
},10496,[10297,10033],"projects/com.dreame.devices/main/widget/ProcessView.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 48,
      "height": 48,
      "scales": [1],
      "hash": "892bc132bd5014ff9f393934f39bb481",
      "name": "video_play",
      "type": "png"
   });
},10499,[10420],"projects/com.dreame.devices/resources/video_play.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _TitleBarBlack = _require(_dependencyMap[2]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[3]);

    var _reactNativeUiKitten = _require(_dependencyMap[4]);

    var _miot = _require(_dependencyMap[5]);

    var _TextButton = _require(_dependencyMap[6]);

    var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var WarnInfoPage = function (_React$Component) {
        babelHelpers.inherits(WarnInfoPage, _React$Component);

        function WarnInfoPage(props) {
            babelHelpers.classCallCheck(this, WarnInfoPage);

            var _this = babelHelpers.possibleConstructorReturn(this, (WarnInfoPage.__proto__ || Object.getPrototypeOf(WarnInfoPage)).call(this, props));

            _this.clickSure = function () {
                _this.props.navigation.goBack();
            };

            var params = _this.props.navigation.state.params;
            _this.warnCode = params.warnCode;
            var detail = (0, _MHLocalizableString.getString)('warnInfo');
            _this.warnInfo = detail[7];

            if (detail[_this.warnCode]) {
                _this.warnInfo = detail[_this.warnCode];
            }

            if (_this.warnCode == 3 || _this.warnCode == 5) {
                _this.imageRes = _require(_dependencyMap[7]);
            } else if (_this.warnCode == 1) {
                _this.imageRes = _require(_dependencyMap[8]);
            } else if (_this.warnCode == 2 || _this.warnCode == 6) {
                _this.imageRes = _require(_dependencyMap[9]);
            } else if (_this.warnCode == 12) {
                _this.imageRes = _require(_dependencyMap[10]);
            } else if (_this.warnCode == 13) {
                _this.imageRes = _require(_dependencyMap[11]);
            } else if (_this.warnCode == 15 || _this.warnCode == 16) {
                _this.imageRes = _require(_dependencyMap[12]);
            } else if (_this.warnCode == 17 || _this.warnCode == 18) {
                _this.imageRes = _require(_dependencyMap[13]);
            } else if (_this.warnCode == 8) {
                _this.imageRes = _require(_dependencyMap[14]);
            } else if (_this.warnCode == 11 || _this.warnCode == 14) {
                _this.imageRes = _require(_dependencyMap[15]);
            } else if (_this.warnCode == 21) {
                _this.imageRes = _require(_dependencyMap[16]);
            } else if (_this.warnCode == 26) {
                _this.imageRes = _require(_dependencyMap[17]);
            } else if (_this.warnCode == 4) {
                _this.imageRes = _require(_dependencyMap[18]);
            } else if (_this.warnCode == 24) {
                _this.imageRes = _require(_dependencyMap[19]);
            } else if (_this.warnCode == 41) {
                _this.imageRes = _require(_dependencyMap[20]);
            } else {
                _this.imageRes = _require(_dependencyMap[21]);
            }

            return _this;
        }

        babelHelpers.createClass(WarnInfoPage, [{
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.willBlurListener) {
                    this.willBlurListener.remove();
                }

                if (this.didFocusListener) {
                    this.didFocusListener.remove();
                }
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                this.willBlurListener = this.props.navigation.addListener('willBlur', function () {});
                this.didFocusListener = this.props.navigation.addListener('didFocus', function () {});
            }
        }, {
            key: "render",
            value: function render() {
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                flex: 1.0
                            },
                            justifyContent: "center",
                            alignItems: "center"
                        },
                        _react2.default.createElement(_reactNative.Image, {
                            source: this.imageRes,
                            style: {
                                width: width * 2 / 3,
                                height: width * 2 / 3,
                                marginBottom: 30
                            },
                            resizeMode: "contain"
                        }),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 20,
                                    color: '#5696ff',
                                    fontFamily: Const.fontFamily
                                },
                                onLayout: this.handleSetRemain
                            },
                            this.warnInfo.title
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 13,
                                    marginTop: 10,
                                    paddingBottom: 50,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.6)'
                                }
                            },
                            this.warnInfo.warninfo
                        )
                    ),
                    _react2.default.createElement(_TextButton2.default, {
                        style: {
                            width: width - 52,
                            height: 48,
                            marginLeft: 6,
                            marginBottom: 26,
                            borderColor: 'rgba(0,0,0,0.2)',
                            borderWidth: _reactNative.StyleSheet.hairlineWidth
                        },
                        normalColor: "rgba(0,0,0,0)",
                        pressColor: "#f2f2f2",
                        text: (0, _MHLocalizableString.getString)('sure'),
                        onPress: this.clickSure,
                        textStyle: {
                            color: "rgba(0,0,0,0.7)",
                            fontFamily: Const.fontFamily,
                            fontSize: 13
                        }
                    })
                );
            }
        }]);
        return WarnInfoPage;
    }(_react2.default.Component);

    WarnInfoPage.navigationOptions = function (_ref) {
        var navigation = _ref.navigation;
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: (0, _MHLocalizableString.getString)('warnInfoTitle'),
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: false,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    }
                })
            )
        };
    };

    exports.default = WarnInfoPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: '#fff',
            paddingLeft: 20,
            paddingRight: 20,
            flex: 1.0
        },
        listItem: {
            height: 50,
            marginLeft: 20,
            marginRight: 20,
            flex: 1.0
        },
        line: {
            height: 1,
            flex: 1.0,
            backgroundColor: 'rgba(0,0,0,0.1)'
        },
        unit: {
            right: 0,
            left: 0,
            top: 0,
            bottom: 0,
            fontSize: 10,
            color: '#5696ff',
            position: 'absolute',
            backgroundColor: 'transparent'
        }
    });
},10502,[10297,10033,10121,10157,11251,10074,10346,10505,10508,10511,10514,10517,10520,10523,10526,10529,10532,10535,10538,10541,10544,10547],"projects/com.dreame.devices/main/WarnInfoPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "32a2e6f6cc192e5cb96ff29f43819e62",
    "name": "warn1",
    "type": "png"
  });
},10505,[10420],"projects/com.dreame.devices/resources/warn/warn1.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "5c9901a9d21b6cb240ab2e630877ed04",
    "name": "warn2",
    "type": "png"
  });
},10508,[10420],"projects/com.dreame.devices/resources/warn/warn2.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "f38811efab9ea605725b9246c5a71fbb",
    "name": "warn3",
    "type": "png"
  });
},10511,[10420],"projects/com.dreame.devices/resources/warn/warn3.png");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
		"width": 1080,
		"height": 1080,
		"scales": [1],
		"hash": "c798127417b8864c040ec0c1a32738f3",
		"name": "warn4",
		"type": "png"
	});
},10514,[10420],"projects/com.dreame.devices/resources/warn/warn4.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "1d9e3bd70e5423fe3256e2d66238e144",
    "name": "warn5",
    "type": "png"
  });
},10517,[10420],"projects/com.dreame.devices/resources/warn/warn5.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "7bb27b184fef10d66eb41ad3de7c8250",
    "name": "warn6",
    "type": "png"
  });
},10520,[10420],"projects/com.dreame.devices/resources/warn/warn6.png");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
		"width": 1080,
		"height": 1080,
		"scales": [1],
		"hash": "f24408c716eaf44ca470a45b6f86c3f1",
		"name": "warn7",
		"type": "png"
	});
},10523,[10420],"projects/com.dreame.devices/resources/warn/warn7.png");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
		"width": 1080,
		"height": 1080,
		"scales": [1],
		"hash": "fb295b2fcb623db854a6a27889b05659",
		"name": "warn8",
		"type": "png"
	});
},10526,[10420],"projects/com.dreame.devices/resources/warn/warn8.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "798d939ef6cff17fb516df3a02a40e4b",
    "name": "warn9",
    "type": "png"
  });
},10529,[10420],"projects/com.dreame.devices/resources/warn/warn9.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "725818a95171239c32ba80821e98fdeb",
    "name": "warn12",
    "type": "png"
  });
},10532,[10420],"projects/com.dreame.devices/resources/warn/warn12.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "91d020642fd670e91bbea9bd305d0f81",
    "name": "warn13",
    "type": "png"
  });
},10535,[10420],"projects/com.dreame.devices/resources/warn/warn13.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "499fba3d5d374e6d29a97ff8f18edc15",
    "name": "warn15",
    "type": "png"
  });
},10538,[10420],"projects/com.dreame.devices/resources/warn/warn15.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "5ab5b22240bed13fe7719109e0d7f45f",
    "name": "warn18",
    "type": "png"
  });
},10541,[10420],"projects/com.dreame.devices/resources/warn/warn18.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
    "width": 1080,
    "height": 1080,
    "scales": [1],
    "hash": "edd23f44309a7334c72f1b8d23edc14f",
    "name": "warn10",
    "type": "png"
  });
},10544,[10420],"projects/com.dreame.devices/resources/warn/warn10.png");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources/warn",
		"width": 1080,
		"height": 1080,
		"scales": [1],
		"hash": "0906ee9dcb3e1366aed7c75d0fc8a4df",
		"name": "warn19",
		"type": "png"
	});
},10547,[10420],"projects/com.dreame.devices/resources/warn/warn19.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _TitleBarBlack = _require(_dependencyMap[2]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[3]);

    var _Toast = _require(_dependencyMap[4]);

    var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

    var _RobotInfoView = _require(_dependencyMap[5]);

    var _RobotInfoView2 = babelHelpers.interopRequireDefault(_RobotInfoView);

    var _miot = _require(_dependencyMap[6]);

    var _LoadingDialog = _require(_dependencyMap[7]);

    var _LoadingDialog2 = babelHelpers.interopRequireDefault(_LoadingDialog);

    var _ListItem = _require(_dependencyMap[8]);

    var _ProcessView = _require(_dependencyMap[9]);

    var _ProcessView2 = babelHelpers.interopRequireDefault(_ProcessView);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var MyListItem = function (_React$PureComponent) {
        babelHelpers.inherits(MyListItem, _React$PureComponent);

        function MyListItem(props) {
            babelHelpers.classCallCheck(this, MyListItem);

            var _this = babelHelpers.possibleConstructorReturn(this, (MyListItem.__proto__ || Object.getPrototypeOf(MyListItem)).call(this, props));

            _this.onButtonPress = function () {
                if (_this.props.onButtonPress) {
                    _this.props.onButtonPress(_this.props.itemData);
                }
            };

            _this.createTitle = function () {
                var startTime = parseInt(_this.props.itemData.startTime) * 1000;
                var date = new Date(startTime);
                var month = date.getMonth() + 1;

                if (month < 10) {
                    month = "0" + month;
                }

                var day = date.getDate();

                if (day < 10) {
                    day = "0" + day;
                }

                var hour = date.getHours();

                if (hour < 10) {
                    hour = "0" + hour;
                }

                var minute = date.getMinutes();

                if (minute < 10) {
                    minute = "0" + minute;
                }

                return (0, _MHLocalizableString.getString)("logDate", {
                    month: month,
                    day: day,
                    hour: hour,
                    minute: minute
                });
            };

            _this.createDesc = function () {
                var cleanType = (0, _MHLocalizableString.getString)('autoClean');

                if (_this.props.itemData.workmode == 4) {
                    cleanType = (0, _MHLocalizableString.getString)('localClean');
                }

                return cleanType + "  " + _this.props.itemData.cleanArea + (0, _MHLocalizableString.getString)("areaUnit") + " | " + _this.props.itemData.cleanTime + (0, _MHLocalizableString.getString)("minute");
            };

            return _this;
        }

        babelHelpers.createClass(MyListItem, [{
            key: "_buttonPressIn",
            value: function _buttonPressIn() {
                this.isPressed = true;

                if (this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            backgroundColor: 'rgba(0,0,0,0.05)'
                        }
                    });
                }
            }
        }, {
            key: "_buttonPressOut",
            value: function _buttonPressOut() {
                this.isPressed = false;

                if (this.cover) {
                    this.cover.setNativeProps({
                        style: {
                            backgroundColor: 'rgba(0,0,0,0)'
                        }
                    });
                }
            }
        }, {
            key: "render",
            value: function render() {
                var _this2 = this;

                var itemData = this.props.itemData;
                console.log(itemData);
                var imageW = 50;
                var height = 60;
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: {
                            flexDirection: "row",
                            height: height,
                            paddingLeft: 24,
                            paddingRight: 24
                        },
                        alignItems: "center"
                    },
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            flex: 1.0,
                            justifyContent: "center"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 15.4,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,1)'
                                }
                            },
                            this.createTitle()
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    fontSize: 12.3,
                                    fontFamily: Const.fontFamily,
                                    color: 'rgba(0,0,0,0.6)',
                                    marginTop: 0
                                }
                            },
                            this.createDesc()
                        )
                    ),
                    _react2.default.createElement(_reactNative.Image, {
                        style: {
                            width: 14,
                            height: 14
                        },
                        resizeMode: "contain",
                        source: _require(_dependencyMap[10])
                    }),
                    _react2.default.createElement(_reactNative.View, {
                        style: {
                            left: 0,
                            top: height - 2 / _reactNative.PixelRatio.get(),
                            height: 1 / _reactNative.PixelRatio.get(),
                            width: width,
                            backgroundColor: 'rgba(0,0,0,0.1)',
                            position: 'absolute'
                        }
                    }),
                    _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: this.onButtonPress,
                            onPressIn: this._buttonPressIn.bind(this),
                            onPressOut: this._buttonPressOut.bind(this)
                        },
                        _react2.default.createElement(_reactNative.View, {
                            style: [{
                                left: 0,
                                top: 0,
                                height: height,
                                width: width,
                                position: 'absolute'
                            }, this.isPressed ? {
                                backgroundColor: 'rgba(0,0,0,0.05)'
                            } : {
                                backgroundColor: 'rgba(0,0,0,0)'
                            }],
                            ref: function ref(c) {
                                return _this2.cover = c;
                            }
                        })
                    )
                );
            }
        }]);
        return MyListItem;
    }(_react2.default.PureComponent);

    var CleanLogPage = function (_React$PureComponent2) {
        babelHelpers.inherits(CleanLogPage, _React$PureComponent2);

        function CleanLogPage(props) {
            babelHelpers.classCallCheck(this, CleanLogPage);

            var _this3 = babelHelpers.possibleConstructorReturn(this, (CleanLogPage.__proto__ || Object.getPrototypeOf(CleanLogPage)).call(this, props));

            _initialiseProps.call(_this3);

            _this3.height = height - 100;
            var logs = [];
            _this3.state = {
                height: height - 100,
                cleanTime: 0,
                cleanArea: 0,
                times: 0,
                logs: logs,
                descHeight: 0,
                loadingVisible: false
            };
            _this3.hasRequestSuccess = false;
            _this3.lastClick = 0;
            _this3.lastStaticsClick = 0;
            _this3.clickNum = 0;
            _this3.requestNum = 0;
            return _this3;
        }

        babelHelpers.createClass(CleanLogPage, [{
            key: "componentWillMount",
            value: function componentWillMount() {
                var _this4 = this;

                this.initLogs();
                this.startInterval();
                this.didFocusListener = this.props.navigation.addListener('didFocus', function () {
                    if (!_this4.hasRequestSuccess) {
                        _this4.setState({
                            loadingVisible: true
                        });
                    }
                });
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.didFocusListener) {
                    this.didFocusListener.remove();
                }

                this.clearInter();
            }
        }, {
            key: "render",
            value: function render() {
                var _this5 = this;

                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container
                    },
                    _react2.default.createElement(_LoadingDialog2.default, {
                        visible: this.state.loadingVisible,
                        cancelable: false,
                        timeout: Const.loadingTimeOut,
                        onDismiss: this.dismissLoad,
                        message: (0, _MHLocalizableString.getString)('loading')
                    }),
                    _react2.default.createElement(
                        _reactNative.TouchableWithoutFeedback,
                        {
                            onPress: function onPress() {
                                if (_this5.clickNum == 0 || Date.now() - _this5.lastStaticsClick > 60000) {
                                    _this5.clickNum = 1;
                                    _this5.lastStaticsClick = Date.now();
                                }

                                _this5.clickNum++;

                                if (_this5.clickNum >= 10) {
                                    gData.isDebug = true;

                                    _this5.props.navigation.navigate("netInfo");

                                    _this5.clickNum = 0;
                                }
                            }
                        },
                        _react2.default.createElement(
                            _reactNative.View,
                            {
                                style: {
                                    flexDirection: "row",
                                    width: width,
                                    height: 70,
                                    paddingLeft: 20,
                                    paddingRight: 20,
                                    backgroundColor: "#fff"
                                }
                            },
                            _react2.default.createElement(_RobotInfoView2.default, {
                                minDescHeight: this.state.descHeight,
                                onHeight: this.onRobotInfoDescHeight,
                                desc: (0, _MHLocalizableString.getString)('totalTime'),
                                value: this.state.cleanTime + "",
                                isTime: true,
                                unit: "'"
                            }),
                            _react2.default.createElement(_RobotInfoView2.default, {
                                minDescHeight: this.state.descHeight,
                                onHeight: this.onRobotInfoDescHeight,
                                desc: (0, _MHLocalizableString.getString)('totalArea'),
                                value: this.state.cleanArea + "",
                                unit: (0, _MHLocalizableString.getString)("areaUnit")
                            }),
                            _react2.default.createElement(_RobotInfoView2.default, {
                                minDescHeight: this.state.descHeight,
                                onHeight: this.onRobotInfoDescHeight,
                                desc: (0, _MHLocalizableString.getString)('totalTimes'),
                                value: this.state.times + "",
                                unit: " "
                            })
                        )
                    ),
                    _react2.default.createElement(_reactNative.View, {
                        style: {
                            height: 10,
                            width: width,
                            backgroundColor: '#f7f7f7'
                        }
                    }),
                    _react2.default.createElement(_reactNative.FlatList, {
                        data: this.state.logs,
                        keyExtractor: this._keyExtractor,
                        renderItem: this._renderItem,
                        ListEmptyComponent: this.hasRequestSuccess ? this._emptyComponent : null
                    }),
                    _react2.default.createElement(_Toast2.default, {
                        ref: "toast",
                        position: 'center',
                        height: Const.contentViewHeight
                    })
                );
            }
        }]);
        return CleanLogPage;
    }(_react2.default.PureComponent);

    CleanLogPage.navigationOptions = function (_ref) {
        var navigation = _ref.navigation;
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: (0, _MHLocalizableString.getString)('cleanLog'),
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: false,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    }
                })
            )
        };
    };

    var _initialiseProps = function _initialiseProps() {
        var _this6 = this;

        this.showToast = function (msg) {
            _this6.refs.toast.show(msg, 1200);
        };

        this.clearInter = function () {
            console.log("clearInter");

            if (_this6.interval) {
                clearInterval(_this6.interval);
                _this6.interval = null;
            }
        };

        this.startInterval = function () {
            _this6.clearInter();

            _this6.interval = setInterval(function () {
                if (_this6.isIniting) {
                    return;
                }

                if (_this6.hasRequestSuccess) {
                    return _this6.clearInter();
                }

                if (!_this6.state.loadingVisible) {
                    _this6.setState({
                        loadingVisible: true
                    });
                }

                _this6.initLogs();
            }, 3000);
        };

        this.initLogs = function () {
            _this6.requestNum++;
            _this6.isIniting = true;

            _miot.Device.getDeviceWifi().callMethod("get_properties", [{
                "did": did,
                "siid": 18,
                "piid": 13
            }, {
                "did": did,
                "siid": 18,
                "piid": 14
            }, {
                "did": did,
                "siid": 18,
                "piid": 15
            }, {
                "did": did,
                "siid": 18,
                "piid": 16
            }]).then(function (res) {
                var updateData = {
                    startUseTime: 0
                };

                for (var i = 0; i < res.result.length; i++) {
                    var item = res.result[i];

                    if (item.code == 0 && item.siid == 18) {
                        if (item.piid == 13) {
                            updateData.cleanTime = item.value;
                        } else if (item.piid == 14) {
                            updateData.times = item.value;
                        } else if (item.piid == 15) {
                            updateData.cleanArea = item.value;
                        } else if (item.piid == 16) {
                            updateData.startUseTime = item.value;
                        }
                    }
                }

                if (updateData.times == 0) {
                    updateData.startUseTime = Math.floor(Date.now());
                }

                var limit = 30;

                if (updateData.times < 20) {
                    limit = updateData.times + 10;
                }

                _this6.state.cleanTime = updateData.cleanTime;
                _this6.state.times = updateData.times;
                _this6.state.cleanArea = updateData.cleanArea;
                _this6.state.startUseTime = updateData.startUseTime;
                console.log(updateData);
                return _miot.Service.smarthome.getDeviceData({
                    did: did,
                    uid: _miot.Service.account.ID,
                    key: "18.1",
                    type: "event",
                    time_start: updateData.startUseTime,
                    time_end: Math.floor(Date.now()),
                    limit: limit
                });
            }).then(function (data) {
                var logs = [];

                for (var i = 0; i < data.length; i++) {
                    var item = data[i];
                    var logData = JSON.parse(item.value);
                    var log = {};

                    for (var j = 0; j < logData.length; j++) {
                        var lItem = logData[j];

                        if (lItem.piid == 1) {
                            log.workmode = lItem.value;
                        } else if (lItem.piid == 2) {
                            log.cleanTime = lItem.value;
                        } else if (lItem.piid == 3) {
                            log.cleanArea = lItem.value;
                        } else if (lItem.piid == 9) {} else if (lItem.piid == 11) {
                            log.logfile = lItem.value;
                        } else if (lItem.piid == 12) {
                            log.startTime = lItem.value;
                            log.id = lItem.value + "";
                        }
                    }

                    if (i != 0) {
                        var lastLog = logs[logs.length - 1];

                        if (lastLog.startTime == log.startTime) {
                            continue;
                        }
                    }

                    logs.push(log);

                    if (logs.length >= 20 || logs.length >= _this6.state.times) {
                        break;
                    }
                }

                _this6.hasRequestSuccess = true;
                _this6.isIniting = false;

                _this6.setState({
                    logs: logs,
                    loadingVisible: false
                });
            }).catch(function (err) {
                console.log(err);

                if (_this6.requestNum >= 5) {
                    _this6.showToast((0, _MHLocalizableString.getString)('netErr'));

                    _this6.setState({
                        loadingVisible: false
                    });

                    _this6.clearInter();
                } else {}

                _this6.isIniting = false;
            });
        };

        this.onRobotInfoDescHeight = function (h) {
            if (h > _this6.state.descHeight) {
                _this6.setState({
                    descHeight: h
                });
            }
        };

        this._keyExtractor = function (item, index) {
            return item.id;
        };

        this.onButtonPress = function (item) {
            if (Date.now() - _this6.lastClick > 500) {
                _this6.lastClick = Date.now();

                _this6.props.navigation.navigate("cleanLogInfo", item);
            }
        };

        this._renderItem = function (_ref2) {
            var item = _ref2.item;
            return _react2.default.createElement(MyListItem, {
                id: item.id,
                onButtonPress: _this6.onButtonPress,
                itemData: item
            });
        };

        this.dismissLoad = function () {
            _this6.setState({
                loadingVisible: false
            });
        };

        this._emptyComponent = function () {
            return _react2.default.createElement(
                _reactNative.View,
                {
                    width: width,
                    height: Const.contentViewHeight - 70,
                    alignItems: "center",
                    justifyContent: "center"
                },
                _react2.default.createElement(_reactNative.Image, {
                    resizeMode: "contain",
                    style: {
                        width: 30,
                        height: 30
                    },
                    source: _require(_dependencyMap[11])
                }),
                _react2.default.createElement(
                    _reactNative.Text,
                    {
                        style: {
                            fontSize: 16,
                            marginTop: 5,
                            fontFamily: Const.fontFamily,
                            color: 'rgba(0,0,0,0.4)'
                        }
                    },
                    (0, _MHLocalizableString.getString)('emptyLog')
                )
            );
        };
    };

    exports.default = CleanLogPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: 'rgba(255,255,255,1)',
            flex: 1.0
        },
        cardStyle: {
            flexDirection: "row"
        },
        listItem: {
            height: 50,
            width: width - 40,
            marginLeft: 20
        },
        line: {
            height: 1,
            width: width,
            backgroundColor: 'rgba(0,0,0,0.1)'
        },
        textUse: {
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            borderRadius: 10,
            borderColor: 'rgba(0,0,0,0.3)',
            width: 70,
            paddingTop: 8,
            paddingBottom: 8,
            textAlign: 'center',
            color: 'rgba(0,0,0,0.75)',
            fontSize: 14
        },
        textUsed: {
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            borderRadius: 10,
            borderColor: '#5696ff',
            width: 70,
            paddingTop: 8,
            paddingBottom: 8,
            textAlign: 'center',
            color: '#5696ff',
            fontSize: 14
        }
    });
},10550,[10297,10033,10121,10157,10343,10202,10074,10740,10338,10496,10283,10553],"projects/com.dreame.devices/main/CleanLogPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
   module.exports = _require(_dependencyMap[0]).registerAsset({
      "__packager_asset": true,
      "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
      "width": 70,
      "height": 91,
      "scales": [1],
      "hash": "b486b91e7a2814b8db3e13e04695b69d",
      "name": "empty_log",
      "type": "png"
   });
},10553,[10420],"projects/com.dreame.devices/resources/empty_log.png");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _reactNativeSvg = _require(_dependencyMap[2]);

    var _reactNativeSvg2 = babelHelpers.interopRequireDefault(_reactNativeSvg);

    var _TitleBarBlack = _require(_dependencyMap[3]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[4]);

    var _Toast = _require(_dependencyMap[5]);

    var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

    var _RobotInfoView = _require(_dependencyMap[6]);

    var _RobotInfoView2 = babelHelpers.interopRequireDefault(_RobotInfoView);

    var _miot = _require(_dependencyMap[7]);

    var _LoadingDialog = _require(_dependencyMap[8]);

    var _LoadingDialog2 = babelHelpers.interopRequireDefault(_LoadingDialog);

    var _ListItem = _require(_dependencyMap[9]);

    var _ProcessView = _require(_dependencyMap[10]);

    var _ProcessView2 = babelHelpers.interopRequireDefault(_ProcessView);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var Optimize = _require(_dependencyMap[11]);

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var CleanLogPage = function (_React$PureComponent) {
        babelHelpers.inherits(CleanLogPage, _React$PureComponent);

        function CleanLogPage(props) {
            babelHelpers.classCallCheck(this, CleanLogPage);

            var _this = babelHelpers.possibleConstructorReturn(this, (CleanLogPage.__proto__ || Object.getPrototypeOf(CleanLogPage)).call(this, props));

            _this.shareLog = function () {
                _miot.Host.file.screenShot("clean_log.png").then(function (res) {
                    _miot.Host.ui.openShareListBar(null, null, {
                        uri: res
                    }, null);
                }).catch(function (e) {});
            };

            _this.getMapData = function (objname) {
                if (_this.isLoading == true) {
                    return;
                }

                _this.isLoading = true;
                objname = objname.replace(/\//g, "/");

                _miot.Service.smarthome.getFileUrl({
                    obj_name: objname
                }).then(function (res) {
                    return fetch(res.url);
                }).then(function (res) {
                    return res.text();
                }).then(function (mapDataStr) {
                    return new Promise(function (resolve, reject) {
                        resolve(new Optimize(mapDataStr).getMap());
                    });
                }).then(function (mapdata) {
                    console.log("------optimize", mapdata);
                    _this.isLoading = false;

                    _this.setState({
                        mapdata: mapdata,
                        loadingVisible: false
                    });
                }).catch(function (err) {
                    console.log("-----", err);
                    _this.isLoading = false;

                    _this.setState({
                        loadingVisible: false
                    });
                });
            };

            _this.showToast = function (msg) {
                _this.refs.toast.show(msg, 1200);
            };

            _this.getMapPath = function () {
                if (!_this.state.mapdata) {
                    return {
                        border: "",
                        obstaclePaths: [],
                        chargePos: null
                    };
                }

                _this.mapdata = _this.state.mapdata;
                var mapWidth = width;
                var mapHeight = Const.contentViewHeight - 70;
                var wnum = _this.mapdata.width + 6;

                if (mapWidth / mapHeight > _this.mapdata.width / (_this.mapdata.height + 20)) {
                    console.log("------------------------", mapWidth, mapHeight, _this.mapdata.width, _this.mapdata.height);
                    wnum = Math.floor(mapWidth / mapHeight * (_this.mapdata.height + 20));
                    console.log(wnum);
                }

                if (wnum < 80) {
                    wnum = 80;
                }

                var cell = width / wnum;
                console.log(mapHeight / cell);
                var mapOffset = {
                    x: (width - _this.mapdata.width * cell) / 2,
                    y: (mapHeight - _this.mapdata.height * cell) / 2
                };

                var getRealPos = function getRealPos(point) {
                    var tPos = {
                        x: mapOffset.x + (point.x + 0.5) * cell,
                        y: mapHeight - (mapOffset.y + (point.y + 0.5) * cell)
                    };
                    return tPos.x + " " + tPos.y;
                };

                var d = "M" + getRealPos(_this.mapdata.points[0]);

                for (var i = 1; i < _this.mapdata.points.length; i++) {
                    d = d + " L" + getRealPos(_this.mapdata.points[i]);
                }

                var obstaclePaths = [];

                for (var _i = 0; _i < _this.mapdata.obstacles.length; _i++) {
                    var points = _this.mapdata.obstacles[_i];
                    var minx = points[0].x;
                    var maxx = points[0].x;
                    var miny = points[0].y;
                    var maxy = points[0].y;
                    var ob = "M" + getRealPos(points[0]);

                    for (var j = 1; j < points.length; j++) {
                        ob = ob + " L" + getRealPos(points[j]);
                        var p = points[j];

                        if (p.x < minx) {
                            minx = p.x;
                        }

                        if (p.y < miny) {
                            miny = p.y;
                        }

                        if (p.x > maxx) {
                            maxx = p.x;
                        }

                        if (p.y > maxy) {
                            maxy = p.y;
                        }
                    }

                    obstaclePaths.push({
                        d: ob,
                        isBorder: maxx - minx >= 60 || maxy - miny >= 60
                    });
                }

                var chargePos = null;

                if (_this.mapdata.chargerPos && _this.mapdata.chargerPos.x != 0x7fff) {
                    chargePos = {};
                    var angel = _this.mapdata.chargerPos.angle;
                    chargePos.x = mapOffset.x + _this.mapdata.chargerPos.x * cell;
                    chargePos.y = mapHeight - (mapOffset.y + _this.mapdata.chargerPos.y * cell);
                    chargePos.angle = 0 - angel + 'deg';
                    console.log(_this.mapdata.chargerPos, chargePos);
                }

                return {
                    border: d,
                    obstaclePaths: obstaclePaths,
                    chargePos: chargePos
                };
            };

            _this.dismissLoad = function () {
                _this.setState({
                    loadingVisible: false
                });
            };

            _this.height = height - 100;
            _this.cleanInfo = props.navigation.state.params;
            _this.state = {
                loadingVisible: false,
                cleanArea: _this.cleanInfo.cleanArea,
                cleanTime: _this.cleanInfo.cleanTime
            };

            _this.props.navigation.setParams({
                share: _this.shareLog
            });

            return _this;
        }

        babelHelpers.createClass(CleanLogPage, [{
            key: "componentWillMount",
            value: function componentWillMount() {
                var _this2 = this;

                this.getMapData(this.cleanInfo.logfile);
                this.didFocusListener = this.props.navigation.addListener('willFocus', function () {
                    if (_this2.isLoading) {
                        _this2.setState({
                            loadingVisible: true
                        });
                    }
                });
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.didFocusListener) {
                    this.didFocusListener.remove();
                }
            }
        }, {
            key: "render",
            value: function render() {
                var mapPath = this.getMapPath();
                console.log(mapPath.chargePos);
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container
                    },
                    _react2.default.createElement(_LoadingDialog2.default, {
                        visible: this.state.loadingVisible,
                        cancelable: false,
                        timeout: Const.loadingTimeOut,
                        onDismiss: this.dismissLoad,
                        message: (0, _MHLocalizableString.getString)('loading')
                    }),
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                flexDirection: "row",
                                width: width,
                                height: 70,
                                paddingLeft: 20,
                                paddingRight: 20,
                                backgroundColor: "#fff"
                            }
                        },
                        _react2.default.createElement(_RobotInfoView2.default, {
                            desc: (0, _MHLocalizableString.getString)('cleaned'),
                            value: this.state.cleanArea,
                            unit: (0, _MHLocalizableString.getString)("areaUnit")
                        }),
                        _react2.default.createElement(_RobotInfoView2.default, {
                            desc: (0, _MHLocalizableString.getString)('cleantime'),
                            value: this.state.cleanTime,
                            isTime: true,
                            unit: "'"
                        })
                    ),
                    _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                width: width,
                                height: Const.contentViewHeight - 70
                            }
                        },
                        _react2.default.createElement(_reactNative.Image, {
                            position: "absolute",
                            style: {
                                width: width,
                                height: Const.contentViewHeight - 70
                            },
                            source: _require(_dependencyMap[12]),
                            resizeMode: "cover"
                        }),
                        _react2.default.createElement(
                            _reactNativeSvg2.default,
                            {
                                key: "tracesvg",
                                position: "absolute",
                                style: {
                                    width: width,
                                    height: Const.contentViewHeight - 70
                                }
                            },
                            this.state.mapdata && _react2.default.createElement(_reactNativeSvg.Path, {
                                d: mapPath.border,
                                fill: "rgba(131, 178, 255, 255)",
                                stroke: "rgba(110, 110, 110, 255)"
                            }),
                            mapPath.obstaclePaths.map(function (item, index) {
                                return _react2.default.createElement(_reactNativeSvg.Path, {
                                    key: 'dash' + index,
                                    d: item.d,
                                    fill: item.isBorder ? "rgba(230, 234, 238, 1)" : "#bed4f5",
                                    stroke: item.isBorder ? "rgba(110, 110, 110, 255)" : "#bed4f5"
                                });
                            })
                        ),
                        mapPath.chargePos && _react2.default.createElement(_reactNative.Image, {
                            position: "absolute",
                            style: {
                                width: 36,
                                height: 36,
                                top: mapPath.chargePos.y - 18,
                                left: mapPath.chargePos.x - 18,
                                transform: [{
                                    rotate: mapPath.chargePos.angle
                                }]
                            },
                            source: _require(_dependencyMap[13]),
                            resizeMode: "cover"
                        })
                    ),
                    _react2.default.createElement(_Toast2.default, {
                        ref: "toast",
                        position: 'center',
                        height: Const.contentViewHeight
                    })
                );
            }
        }]);
        return CleanLogPage;
    }(_react2.default.PureComponent);

    CleanLogPage.navigationOptions = function (_ref) {
        var navigation = _ref.navigation;
        var cleanInfo = navigation.state.params;
        var startTime = parseInt(cleanInfo.startTime) * 1000;
        var date = new Date(startTime);
        var month = date.getMonth() + 1;

        if (month < 10) {
            month = "0" + month;
        }

        var day = date.getDate();

        if (day < 10) {
            day = "0" + day;
        }

        var hour = date.getHours();

        if (hour < 10) {
            hour = "0" + hour;
        }

        var minute = date.getMinutes();

        if (minute < 10) {
            minute = "0" + minute;
        }

        var title = (0, _MHLocalizableString.getString)("logDate", {
            month: month,
            day: day,
            hour: hour,
            minute: minute
        });
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: title,
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: false,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    },
                    onPressRight2: function onPressRight2() {
                        if (navigation.state.params && navigation.state.params.share) {
                            navigation.state.params.share();
                        }
                    }
                })
            )
        };
    };

    exports.default = CleanLogPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: 'rgba(255,255,255,1)',
            flex: 1.0
        },
        cardStyle: {
            flexDirection: "row"
        },
        listItem: {
            height: 50,
            width: width - 40,
            marginLeft: 20
        },
        line: {
            height: 1,
            width: width,
            backgroundColor: 'rgba(0,0,0,0.1)'
        },
        textUse: {
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            borderRadius: 10,
            borderColor: 'rgba(0,0,0,0.3)',
            width: 70,
            paddingTop: 8,
            paddingBottom: 8,
            textAlign: 'center',
            color: 'rgba(0,0,0,0.75)',
            fontSize: 14
        },
        textUsed: {
            borderWidth: _reactNative.StyleSheet.hairlineWidth,
            borderRadius: 10,
            borderColor: '#5696ff',
            width: 70,
            paddingTop: 8,
            paddingBottom: 8,
            textAlign: 'center',
            color: '#5696ff',
            fontSize: 14
        }
    });
},10556,[10297,10033,11485,10121,10157,10343,10202,10074,10740,10338,10496,10559,10562,10193],"projects/com.dreame.devices/main/CleanLogInfo.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    var _pako = _require(_dependencyMap[0]);

    var _pako2 = babelHelpers.interopRequireDefault(_pako);

    var _base64Js = _require(_dependencyMap[1]);

    var _base64Js2 = babelHelpers.interopRequireDefault(_base64Js);

    var _buffer = _require(_dependencyMap[2]);

    var _Optimize = _require(_dependencyMap[3]);

    var _Optimize2 = babelHelpers.interopRequireDefault(_Optimize);

    function OptimizaMapUtil(mapStr) {
        mapStr = mapStr.replace(/-/g, "+");
        mapStr = mapStr.replace(/_/g, "/");
        this.mapStr = mapStr;
        this.map = {};

        var unZipArrayBuffer = _pako2.default.inflate(_buffer.Buffer.from(this.mapStr, 'base64'));

        var unZipBuffer = _buffer.Buffer.from(unZipArrayBuffer);

        var map_id = unZipBuffer.readInt16LE(0);
        var frame_id = unZipBuffer.readInt16LE(2);
        var frame_type = unZipBuffer.readInt8(4);
        var robotPos = {};
        robotPos.x = unZipBuffer.readInt16LE(5);
        robotPos.y = unZipBuffer.readInt16LE(7);
        robotPos.angle = unZipBuffer.readInt16LE(9);
        var chargerPos = {};
        chargerPos.x = unZipBuffer.readInt16LE(11);
        chargerPos.y = unZipBuffer.readInt16LE(13);
        chargerPos.angle = unZipBuffer.readInt16LE(15);
        var gridWidth = unZipBuffer.readInt16LE(17);
        var iwidth = unZipBuffer.readInt16LE(19);
        var iHeight = unZipBuffer.readInt16LE(21);

        var _x = unZipBuffer.readInt16LE(23);

        var _y = unZipBuffer.readInt16LE(25);

        this.iwidth = iwidth;
        this.iHeight = iHeight;
        this.map.width = iwidth;
        this.map.height = iHeight;
        this.map.gridWidth = gridWidth;
        this.map.chargerPos = {
            x: (chargerPos.x - _x) / gridWidth,
            y: (chargerPos.y - _y) / gridWidth,
            angle: chargerPos.angle
        };

        if (unZipBuffer.length < 27 + iwidth * iHeight) {
            console.log("map data is missing");
            return;
        }

        if (frame_type != 73) {
            console.log("frame type is error:" + frame_type);
            return;
        }

        var mapInfo = _buffer.Buffer.alloc(iwidth * iHeight, 0);

        var oldMapInfo = _buffer.Buffer.alloc(iwidth * iHeight, 0);

        for (var i = 0; i < mapInfo.length; i++) {
            mapInfo[i] = unZipBuffer[i + 27];
            oldMapInfo[i] = unZipBuffer[i + 27];
            ;
        }

        this.mapInfo = mapInfo;

        _Optimize2.default.clearLaminatedWall(mapInfo, iwidth, iHeight);

        _Optimize2.default.clearBorder(mapInfo);

        _Optimize2.default.fillMapData(mapInfo, iwidth, iHeight, 2, 3, 3);

        _Optimize2.default.denoise(mapInfo, iwidth, iHeight);

        _Optimize2.default.denoise2(mapInfo, iwidth, iHeight);

        _Optimize2.default.updateBorderValue(mapInfo, iwidth, iHeight, 5);

        _Optimize2.default.fillCrossLine(mapInfo, iwidth, iHeight, 5);

        _Optimize2.default.linkAdjacentAreas(oldMapInfo, mapInfo, iwidth, iHeight, 5);

        _Optimize2.default.findOutLine(mapInfo, iwidth, iHeight, 5, true);

        _Optimize2.default.updateBorderValue(mapInfo, iwidth, iHeight, 6);

        _Optimize2.default.findOutLine(mapInfo, iwidth, iHeight, 6);

        _Optimize2.default.updateBorderValue(mapInfo, iwidth, iHeight, 7);

        _Optimize2.default.findOutLine(mapInfo, iwidth, iHeight, 7);

        fillObstacle(mapInfo, iwidth, iHeight);

        _Optimize2.default.clearSmallObstacle(mapInfo, iwidth, iHeight, 3);

        linkSmallObstacle(mapInfo, iwidth, iHeight, 3);
        fillObstacleLines(mapInfo, iwidth, iHeight, 3);
        this.map.obstacles = findObstacleLines(mapInfo, iwidth, iHeight, 4);

        _Optimize2.default.updateBorderValue(mapInfo, iwidth, iHeight, 8);

        this.map.points = extractPoints(mapInfo, iwidth, iHeight, 8);

        if (chargerPos.angle != 32767) {
            var vLines = [];
            var hLines = [];

            for (var _i2 = 1; _i2 < this.map.points.length; _i2++) {
                var p0 = this.map.points[_i2 - 1];
                var p1 = this.map.points[_i2];

                if (p0.x == p1.x) {
                    vLines.push({
                        p0: p0,
                        p1: p1
                    });
                } else if (p0.y == p1.y) {
                    hLines.push({
                        p0: p0,
                        p1: p1
                    });
                }
            }

            var cX = Math.floor(this.map.chargerPos.x);
            var cY = Math.floor(this.map.chargerPos.y);
            var index = cY * iwidth + cX;
            console.log(chargerPos, oldMapInfo[index], cX, cY, vLines);

            if (oldMapInfo[index] == 1) {
                if (Math.abs(chargerPos.angle - 180) <= 30) {
                    chargerPos.angle = 180;
                    var lastX = undefined;

                    for (var _i3 = 0; _i3 < vLines.length; _i3++) {
                        var line = vLines[_i3];
                        var lx = line.p0.x;
                        var minY = line.p0.y < line.p1.y ? line.p0.y : line.p1.y;
                        var maxY = line.p0.y > line.p1.y ? line.p0.y : line.p1.y;

                        if (lx >= cX && cY >= minY && cY <= maxY) {
                            if (lastX == undefined || lx < lastX) {
                                lastX = lx;
                            }
                        }
                    }

                    if (lastX != undefined) {
                        if (lastX - cX <= 11) {
                            this.map.chargerPos.angle = 180;
                            this.map.chargerPos.x = lastX + 0.5;
                        }
                    }
                } else if (Math.abs(chargerPos.angle - 360) <= 30 || Math.abs(chargerPos.angle) <= 30) {
                    chargerPos.angle = 360;
                    var _lastX = undefined;

                    for (var _i4 = 0; _i4 < vLines.length; _i4++) {
                        var _line = vLines[_i4];
                        var _lx = _line.p0.x;

                        var _minY = _line.p0.y < _line.p1.y ? _line.p0.y : _line.p1.y;

                        var _maxY = _line.p0.y > _line.p1.y ? _line.p0.y : _line.p1.y;

                        if (_lx <= cX && cY >= _minY && cY <= _maxY) {
                            if (_lastX == undefined || _lx > _lastX) {
                                _lastX = _lx;
                            }
                        }
                    }

                    if (_lastX != undefined) {
                        if (cX - _lastX <= 11) {
                            this.map.chargerPos.angle = 360;
                            this.map.chargerPos.x = _lastX + 0.5;
                        }
                    }
                } else if (Math.abs(Math.abs(chargerPos.angle - 270) <= 30)) {
                    var lastY = undefined;

                    for (var _i5 = 0; _i5 < hLines.length; _i5++) {
                        var _line2 = hLines[_i5];
                        var ly = _line2.p0.y;
                        var minX = _line2.p0.x < _line2.p1.x ? _line2.p0.x : _line2.p1.x;
                        var maxX = _line2.p0.x > _line2.p1.x ? _line2.p0.x : _line2.p1.x;

                        if (ly >= cY && cX >= minX && cX <= maxX) {
                            if (lastY == undefined || ly < lastY) {
                                lastY = ly;
                            }
                        }
                    }

                    if (lastY != undefined) {
                        if (lastY - cY <= 11) {
                            this.map.chargerPos.angle = 270;
                            this.map.chargerPos.y = lastY + 0.5;
                        }
                    }
                } else if (Math.abs(Math.abs(chargerPos.angle - 90) <= 30)) {
                    var _lastY = undefined;

                    for (var _i6 = 0; _i6 < hLines.length; _i6++) {
                        var _line3 = hLines[_i6];
                        var _ly = _line3.p0.y;

                        var _minX = _line3.p0.x < _line3.p1.x ? _line3.p0.x : _line3.p1.x;

                        var _maxX = _line3.p0.x > _line3.p1.x ? _line3.p0.x : _line3.p1.x;

                        if (_ly <= cY && cX >= _minX && cX <= _maxX) {
                            if (_lastY == undefined || _ly > _lastY) {
                                _lastY = _ly;
                            }
                        }
                    }

                    if (_lastY != undefined) {
                        if (cY - _lastY <= 11) {
                            this.map.chargerPos.angle = 90;
                            this.map.chargerPos.y = _lastY + 0.5;
                        }
                    }
                }
            }
        }
    }

    OptimizaMapUtil.prototype.getMap = function () {
        return this.map;
    };

    OptimizaMapUtil.prototype.getMapInfo = function () {
        return this.mapInfo;
    };

    OptimizaMapUtil.prototype.getWidth = function () {
        return this.iwidth;
    };

    OptimizaMapUtil.prototype.getHeight = function () {
        return this.iHeight;
    };

    function linkSmallObstacle(mapInfo, picW, picH, obstacleValue) {
        for (var i = 0; i < picW; i++) {
            var startY = -1;
            var len = 0;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;

                if (mapInfo[index] == obstacleValue) {
                    if (startY > 0 && len <= 3) {
                        for (var k = startY + 1; k < j; k++) {
                            mapInfo[k * picW + i] = obstacleValue;
                        }
                    }

                    startY = j;
                    len = 0;
                    continue;
                } else if (mapInfo[index] == 0) {
                    startY = -1;
                    len = 0;
                } else if (startY > 0) {
                    len++;
                    continue;
                }

                startY = -1;
                len = 0;
            }
        }

        for (var j = 0; j < picH; j++) {
            var startX = -1;
            var len = 0;

            for (var i = 0; i < picW; i++) {
                var index = j * picW + i;

                if (mapInfo[index] == obstacleValue) {
                    if (startX > 0 && len <= 3) {
                        for (var k = startX + 1; k < i; k++) {
                            mapInfo[j * picW + k] = obstacleValue;
                        }
                    }

                    startX = i;
                    len = 0;
                    continue;
                } else if (mapInfo[index] == 0) {
                    startX = -1;
                    len = 0;
                } else if (startX > 0) {
                    len++;
                    continue;
                }

                startX = -1;
                len = 0;
            }
        }
    }

    function fillObstacle(mapInfo, picW, picH) {
        var fristPoint = null;

        for (var j = 0; j < picH; j++) {
            for (var i = 0; i < picW; i++) {
                if (mapInfo[j * picW + i] == 0) {
                    if (!fristPoint) {
                        fristPoint = {
                            x: i,
                            y: j
                        };
                    }
                }

                if (fristPoint) {
                    break;
                }
            }

            if (fristPoint) {
                break;
            }
        }

        if (!fristPoint) {
            return;
        }

        var fillData = 255;
        mapInfo[fristPoint.x + fristPoint.y * picW] = fillData;
        var needFindPoints = [];
        needFindPoints.push(fristPoint);

        function findZeroPoint(p) {
            var finds = [];
            var i = p.x;
            var j = p.y;

            for (var _j = j - 1; _j <= j + 1; _j++) {
                for (var _i = i - 1; _i <= i + 1; _i++) {
                    if (_j == j || _i == i) {
                        if (mapInfo[_j * picW + _i] == 0) {
                            mapInfo[_j * picW + _i] = 255;
                            finds.push({
                                x: _i,
                                y: _j
                            });
                        }
                    }
                }
            }

            return finds;
        }

        while (needFindPoints.length > 0) {
            var p = needFindPoints.shift();
            var ps = findZeroPoint(p);
            needFindPoints = needFindPoints.concat(ps);
        }

        for (var _j2 = 0; _j2 < picH; _j2++) {
            for (var _i7 = 0; _i7 < picW; _i7++) {
                var index = _j2 * picW + _i7;

                if (mapInfo[index] == 0) {
                    mapInfo[index] = 3;
                }
            }
        }

        for (var _j3 = 0; _j3 < picH; _j3++) {
            for (var _i8 = 0; _i8 < picW; _i8++) {
                var _index = _j3 * picW + _i8;

                if (mapInfo[_index] == fillData) {
                    mapInfo[_index] = 0;
                }
            }
        }
    }

    function fillObstacleLines(mapInfo, picW, picH, obstacleValue) {
        for (var i = 0; i < picW; i++) {
            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;

                if (mapInfo[index] == obstacleValue) {
                    for (var ii = i - 1; ii < i + 2; ii++) {
                        for (var jj = j - 1; jj < j + 2; jj++) {
                            if (ii == i && jj == j) {
                                continue;
                            }

                            var nIndex = jj * picW + ii;

                            if (mapInfo[nIndex] != obstacleValue) {
                                mapInfo[nIndex] = 4;
                            }
                        }
                    }
                }
            }
        }
    }

    function findObstacleLines(mapInfo, picW, picH, obstacleValue) {
        var horizontalLines = [];
        var verticalLines = [];

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;
                var lastY = j - 1;

                if (mapInfo[index] == obstacleValue) {
                    if (startY < 0) {
                        startY = j;
                    }

                    continue;
                }

                if (startY >= 0) {
                    if (lastY == startY) {
                        startY = -1;
                        continue;
                    }

                    var line = {
                        x: i,
                        y: [startY, lastY],
                        ishorizontal: false,
                        length: lastY - startY + 1
                    };
                    verticalLines.push(line);
                }

                startY = -1;
            }
        }

        for (var _j4 = 0; _j4 < picH; _j4++) {
            var startX = -1;

            for (var _i9 = 0; _i9 < picW; _i9++) {
                var _index2 = _j4 * picW + _i9;

                var lastX = _i9 - 1;

                if (mapInfo[_index2] == obstacleValue) {
                    if (startX < 0) {
                        startX = _i9;
                    }

                    continue;
                }

                if (startX >= 0) {
                    if (lastX == startX) {
                        startX = -1;
                        continue;
                    }

                    var _line4 = {
                        x: [startX, lastX],
                        y: _j4,
                        ishorizontal: true,
                        length: lastX - startX + 1
                    };
                    horizontalLines.push(_line4);
                }

                startX = -1;
            }
        }

        function findStartLine(lines) {
            for (var _i10 = 0; _i10 < lines.length; _i10++) {
                var _line5 = lines[_i10];

                if (_line5 != undefined) {
                    delete lines[_i10];
                    return _line5;
                }
            }

            return undefined;
        }

        function addLine(line, allLines, covertlines) {
            var aLine = {
                p0: {},
                p1: {}
            };

            if (line.ishorizontal) {
                aLine.p0.y = line.y;
                aLine.p1.y = line.y;

                if (line.findEnd) {
                    aLine.p0.x = line.x[0];
                    aLine.p1.x = line.x[1];
                } else {
                    aLine.p0.x = line.x[1];
                    aLine.p1.x = line.x[0];
                }

                aLine.length = Math.abs(line.x[1] - line.x[0]);
            } else {
                aLine.p0.x = line.x;
                aLine.p1.x = line.x;
                aLine.length = Math.abs(line.y[1] - line.y[0]);

                if (line.findEnd) {
                    aLine.p0.y = line.y[0];
                    aLine.p1.y = line.y[1];
                } else {
                    aLine.p0.y = line.y[1];
                    aLine.p1.y = line.y[0];
                }
            }

            allLines.push(line);
            covertlines.push(aLine);
        }

        var allObstacles = [];

        while (true) {
            var startLine = findStartLine(horizontalLines);

            if (!startLine) {
                break;
            }

            var ishorizontal = true;
            var allLines = [];
            startLine.findEnd = true;
            var covertlines = [];
            addLine(startLine, allLines, covertlines);

            while (true) {
                var lastLine = allLines[allLines.length - 1];

                if (ishorizontal) {
                    var hasFind = false;

                    for (var _i11 = 0; _i11 < verticalLines.length; _i11++) {
                        var vLine = verticalLines[_i11];

                        if (vLine == undefined) {
                            continue;
                        }

                        var x = lastLine.x[0];

                        if (lastLine.findEnd) {
                            x = lastLine.x[1];
                        }

                        if (x == vLine.x) {
                            if (lastLine.y == vLine.y[0]) {
                                vLine.findEnd = true;
                                addLine(vLine, allLines, covertlines);
                                delete verticalLines[_i11];
                                hasFind = true;
                                break;
                            } else if (lastLine.y == vLine.y[1]) {
                                vLine.findEnd = false;
                                addLine(vLine, allLines, covertlines);
                                delete verticalLines[_i11];
                                hasFind = true;
                                break;
                            } else if (lastLine.y > vLine.y[0] && lastLine.y < vLine.y[1]) {
                                if (lastLine.findEnd) {
                                    if (mapInfo[(lastLine.y + 1) * picW + x - 1] == 0) {
                                        vLine.y[1] = lastLine.y;
                                        vLine.findEnd = false;
                                    } else {
                                        vLine.y[0] = lastLine.y;
                                        vLine.findEnd = true;
                                    }
                                } else {
                                    if (mapInfo[(lastLine.y + 1) * picW + x + 1] == 0) {
                                        vLine.y[1] = lastLine.y;
                                        vLine.findEnd = false;
                                    } else {
                                        vLine.y[0] = lastLine.y;
                                        vLine.findEnd = true;
                                    }
                                }

                                addLine(vLine, allLines, covertlines);
                                delete verticalLines[_i11];
                                hasFind = true;
                                break;
                            }
                        }
                    }

                    if (hasFind) {
                        ishorizontal = false;
                    } else {
                        break;
                    }
                } else {
                    var _hasFind = false;
                    var _y = lastLine.y[0];

                    if (lastLine.findEnd) {
                        _y = lastLine.y[1];
                    }

                    if (_y == startLine.y && lastLine.x == startLine.x[0]) {
                        break;
                    }

                    for (var _i12 = 0; _i12 < horizontalLines.length; _i12++) {
                        var hLine = horizontalLines[_i12];

                        if (!hLine) {
                            continue;
                        }

                        var y = lastLine.y[0];

                        if (lastLine.findEnd) {
                            y = lastLine.y[1];
                        }

                        if (y == hLine.y) {
                            if (lastLine.x == hLine.x[0]) {
                                hLine.findEnd = true;
                                addLine(hLine, allLines, covertlines);
                                delete horizontalLines[_i12];
                                _hasFind = true;
                                break;
                            } else if (lastLine.x == hLine.x[1]) {
                                hLine.findEnd = false;
                                addLine(hLine, allLines, covertlines);
                                delete horizontalLines[_i12];
                                _hasFind = true;
                                break;
                            } else if (lastLine.x > hLine.x[0] && lastLine.x < hLine.x[1]) {
                                if (lastLine.findEnd) {
                                    if (mapInfo[(y - 1) * picW + lastLine.x - 1] == 0) {
                                        hLine.x[0] = lastLine.x;
                                        hLine.findEnd = true;
                                    } else {
                                        hLine.x[1] = lastLine.x;
                                        hLine.findEnd = false;
                                    }
                                } else {
                                    if (mapInfo[(y + 1) * picW + lastLine.x - 1] == 0) {
                                        hLine.x[0] = lastLine.x;
                                        hLine.findEnd = true;
                                    } else {
                                        hLine.x[1] = lastLine.x;
                                        hLine.findEnd = false;
                                    }
                                }

                                addLine(hLine, allLines, covertlines);
                                delete horizontalLines[_i12];
                                _hasFind = true;
                                break;
                            }
                        }
                    }

                    if (_hasFind) {
                        ishorizontal = true;
                    } else {
                        break;
                    }
                }
            }

            if (covertlines.length >= 3) {
                allObstacles.push(covertlines);
            }
        }

        var ObstacleLinesPoint = [];

        for (var _i13 = 0; _i13 < allObstacles.length; _i13++) {
            var _covertlines = allObstacles[_i13];
            var points = [];
            var tmpLines = [];
            var shortSidenum = 0;

            for (var _index3 = 0; _index3 < _covertlines.length; _index3++) {
                var _line6 = _covertlines[_index3];

                if (_index3 == 0) {
                    points.push(_line6.p0);
                    points.push(_line6.p1);
                    continue;
                }

                if (_line6.length <= 4 && _index3 != _covertlines.length - 1) {
                    tmpLines.push(_line6);
                    shortSidenum++;
                    continue;
                } else {
                    var lastP = points[points.length - 1];

                    if (shortSidenum > 0) {
                        if (shortSidenum == 1) {
                            points.push(_line6.p0);
                        } else if (shortSidenum < 10) {
                            var p = {
                                x: _line6.p0.x,
                                y: lastP.y
                            };
                            var p1 = {
                                y: _line6.p0.y,
                                x: lastP.x
                            };

                            if (mapInfo[p.y * picW + p.x] != 1 && mapInfo[p.y * picW + p.x] != obstacleValue) {
                                points.push(p);
                            } else if (mapInfo[p1.y * picW + p1.x] != 1 && mapInfo[p1.y * picW + p1.x] != obstacleValue) {
                                points.push(p1);
                            } else {
                                for (var ii = 0; ii < tmpLines.length; ii++) {
                                    var tmpLine = tmpLines[ii];
                                    points.push(tmpLine.p1);
                                }
                            }

                            points.push(_line6.p0);
                        } else {
                            points.push(_line6.p0);
                        }
                    }

                    points.push(_line6.p1);
                    shortSidenum = 0;
                    tmpLines = [];
                }
            }

            ObstacleLinesPoint.push(points);
        }

        return ObstacleLinesPoint;
    }

    function extractPoints(mapInfo, picW, picH, strokeValue) {
        var horizontalLines = [];
        var verticalLines = [];

        for (var i = 0; i < picW; i++) {
            var startY = -1;

            for (var j = 0; j < picH; j++) {
                var index = j * picW + i;
                var lastY = j - 1;

                if (mapInfo[index] == strokeValue && j != picH - 1) {
                    var isCross = false;

                    if (i != 0 && mapInfo[index - 1] == strokeValue || i != picW - 1 && mapInfo[index + 1] == strokeValue) {
                        isCross = true;
                    }

                    if (startY < 0 && isCross) {
                        startY = j;
                        continue;
                    }

                    if (!isCross) {
                        continue;
                    }

                    lastY = j;
                }

                if (startY >= 0) {
                    if (j == picH - 1 && mapInfo[index] == strokeValue) {
                        lastY = j;
                    }

                    if (lastY == startY) {
                        startY = -1;
                        continue;
                    }

                    var _isCross = false;
                    var lastIndex = lastY * picW + i;

                    if (mapInfo[lastIndex - 1] == strokeValue || mapInfo[lastIndex + 1] == strokeValue) {
                        _isCross = true;
                    }

                    if (_isCross) {
                        var line = {
                            x: i,
                            y: [startY, lastY],
                            ishorizontal: false,
                            lenght: lastY - startY
                        };
                        verticalLines.push(line);
                        startY = lastY;
                        continue;
                    }
                }

                startY = -1;
            }
        }

        for (var _j5 = 0; _j5 < picH; _j5++) {
            var startX = -1;

            for (var _i14 = 0; _i14 < picW; _i14++) {
                var _index4 = _j5 * picW + _i14;

                var lastX = _i14 - 1;

                if (mapInfo[_index4] == strokeValue && _i14 != picW - 1) {
                    var _isCross2 = false;

                    if (mapInfo[_index4 - picW] == strokeValue || mapInfo[_index4 + picW] == strokeValue) {
                        _isCross2 = true;
                    }

                    if (startX < 0 && _isCross2) {
                        startX = _i14;
                        continue;
                    }

                    if (!_isCross2) {
                        continue;
                    }

                    lastX = _i14;
                }

                if (startX >= 0) {
                    if (mapInfo[_index4] == strokeValue && _i14 == picW - 1) {
                        lastX = _i14;
                    }

                    if (lastX == startX) {
                        startX = -1;
                        continue;
                    }

                    var _isCross3 = false;

                    var _lastIndex = _j5 * picW + lastX;

                    if (mapInfo[_lastIndex - picW] == strokeValue || mapInfo[_lastIndex + picW] == strokeValue) {
                        _isCross3 = true;
                    }

                    if (_isCross3) {
                        var _line7 = {
                            x: [startX, lastX],
                            y: _j5,
                            ishorizontal: true,
                            length: lastX - startX
                        };
                        horizontalLines.push(_line7);
                        startX = lastX;
                        continue;
                    }
                }

                startX = -1;
            }
        }

        var startLine = horizontalLines[0];
        var ishorizontal = true;
        var allLines = [];
        startLine.findEnd = true;
        var covertlines = [];

        function addLine(line) {
            var aLine = {
                p0: {},
                p1: {}
            };

            if (line.ishorizontal) {
                aLine.p0.y = line.y;
                aLine.p1.y = line.y;

                if (line.findEnd) {
                    aLine.p0.x = line.x[0];
                    aLine.p1.x = line.x[1];
                } else {
                    aLine.p0.x = line.x[1];
                    aLine.p1.x = line.x[0];
                }

                aLine.length = Math.abs(line.x[1] - line.x[0]);
            } else {
                aLine.p0.x = line.x;
                aLine.p1.x = line.x;
                aLine.length = Math.abs(line.y[1] - line.y[0]);

                if (line.findEnd) {
                    aLine.p0.y = line.y[0];
                    aLine.p1.y = line.y[1];
                } else {
                    aLine.p0.y = line.y[1];
                    aLine.p1.y = line.y[0];
                }
            }

            allLines.push(line);
            covertlines.push(aLine);
        }

        addLine(startLine);

        while (true) {
            var lastLine = allLines[allLines.length - 1];

            if (ishorizontal) {
                var hasFind = false;

                for (var _i15 = 0; _i15 < verticalLines.length; _i15++) {
                    var vLine = verticalLines[_i15];

                    if (vLine == undefined) {
                        continue;
                    }

                    var x = lastLine.x[0];

                    if (lastLine.findEnd) {
                        x = lastLine.x[1];
                    }

                    if (x == vLine.x) {
                        if (lastLine.y == vLine.y[0]) {
                            vLine.findEnd = true;
                            addLine(vLine);
                            delete verticalLines[_i15];
                            hasFind = true;
                            break;
                        } else if (lastLine.y == vLine.y[1]) {
                            vLine.findEnd = false;
                            addLine(vLine);
                            delete verticalLines[_i15];
                            hasFind = true;
                            break;
                        } else if (lastLine.y > vLine.y[0] && lastLine.y < vLine.y[1]) {
                            if (lastLine.findEnd) {
                                if (mapInfo[(lastLine.y + 1) * picW + x - 1] == 0) {
                                    vLine.y[1] = lastLine.y;
                                    vLine.findEnd = false;
                                } else {
                                    vLine.y[0] = lastLine.y;
                                    vLine.findEnd = true;
                                }
                            } else {
                                if (mapInfo[(lastLine.y + 1) * picW + x + 1] == 0) {
                                    vLine.y[1] = lastLine.y;
                                    vLine.findEnd = false;
                                } else {
                                    vLine.y[0] = lastLine.y;
                                    vLine.findEnd = true;
                                }
                            }

                            addLine(vLine);
                            delete verticalLines[_i15];
                            hasFind = true;
                            break;
                        }
                    }
                }

                if (hasFind) {
                    ishorizontal = false;
                } else {
                    break;
                }
            } else {
                var _hasFind2 = false;
                var _y = lastLine.y[0];

                if (lastLine.findEnd) {
                    _y = lastLine.y[1];
                }

                if (_y == startLine.y && lastLine.x == startLine.x[0]) {
                    break;
                }

                for (var _i16 = 0; _i16 < horizontalLines.length; _i16++) {
                    var hLine = horizontalLines[_i16];

                    if (!hLine) {
                        continue;
                    }

                    var y = lastLine.y[0];

                    if (lastLine.findEnd) {
                        y = lastLine.y[1];
                    }

                    if (y == hLine.y) {
                        if (lastLine.x == hLine.x[0]) {
                            hLine.findEnd = true;
                            addLine(hLine);
                            delete horizontalLines[_i16];
                            _hasFind2 = true;
                            break;
                        } else if (lastLine.x == hLine.x[1]) {
                            hLine.findEnd = false;
                            addLine(hLine);
                            delete horizontalLines[_i16];
                            _hasFind2 = true;
                            break;
                        } else if (lastLine.x > hLine.x[0] && lastLine.x < hLine.x[1]) {
                            if (lastLine.findEnd) {
                                if (mapInfo[(y - 1) * picW + lastLine.x - 1] == 0) {
                                    hLine.x[0] = lastLine.x;
                                    hLine.findEnd = true;
                                } else {
                                    hLine.x[1] = lastLine.x;
                                    hLine.findEnd = false;
                                }
                            } else {
                                if (mapInfo[(y + 1) * picW + lastLine.x - 1] == 0) {
                                    hLine.x[0] = lastLine.x;
                                    hLine.findEnd = true;
                                } else {
                                    hLine.x[1] = lastLine.x;
                                    hLine.findEnd = false;
                                }
                            }

                            addLine(hLine);
                            delete horizontalLines[_i16];
                            _hasFind2 = true;
                            break;
                        }
                    }
                }

                if (_hasFind2) {
                    ishorizontal = true;
                } else {
                    break;
                }
            }
        }

        horizontalLines = [];
        verticalLines = [];
        var points = [];
        var tmpLines = [];
        var shortSidenum = 0;

        for (var _index5 = 0; _index5 < covertlines.length; _index5++) {
            var _line8 = covertlines[_index5];

            if (_index5 == 0) {
                points.push(_line8.p0);
                points.push(_line8.p1);
                continue;
            }

            if (_line8.length <= 4 && _index5 != covertlines.length - 1) {
                tmpLines.push(_line8);
                shortSidenum++;
                continue;
            } else {
                var lastP = points[points.length - 1];

                if (shortSidenum > 0) {
                    if (shortSidenum == 1) {
                        points.push(_line8.p0);
                    } else if (shortSidenum < 7) {
                        var p = {
                            x: _line8.p0.x,
                            y: lastP.y
                        };
                        var p1 = {
                            y: _line8.p0.y,
                            x: lastP.x
                        };

                        if (mapInfo[p.y * picW + p.x] != 0 && mapInfo[p.y * picW + p.x] != strokeValue) {
                            points.push(p);
                        } else if (mapInfo[p1.y * picW + p1.x] != 0 && mapInfo[p1.y * picW + p1.x] != strokeValue) {
                            points.push(p1);
                        } else {
                            for (var ii = 0; ii < tmpLines.length; ii++) {
                                var tmpLine = tmpLines[ii];
                                points.push(tmpLine.p1);
                            }
                        }

                        points.push(_line8.p0);
                    } else {
                        points.push(_line8.p0);
                    }
                }

                points.push(_line8.p1);
                shortSidenum = 0;
                tmpLines = [];
            }
        }

        for (var _i17 = 0; _i17 < points.length; _i17++) {
            var _p = points[_i17];
            mapInfo[_p.y * picW + _p.x] = 10;
        }

        return points;
    }

    module.exports = OptimizaMapUtil;
},10559,[10064,10010,10007,10112],"projects/com.dreame.devices/main/DreameUtil/OptimizeMapUtil.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 1080,
    "height": 2160,
    "scales": [1],
    "hash": "1c91ae6c3ae40085a9baf1eace85d738",
    "name": "log_bg",
    "type": "jpg"
  });
},10562,[10420],"projects/com.dreame.devices/resources/log_bg.jpg");
__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _react = _require(_dependencyMap[0]);

    var _react2 = babelHelpers.interopRequireDefault(_react);

    var _reactNative = _require(_dependencyMap[1]);

    var _TitleBarBlack = _require(_dependencyMap[2]);

    var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

    var _MHLocalizableString = _require(_dependencyMap[3]);

    var _SettingListItemView = _require(_dependencyMap[4]);

    var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

    var _Toast = _require(_dependencyMap[5]);

    var _Toast2 = babelHelpers.interopRequireDefault(_Toast);

    var _reactNativeProgress = _require(_dependencyMap[6]);

    var Progress = babelHelpers.interopRequireWildcard(_reactNativeProgress);

    var _TextButton = _require(_dependencyMap[7]);

    var _TextButton2 = babelHelpers.interopRequireDefault(_TextButton);

    var _miot = _require(_dependencyMap[8]);

    var did = _miot.Device.getDeviceWifi().deviceID;

    var _Dimensions$get = _reactNative.Dimensions.get('window'),
        width = _Dimensions$get.width,
        height = _Dimensions$get.height;

    var delay = 3000;

    var OTAPage = function (_React$Component) {
        babelHelpers.inherits(OTAPage, _React$Component);

        function OTAPage(props) {
            babelHelpers.classCallCheck(this, OTAPage);

            var _this = babelHelpers.possibleConstructorReturn(this, (OTAPage.__proto__ || Object.getPrototypeOf(OTAPage)).call(this, props));

            _this._handleAppStateChange = function (nextAppState) {
                if (_this.appState == undefined) {
                    _this.appState = "";
                }

                if (_this.appState.match(/inactive|background/) && nextAppState === 'active') {
                    _this.setState({
                        key: "" + Date.now()
                    });
                }

                _this.appState = nextAppState;
            };

            _this.checkDeviceVersion = function () {
                _miot.Service.smarthome.checkDeviceVersion(did).then(function (res) {
                    if (!_this.isMount) {
                        return;
                    }

                    console.log("checkDeviceVersion", res);

                    _this.updateStatus(res);
                }).catch(function (err) {
                    if (!_this.isMount) {
                        return;
                    }

                    console.log("checkDeviceVersion err", err);

                    if (_this.startTime) {
                        var timeOut = 600;

                        if (Date.now() / 1000 - _this.startTime < timeOut) {
                            setTimeout(_this.checkDeviceVersion, delay);
                        } else {
                            var errmsg = (0, _MHLocalizableString.getString)('upgradeErr5');

                            _this.setState({
                                status: -2,
                                errmsg: errmsg
                            });
                        }
                    } else {
                        _this.setState({
                            status: -1
                        });
                    }
                });
            };

            _this.updateStatus = function (res) {
                if (res.isLatest) {
                    gData.curVersion = res.curVersion;
                    gData.hasNewFirmware = res.hasNewFirmware;

                    if (_this.state.status == 4 || _this.state.status == 5) {
                        if (res.curVersion == _this.state.newVersion && _this.startTime != undefined) {
                            _this.setState({
                                status: 6,
                                currentVersion: res.curVersion
                            });
                        } else {
                            var timeOut = 600;

                            if (Date.now() / 1000 - _this.startTime < timeOut) {
                                setTimeout(_this.checkDeviceVersion, delay);
                            } else {
                                var errmsg = (0, _MHLocalizableString.getString)('upgradeErr5');

                                _this.setState({
                                    status: -2,
                                    errmsg: errmsg
                                });
                            }
                        }
                    } else {
                        _this.setState({
                            status: 2,
                            currentVersion: res.curVersion
                        });
                    }
                } else if (res.isUpdating == true) {
                    if (res.otaState.state == "downloading") {
                        _this.setState({
                            status: 4,
                            newVersion: res.newVersion,
                            progress: res.otaState.progress > 0 ? res.otaState.progress : 0
                        });
                    } else if (res.otaState.state == "installing") {
                        _this.setState({
                            status: 5,
                            newVersion: res.newVersion
                        });
                    } else if (res.otaState.state == "failed") {
                        var _errmsg = (0, _MHLocalizableString.getString)('upgradeErr5');

                        var failcode = res.otaState.failedCode;

                        if (_this.errs[failcode]) {
                            _errmsg = _this.errs[code];
                        }

                        _this.setState({
                            status: -2,
                            errmsg: _errmsg
                        });

                        return;
                    }

                    _this.startTime = res.otaState.startTime;
                    var _timeOut = 600;

                    if (Date.now() / 1000 - _this.startTime < _timeOut) {
                        setTimeout(_this.checkDeviceVersion, delay);
                    } else {
                        var _errmsg2 = (0, _MHLocalizableString.getString)('upgradeErr5');

                        _this.setState({
                            status: -2,
                            errmsg: _errmsg2
                        });
                    }
                } else {
                    if (_this.state.status == 4 || _this.state.status == 5) {
                        if ((res.otaState.state == "idle" || res.otaState.state == "dowloaded") && Date.now() / 1000 - res.otaState.startTime < 600) {
                            setTimeout(_this.checkDeviceVersion, delay);
                        } else {
                            var _errmsg3 = (0, _MHLocalizableString.getString)('upgradeErr5');

                            var _failcode = res.otaState.failedCode;

                            if (_this.errs[_failcode]) {
                                _errmsg3 = _this.errs[_failcode];
                            }

                            _this.setState({
                                status: -2,
                                errmsg: _errmsg3
                            });
                        }
                    } else {
                        gData.curVersion = res.curVersion;

                        _this.setState({
                            status: 3,
                            currentVersion: res.curVersion,
                            newVersion: res.newVersion,
                            description: res.description
                        });
                    }
                }
            };

            _this.showToast = function (msg) {
                if (_this.refs.toast) {
                    _this.refs.toast.show(msg, 1200);
                }
            };

            _this.renderImage1 = function (imageRes) {
                var iW = 88;
                return _react2.default.createElement(_reactNative.Image, {
                    style: {
                        marginTop: 99,
                        width: iW,
                        height: iW,
                        marginBottom: 11,
                        marginLeft: (width - iW) / 2
                    },
                    resizeMode: "contain",
                    source: imageRes
                });
            };

            _this.progressText = function () {
                if (_this.state.progress == undefined) {
                    _this.state.progress = 0;
                }

                if (_miot.Host.locale.language == "tr") {
                    return "%" + _this.state.progress;
                }

                return _this.state.progress + "%";
            };

            _this.renderImage = function () {
                var iW = 88;
                var marginBottom = 15;

                if (_this.state.status == 1) {
                    return _react2.default.createElement(Progress.Circle, {
                        style: {
                            marginTop: 104,
                            width: iW - 10,
                            height: iW - 10,
                            marginBottom: marginBottom,
                            marginLeft: (width - iW + 10) / 2
                        },
                        size: iW - 10,
                        borderWidth: 3,
                        borderColor: "#cccccc",
                        indeterminate: true
                    });
                } else if (_this.state.status == 2) {
                    return _this.renderImage1(_require(_dependencyMap[9]));
                } else if (_this.state.status == -1) {
                    return _this.renderImage1(_require(_dependencyMap[10]));
                } else if (_this.state.status == 3) {
                    return _this.renderImage1(_require(_dependencyMap[11]));
                } else if (_this.state.status == -2) {
                    return _this.renderImage1(_require(_dependencyMap[10]));
                } else if (_this.state.status == 4) {
                    return _react2.default.createElement(Progress.Circle, {
                        style: {
                            marginTop: 104,
                            width: iW - 10,
                            height: iW - 10,
                            marginBottom: marginBottom,
                            marginLeft: (width - iW + 10) / 2
                        },
                        color: "rgba(86,150,255,1)",
                        showsText: true,
                        formatText: _this.progressText,
                        textStyle: {
                            fontFamily: Const.fontFamily
                        },
                        progress: _this.state.progress / 100,
                        size: iW - 10,
                        indeterminate: false
                    });
                } else if (_this.state.status == 5) {
                    return _react2.default.createElement(Progress.Circle, {
                        key: _this.state.key,
                        style: {
                            marginTop: 104,
                            width: iW - 10,
                            height: iW - 10,
                            marginBottom: marginBottom,
                            marginLeft: (width - iW + 10) / 2
                        },
                        size: iW - 10,
                        borderWidth: 3,
                        borderColor: "rgba(86,150,255,1)",
                        indeterminate: true
                    });
                } else if (_this.state.status == 6) {
                    return _this.renderImage1(_require(_dependencyMap[12]));
                }

                return _react2.default.createElement(_reactNative.Image, {
                    style: {
                        marginTop: 100,
                        width: iW,
                        height: iW,
                        marginLeft: (width - iW) / 2
                    },
                    resizeMode: "contain",
                    source: _this.state.imageRes
                });
            };

            _this.renderTipText1 = function (text1, text2) {
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: {
                            width: width,
                            paddingLeft: 15,
                            paddingRight: 15
                        },
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: {
                                color: "#000000",
                                fontFamily: Const.fontFamily,
                                fontSize: 14
                            }
                        },
                        text1
                    ),
                    _react2.default.createElement(
                        _reactNative.Text,
                        {
                            style: {
                                color: "rgba(0,0,0,0.5)",
                                fontFamily: Const.fontFamily,
                                marginTop: 3,
                                fontSize: 13
                            }
                        },
                        text2
                    )
                );
            };

            _this.renderTipText = function () {
                if (_this.state.status == 1) {
                    return _this.renderTipText1((0, _MHLocalizableString.getString)('otaChecking'), (0, _MHLocalizableString.getString)('currentVersion') + " " + _this.state.currentVersion);
                } else if (_this.state.status == 2) {
                    return _this.renderTipText1((0, _MHLocalizableString.getString)('isLatestVersion'), (0, _MHLocalizableString.getString)('currentVersion') + " " + _this.state.currentVersion);
                } else if (_this.state.status == -1) {
                    return _this.renderTipText1((0, _MHLocalizableString.getString)('checkVersionFailed'), (0, _MHLocalizableString.getString)('currentVersion') + " " + _this.state.currentVersion);
                } else if (_this.state.status == -2) {
                    return _this.renderTipText1((0, _MHLocalizableString.getString)('upgradeErr'), _this.state.errmsg);
                } else if (_this.state.status == 3) {
                    return _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                width: width
                            },
                            justifyContent: "center",
                            alignItems: "center"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "#000000",
                                    fontFamily: Const.fontFamily,
                                    fontSize: 14,
                                    paddingLeft: 15,
                                    paddingRight: 15
                                }
                            },
                            (0, _MHLocalizableString.getString)('currentVersion') + " " + _this.state.currentVersion
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "#000000",
                                    fontSize: 14,
                                    fontFamily: Const.fontFamily,
                                    marginTop: 3,
                                    paddingLeft: 15,
                                    paddingRight: 15
                                }
                            },
                            (0, _MHLocalizableString.getString)('latestVersion') + " " + _this.state.newVersion
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "rgba(0,0,0,0.5)",
                                    fontSize: 13,
                                    marginTop: 39,
                                    fontFamily: Const.fontFamily,
                                    width: width,
                                    paddingLeft: 30,
                                    paddingRight: 30
                                }
                            },
                            _this.state.description
                        )
                    );
                } else if (_this.state.status == 4) {
                    return _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                width: width,
                                paddingLeft: 15,
                                paddingRight: 15
                            },
                            justifyContent: "center",
                            alignItems: "center"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "#000000",
                                    fontFamily: Const.fontFamily,
                                    fontSize: 14
                                }
                            },
                            (0, _MHLocalizableString.getString)('updating')
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "rgba(0,0,0,0.5)",
                                    fontFamily: Const.fontFamily,
                                    marginTop: 3,
                                    fontSize: 13
                                }
                            },
                            (0, _MHLocalizableString.getString)('updateTip2')
                        )
                    );
                } else if (_this.state.status == 5) {
                    return _react2.default.createElement(
                        _reactNative.View,
                        {
                            style: {
                                width: width,
                                paddingLeft: 15,
                                paddingRight: 15
                            },
                            justifyContent: "center",
                            alignItems: "center"
                        },
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "#000000",
                                    fontFamily: Const.fontFamily,
                                    fontSize: 14
                                }
                            },
                            (0, _MHLocalizableString.getString)('installing')
                        ),
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "#ffa81d",
                                    marginTop: 3,
                                    fontFamily: Const.fontFamily,
                                    fontSize: 13
                                }
                            },
                            (0, _MHLocalizableString.getString)('installtip')
                        )
                    );
                } else if (_this.state.status == 6) {
                    return _this.renderTipText1((0, _MHLocalizableString.getString)('updatesuccess'), (0, _MHLocalizableString.getString)('currentVersion') + " " + _this.state.currentVersion);
                }

                return null;
            };

            _this.back = function () {
                _this.props.navigation.goBack();
            };

            _this.renderBottomView1 = function (text, onPress) {
                return _react2.default.createElement(_TextButton2.default, {
                    style: {
                        width: width - 52,
                        height: 48,
                        marginLeft: 26,
                        marginBottom: 26,
                        borderColor: 'rgba(0,0,0,0.2)',
                        borderWidth: _reactNative.StyleSheet.hairlineWidth
                    },
                    normalColor: "rgba(0,0,0,0)",
                    pressColor: "#f2f2f2",
                    text: text,
                    onPress: onPress,
                    textStyle: {
                        color: "rgba(0,0,0,0.7)",
                        fontFamily: Const.fontFamily,
                        fontSize: 13
                    }
                });
            };

            _this.updateNow = function () {
                _this.setState({
                    status: 4,
                    progress: 0
                });

                _miot.Device.getDeviceWifi().startUpgradingFirmware().then(function (res) {
                    console.log(res);
                    _this.startTime = Date.now() / 1000;
                    setTimeout(_this.checkDeviceVersion, 5000);
                }).catch(function (err) {
                    console.log("err", err);
                    var errmsg = (0, _MHLocalizableString.getString)('upgradeErr5');
                    var code = err.code;

                    if (code == undefined) {
                        var errInfo = JSON.stringify(err);

                        if (errInfo.indexOf("-33001") >= 0) {
                            code = "-33001";
                        } else if (errInfo.indexOf("-33002") >= 0) {
                            code = "-33002";
                        } else if (errInfo.indexOf("-33003") >= 0) {
                            code = "-33003";
                        } else if (errInfo.indexOf("-33004") >= 0) {
                            code = "-33004";
                        } else if (errInfo.indexOf("-33005") >= 0) {
                            code = "-33005";
                        } else if (errInfo.indexOf("-33006") >= 0) {
                            code = "-33006";
                        } else if (errInfo.indexOf("-33007") >= 0) {
                            code = "-33007";
                        } else if (errInfo.indexOf("-33008") >= 0) {
                            code = "-33008";
                        } else if (errInfo.indexOf("-33020") >= 0) {
                            code = "-33020";
                        }
                    }

                    if (code) {
                        if (_this.errs[code]) {
                            errmsg = _this.errs[code];
                        }
                    }

                    _this.setState({
                        status: -2,
                        errmsg: errmsg
                    });
                });
            };

            _this.renderBottomView = function () {
                if (_this.state.status == 2) {
                    return _this.renderBottomView1((0, _MHLocalizableString.getString)("back"), _this.back);
                } else if (_this.state.status == -1) {
                    return _this.renderBottomView1((0, _MHLocalizableString.getString)("retry"), function () {
                        _this.setState({
                            status: 1
                        });

                        _this.checkDeviceVersion();
                    });
                } else if (_this.state.status == -2) {
                    return _this.renderBottomView1((0, _MHLocalizableString.getString)("retry"), _this.updateNow);
                } else if (_this.state.status == 3) {
                    return _react2.default.createElement(
                        _reactNative.View,
                        null,
                        _react2.default.createElement(
                            _reactNative.Text,
                            {
                                style: {
                                    color: "rgba(0,0,0,1)",
                                    fontSize: 13,
                                    width: width - 40,
                                    marginLeft: 20,
                                    fontFamily: Const.fontFamily,
                                    textAlign: "center"
                                }
                            },
                            (0, _MHLocalizableString.getString)('updateTip')
                        ),
                        _react2.default.createElement(_TextButton2.default, {
                            style: {
                                width: width - 52,
                                height: 48,
                                marginTop: 15,
                                marginLeft: 26,
                                marginBottom: 26
                            },
                            normalColor: "#5696ff",
                            pressColor: "#3f85fb",
                            text: (0, _MHLocalizableString.getString)('updateNow'),
                            onPress: _this.updateNow,
                            textStyle: {
                                color: "#FFFFFF",
                                fontSize: 13,
                                fontFamily: Const.fontFamily
                            }
                        })
                    );
                } else if (_this.state.status == 6) {
                    return _this.renderBottomView1((0, _MHLocalizableString.getString)("sure"), _this.back);
                }

                return null;
            };

            _this.state = {
                imageRes: _require(_dependencyMap[11]),
                status: 1,
                newVersion: "",
                key: "" + Date.now(),
                progress: 0,
                currentVersion: gData.curVersion ? gData.curVersion : ""
            };
            _this.errs = {
                "-33001": (0, _MHLocalizableString.getString)("upgradeErr1"),
                "-33002": (0, _MHLocalizableString.getString)("upgradeErr1"),
                "-33003": (0, _MHLocalizableString.getString)("upgradeErr1"),
                "-33004": (0, _MHLocalizableString.getString)("upgradeErr1"),
                "-33005": (0, _MHLocalizableString.getString)("upgradeErr5"),
                "-33006": (0, _MHLocalizableString.getString)("upgradeErr1"),
                "-33007": (0, _MHLocalizableString.getString)("upgradeErr7"),
                "-33008": (0, _MHLocalizableString.getString)("upgradeErr8"),
                "-33020": (0, _MHLocalizableString.getString)("upgradeErr5")
            };
            return _this;
        }

        babelHelpers.createClass(OTAPage, [{
            key: "componentDidMount",
            value: function componentDidMount() {
                this.isMount = true;
                this.checkDeviceVersion();

                _reactNative.AppState.addEventListener('change', this._handleAppStateChange);
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this.isMount = false;

                _reactNative.AppState.removeEventListener('change', this._handleAppStateChange);
            }
        }, {
            key: "render",
            value: function render() {
                console.log("------------render");
                return _react2.default.createElement(
                    _reactNative.View,
                    {
                        style: styles.container
                    },
                    _react2.default.createElement(
                        _reactNative.ScrollView,
                        {
                            style: styles.container
                        },
                        _react2.default.createElement(
                            _reactNative.View,
                            {
                                style: [styles.container, {}]
                            },
                            this.renderImage(),
                            this.renderTipText()
                        )
                    ),
                    this.renderBottomView(),
                    _react2.default.createElement(_Toast2.default, {
                        ref: "toast",
                        position: 'center',
                        height: Const.contentViewHeight
                    })
                );
            }
        }]);
        return OTAPage;
    }(_react2.default.Component);

    OTAPage.navigationOptions = function (_ref) {
        var navigation = _ref.navigation;
        return {
            header: _react2.default.createElement(
                _reactNative.View,
                null,
                _react2.default.createElement(_TitleBarBlack2.default, {
                    title: (0, _MHLocalizableString.getString)('otatitle'),
                    style: {
                        backgroundColor: '#fff'
                    },
                    showLine: true,
                    onPressLeft: function onPressLeft() {
                        navigation.goBack();
                    }
                })
            )
        };
    };

    exports.default = OTAPage;

    var styles = _reactNative.StyleSheet.create({
        container: {
            backgroundColor: 'rgba(255,255,255,1)',
            flex: 1.0
        },
        listItem: {
            height: 55,
            width: width,
            paddingLeft: 25,
            paddingRight: 25
        },
        line: {
            height: 1 / _reactNative.PixelRatio.get(),
            width: width,
            backgroundColor: 'rgba(0,0,0,0.1)'
        }
    });
},10565,[10297,10033,10121,10157,10340,10343,13636,10346,10074,10568,10571,10574,10577],"projects/com.dreame.devices/main/OTAPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 480,
    "height": 480,
    "scales": [1],
    "hash": "45713ed1c0882146d66ce7d5823f341c",
    "name": "update_success",
    "type": "png"
  });
},10568,[10420],"projects/com.dreame.devices/resources/update_success.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 480,
    "height": 480,
    "scales": [1],
    "hash": "60689e301a8c7043d1e0dab8d52f07bd",
    "name": "update_error",
    "type": "png"
  });
},10571,[10420],"projects/com.dreame.devices/resources/update_error.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 480,
    "height": 480,
    "scales": [1],
    "hash": "7f8e54eb0698373db62181ff645132f5",
    "name": "update_before",
    "type": "png"
  });
},10574,[10420],"projects/com.dreame.devices/resources/update_before.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  module.exports = _require(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/projects/com.dreame.devices/resources",
    "width": 480,
    "height": 480,
    "scales": [1],
    "hash": "12de22cfa7224d8b1559303f2f34bd0e",
    "name": "update_finish",
    "type": "png"
  });
},10577,[10420],"projects/com.dreame.devices/resources/update_finish.png");
__d(function (global, _require, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = _require(_dependencyMap[0]);

  var _react2 = babelHelpers.interopRequireDefault(_react);

  var _reactNative = _require(_dependencyMap[1]);

  var _TitleBarBlack = _require(_dependencyMap[2]);

  var _TitleBarBlack2 = babelHelpers.interopRequireDefault(_TitleBarBlack);

  var _MHLocalizableString = _require(_dependencyMap[3]);

  var _SettingListItemView = _require(_dependencyMap[4]);

  var _SettingListItemView2 = babelHelpers.interopRequireDefault(_SettingListItemView);

  var _miot = _require(_dependencyMap[5]);

  var _LoadingDialog = _require(_dependencyMap[6]);

  var _LoadingDialog2 = babelHelpers.interopRequireDefault(_LoadingDialog);

  var _CopyMessageDialog = _require(_dependencyMap[7]);

  var _CopyMessageDialog2 = babelHelpers.interopRequireDefault(_CopyMessageDialog);

  var did = _miot.Device.getDeviceWifi().deviceID;

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      width = _Dimensions$get.width,
      height = _Dimensions$get.height;

  var otaUrl3 = "https://cnbj2.fds.api.xiaomi.com/productinfo/log/otaca.json";

  var CalibrationPage = function (_React$Component) {
    babelHelpers.inherits(CalibrationPage, _React$Component);

    function CalibrationPage(props) {
      babelHelpers.classCallCheck(this, CalibrationPage);

      var _this = babelHelpers.possibleConstructorReturn(this, (CalibrationPage.__proto__ || Object.getPrototypeOf(CalibrationPage)).call(this, props));

      _this.loadOtaList = function () {
        var url = otaUrl3 + "?" + Date.now();
        fetch(url).then(function (res) {
          return res.json();
        }).then(function (data) {
          if (data.code == 0 && data.data) {
            _this.setState({
              otalist: data.data,
              hasDebuglist: data.data.length > 0
            });
          }
        }).catch(function (e) {});
      };

      _this.testgyro = function () {
        _this.sendTest("gyro1", function () {
          _this.setState({
            loadVisiable: true,
            loadTip: "陀螺仪标定",
            timeout: 60000
          });
        });
      };

      _this.testgyro2 = function () {
        _this.sendTest("gyro2", function () {
          _this.setState({
            loadVisiable: true,
            loadTip: "陀螺仪标定确认",
            timeout: 10000
          });
        });
      };

      _this.dismissMsgDialog = function () {
        _this.setState({
          dialogVisible: false
        });
      };

      _this.testlightA = function () {
        _this.sendTest("light1", function () {
          _this.setState({
            loadVisiable: true,
            loadTip: "光流A标定",
            timeout: 40000
          });
        });
      };

      _this.testlightB = function () {
        _this.sendTest("light2", function () {
          _this.setState({
            loadVisiable: true,
            loadTip: "光流B标定",
            timeout: 40000
          });
        });
      };

      _this.sendTest = function (test, cb) {
        _miot.Device.getDeviceWifi().callMethod("set_properties", [{
          "did": did,
          "siid": 99,
          "piid": 1,
          "value": test
        }]).then(function (res) {
          if (cb) {
            cb(null);
          }
        }).catch(function (err) {
          cb(err);
        });
      };

      _this.dismissLoad = function () {
        _this.setState({
          loadVisiable: false,
          loadTip: ""
        });
      };

      _this.onItemClick = function (index) {
        var item = _this.state.otalist[index];
        var url = item.url;
        var md5 = item.md5;

        _miot.Device.getDeviceWifi().callMethod("miIO.ota", {
          "app_url": url,
          "file_md5": md5,
          "proc": "dnld install",
          "mode": "normal",
          "install": "1"
        }).then(function (res) {
          _reactNative.Alert.alert(JSON.stringify(res));
        }).catch(function (err) {
          _reactNative.Alert.alert("err:" + JSON.stringify(err));
        });
      };

      _this.state = {
        loadVisiable: false,
        loadTip: "",
        dialogVisible: false,
        dialogTitle: "提示",
        dialogMessage: "请将机器搬至起始位置，搬动完成后点击确定按钮",
        otalist: []
      };
      return _this;
    }

    babelHelpers.createClass(CalibrationPage, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this.loadOtaList();
        this.propChangeListener = _miot.DeviceEvent.deviceReceivedMessages.addListener(function (device, messages) {
          if (messages.has('event.99.1')) {
            var prop = messages.get('event.99.1');
            console.log(JSON.stringify(prop));

            if (Array.isArray(prop) && prop.length > 0) {
              var value = prop[0].value;

              if (value == "gyro2") {
                _this2.setState({
                  loadVisiable: false
                });
              } else {
                var msgs = {
                  gyro20: "陀螺仪标定成功",
                  gyro21: "陀螺仪标定失败",
                  light10: "光流A标定成功",
                  light11: "光流A标定失败",
                  light20: "光流B标定成功",
                  light21: "光流B标定失败"
                };

                if (msgs[value]) {
                  _this2.setState({
                    loadVisiable: false,
                    dialogVisible: true,
                    dialogMessage: msgs[value],
                    dialogConfium: _this2.dismissMsgDialog
                  });
                }
              }
            }
          }
        });
        this.msgSubscription = null;

        _miot.Device.getDeviceWifi().subscribeMessages('event.99.1').then(function (subcription) {
          _this2.msgSubscription = subcription;
          console.log('subscribe success');
        }).catch(function () {
          _reactNative.Alert.alert("订阅失败，无法标定");
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.msgSubscription) {
          this.msgSubscription.remove();
        }

        if (this.propChangeListener) {
          this.propChangeListener.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var tips = "一、可标定固件是1015版本之后的固件，如果当前版本低于1015，请先升级至1015以上的版本；在该页面升级请确保APP和设备不在同一局域网\n\n二、陀螺仪标定\n1.将机器放到水平地面，机身与标准线垂直、左右撞板缝隙对其标准线;\n2.点击“陀螺仪标定”，机器静止10s后启动，自转10圈后停止；\n3.待机器旋转停止，主机播报语音请手动将机器旋转至起始位置后， 将机器旋转到起始位置，点击“陀螺仪搬动确认”按钮；\n4.机器返回标定结果并播报语音\n\n三、光流标定\n1.先标定A再标定B，地面要求光滑瓷砖，光流A和B标定起始方向一致，场地至少4m*1m；\n2.点击“光流A/B标定”后，机器播放开始标定语音，机器前进3m后掉头回到起点后提示成功或失败";
        return _react2.default.createElement(
          _reactNative.ScrollView,
          {
            style: styles.container
          },
          this.state.otalist.map(function (item, index) {
            var w = (_this3.props.width - 70) / 4;
            return _react2.default.createElement(_SettingListItemView2.default, {
              key: 'dash' + index,
              style: styles.listItem,
              leftText: "OTA to ",
              rightText: item.version,
              onPress: function onPress() {
                _this3.onItemClick(index);
              },
              hideArrow: true
            });
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "陀螺仪标定",
            onPress: this.testgyro,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "陀螺仪搬动确认",
            onPress: this.testgyro2,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "光流A标定",
            onPress: this.testlightA,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(_SettingListItemView2.default, {
            style: styles.listItem,
            leftText: "光流B标定",
            onPress: this.testlightB,
            hideArrow: true
          }),
          _react2.default.createElement(_reactNative.View, {
            style: styles.line
          }),
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: {
                fontSize: 17,
                marginTop: 10,
                marginLeft: 20,
                marginRight: 20,
                fontFamily: Const.fontFamily,
                color: 'rgba(0,0,0,1)'
              }
            },
            "\u5907\u6CE8\uFF1A"
          ),
          _react2.default.createElement(
            _reactNative.Text,
            {
              style: {
                fontSize: 17,
                marginTop: 10,
                marginLeft: 20,
                marginRight: 20,
                fontFamily: Const.fontFamily,
                color: 'rgba(0,0,0,1)'
              }
            },
            tips
          ),
          _react2.default.createElement(_LoadingDialog2.default, {
            visible: this.state.loadVisiable,
            cancelable: false,
            timeout: this.state.timeout,
            onDismiss: this.dismissLoad,
            message: this.state.loadTip
          }),
          _react2.default.createElement(_CopyMessageDialog2.default, {
            visible: this.state.dialogVisible,
            title: this.state.dialogTitle,
            message: this.state.dialogMessage,
            canDismiss: false,
            buttons: [{
              text: (0, _MHLocalizableString.getString)('sure'),
              style: {
                color: '#5696ff'
              },
              callback: function callback(_) {
                _this3.state.dialogConfium();
              }
            }]
          })
        );
      }
    }]);
    return CalibrationPage;
  }(_react2.default.Component);

  CalibrationPage.navigationOptions = function (_ref) {
    var navigation = _ref.navigation;
    return {
      header: _react2.default.createElement(
        _reactNative.View,
        null,
        _react2.default.createElement(_TitleBarBlack2.default, {
          title: '传感器标定',
          style: {
            backgroundColor: '#fff'
          },
          showLine: true,
          onPressLeft: function onPressLeft() {
            navigation.goBack();
          }
        })
      )
    };
  };

  exports.default = CalibrationPage;

  var styles = _reactNative.StyleSheet.create({
    container: {
      backgroundColor: '#fff',
      flex: 1.0
    },
    listItem: {
      height: 50,
      marginLeft: 20,
      marginRight: 20,
      flex: 1.0
    },
    line: {
      height: 1,
      flex: 1.0,
      marginLeft: 20,
      backgroundColor: 'rgba(0,0,0,0.1)'
    }
  });
},10580,[10297,10033,10121,10157,10340,10074,10740,10289],"projects/com.dreame.devices/main/CalibrationPage.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    Object.defineProperty(exports, "__esModule", {
        value: true
    });

    var _MHLocalizableString = _require(_dependencyMap[0]);

    var LedMode = {
        PowerOn: 0,
        Working: 1,
        Standby: 2,
        Pause: 3,
        Backhome_Normal: 4,
        Backhome_LowPower: 5,
        Charging_NoTask_Workable: 6,
        Charging_NoTask_UnWorkable: 7,
        ChargeDone_NoTask: 8,
        Charging_ContinueWork_Able: 9,
        Charging_ContinueWork_Unable: 10,
        SetWifiPassword_Normal: 11,
        SetWifiPassword_Charging_Lowpower: 12,
        SetWifiPassword_Charging: 13,
        SetWifiPassword_ChargDone: 14,
        LinkServer_Normal: 15,
        LinkServer_Charging_LowPower: 16,
        LinkServer_Charging: 17,
        LinkServer_ChargDone: 18,
        SetWIfiOK_Normal: 19,
        SetWIfiOK_Charging_LowPower: 20,
        SetWIfiOK_Charging: 21,
        SetWIfiOK_ChargDone: 22,
        SetWIfiFault_Normal: 23,
        SetWIfiFault__Charging_LowPower: 24,
        SetWIfiFault__Charging: 25,
        SetWIfiFault__ChargDone: 26,
        Working_ERROR: 27,
        Working_ERROR__Charging_LowPower: 28,
        Working_ERROR__Charging: 29,
        Working_ERROR__ChargDone: 30,
        Charging_ERROR: 31,
        OTA: 32,
        OFF: 33,
        Charging_OFF: 34
    };
    var WorkMode = {
        IdleMode: 0,
        PauseAndStopMode: 1,
        AutoCleanMode: 2,
        BackHomeMode: 3,
        PartCleanMode: 4,
        FollowWallMode: 5,
        ChargingMode: 6,
        OtaModeMode: 7,
        FctModeMode: 8,
        WIFISetMode: 9,
        PowerOffMode: 10,
        FactoryMode: 11,
        ErrRepotMode: 12,
        RemoteCtrlMode: 13,
        SleepMode: 14,
        SelfTestMode: 15,
        FactoryFuncTest: 16,
        StandbyMode: 17
    };
    var ChargingStatus = {
        Charging: 1,
        Not_Charging: 2,
        Err_Charging: 3,
        CompletedCharge: 4
    };

    var StatusManage = function StatusManage() {
        var _this = this;

        babelHelpers.classCallCheck(this, StatusManage);

        this.setBattery = function (battery) {
            if (_this.currentBattery > 0) {
                if (battery > _this.currentBattery && !_this.isOnCharge()) {
                    if (_this.onRefreshDataListener) {
                        _this.onRefreshDataListener();
                    }
                }
            }

            _this.currentBattery = battery;

            _this.statusChanged();
        };

        this.setWorkMode = function (workMode) {
            if (workMode == undefined) {
                return;
            }

            _this.workMode = workMode;

            _this.statusChanged();
        };

        this.setLedMode = function (ledMode) {
            if (ledMode == undefined) {
                return;
            }

            _this.ledMode = ledMode;
        };

        this.setWaterBoxStatus = function (waterBox) {
            if (waterBox == undefined) {
                return;
            }

            _this.waterBox = waterBox;
        };

        this.setChargingStatus = function (chargingStatus) {
            if (chargingStatus == undefined) {
                return false;
            }

            var changeToCharging = false;

            if (_this.chargingStatus != ChargingStatus.Charging && chargingStatus == ChargingStatus.Charging) {
                changeToCharging = true;
            }

            _this.chargingStatus = chargingStatus;

            _this.statusChanged();

            return changeToCharging;
        };

        this.setTaskStatus = function (taskStatus) {
            if (taskStatus == undefined) {
                return;
            }

            _this.taskStatus = taskStatus;
        };

        this.hasWarn = function () {
            return _this.warnCode > 0;
        };

        this.hasNotWorkWarn = function () {
            return _this.warnCode > 0 && _this.warnCode != 20;
        };

        this.setWarnCode = function (warnCode) {
            _this.warnCode = warnCode;

            _this.statusChanged();
        };

        this.isSleep = function () {
            return _this.workMode == WorkMode.SleepMode;
        };

        this.hasTask = function () {
            return _this.taskStatus == 0;
        };

        this.isGoCharing = function () {
            if (_this.workMode == WorkMode.BackHomeMode) {
                return true;
            }

            return false;
        };

        this.isCharging = function () {
            if (_this.chargingStatus == ChargingStatus.Charging) {
                return true;
            }

            return false;
        };

        this.isOnCharge = function () {
            if (_this.chargingStatus == ChargingStatus.Charging || _this.chargingStatus == ChargingStatus.CompletedCharge) {
                return true;
            }

            return false;
        };

        this.isCleaning = function () {
            if (_this.workMode == WorkMode.AutoCleanMode || _this.workMode == WorkMode.PartCleanMode || _this.workMode == WorkMode.RemoteCtrlMode || _this.workMode == WorkMode.FollowWallMode) {
                return true;
            }

            return false;
        };

        this.statusChanged = function () {
            if (_this.statusIsConflicting()) {
                if (_this.runningTask) {
                    return;
                }

                _this.runningTask = setTimeout(function () {
                    if (_this.statusIsConflicting()) {
                        if (_this.onRefreshDataListener) {
                            _this.onRefreshDataListener();
                        }
                    }

                    _this.runningTask = undefined;
                }, 5000);
            } else {
                _this.clearTask();
            }
        };

        this.clearTask = function () {
            if (_this.runningTask) {
                clearTimeout(_this.runningTask);
                _this.runningTask = undefined;
            }
        };

        this.setOnRefreshDataListener = function (listener) {
            _this.onRefreshDataListener = listener;
        };

        this.statusIsConflicting = function () {
            if (_this.isOnCharge() && (_this.isCleaning() || _this.isGoCharing())) {
                return true;
            }

            if (_this.hasNotWorkWarn() && (_this.isGoCharing() || _this.isCleaning())) {
                return true;
            }

            if (_this.currentBattery != -1 && _this.currentBattery > 15 && _this.warnCode == 20) {
                return true;
            }

            return false;
        };

        this.getStatusText = function () {
            console.log("getStatusText", _this.waterBox, _this.workMode, _this.taskStatus, _this.ledMode, _this.chargingStatus);

            if (_this.waterBox == 1 && _this.isCleaning()) {
                return (0, _MHLocalizableString.getString)('mop');
            }

            if (_this.workMode == WorkMode.AutoCleanMode || _this.workMode == WorkMode.FollowWallMode) {
                return (0, _MHLocalizableString.getString)('cleaning');
            } else if (_this.workMode == WorkMode.PartCleanMode) {
                return (0, _MHLocalizableString.getString)('localClean');
            } else if (_this.workMode == WorkMode.RemoteCtrlMode) {
                return (0, _MHLocalizableString.getString)('remoteClean');
            } else if (_this.workMode == WorkMode.BackHomeMode) {
                return (0, _MHLocalizableString.getString)('gocharging');
            } else {
                if (_this.taskStatus == 0) {
                    return (0, _MHLocalizableString.getString)('pause');
                }

                if (_this.chargingStatus == ChargingStatus.Charging) {
                    return (0, _MHLocalizableString.getString)('charging');
                }

                if (_this.chargingStatus == ChargingStatus.CompletedCharge) {
                    return (0, _MHLocalizableString.getString)("completedCharge");
                }
            }

            return (0, _MHLocalizableString.getString)('waiting');
        };

        this.getChargingButtonText = function () {
            if (_this.workMode == WorkMode.BackHomeMode) {
                return (0, _MHLocalizableString.getString)('chargePause');
            }

            if (_this.chargingStatus == ChargingStatus.Charging) {
                return (0, _MHLocalizableString.getString)('chargingBtnText');
            }

            if (_this.chargingStatus == ChargingStatus.CompletedCharge) {
                return (0, _MHLocalizableString.getString)("completedChargeBtnText");
            }

            return (0, _MHLocalizableString.getString)("charge");
        };

        this.getCleanButtonText = function () {
            if (_this.isCleaning()) {
                return (0, _MHLocalizableString.getString)("cleanPause");
            } else {
                return (0, _MHLocalizableString.getString)("cleanStart");
            }
        };

        this.showRemoveWaterBoxTip = function () {
            if (_this.waterBox == 1 && (_this.chargingStatus == ChargingStatus.Charging || _this.chargingStatus == ChargingStatus.CompletedCharge)) {
                return true;
            }

            return false;
        };

        this.showKeepSweeperTip = function () {
            if (_this.isCleaning() || _this.isGoCharing()) {
                return false;
            }

            if (_this.taskStatus == 0 && _this.isOnCharge()) {
                return true;
            }

            return false;
        };

        this.ledMode = 0;
        this.workMode = 0;
        this.waterBox = 0;
        this.chargingStatus = 0;
        this.taskStatus = 1;
        this.warnCode = 0;
        this.currentBattery = -1;
    };

    exports.default = StatusManage;
},10583,[10157],"projects/com.dreame.devices/main/DreameUtil/StatusUtil.js");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/HK",
        "scales": [1],
        "hash": "e3d08d7b0a3e8f79689aed2d8ac0c6fb",
        "name": "general_license",
        "type": "html"
    });
},10586,[10420],"projects/com.dreame.devices/resources/web/license/HK/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/HK",
        "scales": [1],
        "hash": "c227a33cb1cdc289e44b04f09aaf9d41",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10589,[10420],"projects/com.dreame.devices/resources/web/license/HK/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/TW",
        "scales": [1],
        "hash": "03d1ad63d4c7fff14c09bf97a28f97e6",
        "name": "general_license",
        "type": "html"
    });
},10592,[10420],"projects/com.dreame.devices/resources/web/license/TW/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/TW",
        "scales": [1],
        "hash": "0591acdebebdd5fc722a0094a7844ce8",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10595,[10420],"projects/com.dreame.devices/resources/web/license/TW/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/C-IL",
        "scales": [1],
        "hash": "7bb6d907ff568139e9b2b1bc79983d6f",
        "name": "general_license",
        "type": "html"
    });
},10598,[10420],"projects/com.dreame.devices/resources/web/license/C-IL/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/C-IL",
        "scales": [1],
        "hash": "90ea6d842ea0d9de096f964a1832f634",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10601,[10420],"projects/com.dreame.devices/resources/web/license/C-IL/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/TR",
        "scales": [1],
        "hash": "e304b74d5d10640b1ed5c64aa1f0333b",
        "name": "general_license",
        "type": "html"
    });
},10604,[10420],"projects/com.dreame.devices/resources/web/license/TR/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/TR",
        "scales": [1],
        "hash": "a65d929573c7dd7e601e0613f2f5f75f",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10607,[10420],"projects/com.dreame.devices/resources/web/license/TR/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/TH",
        "scales": [1],
        "hash": "a44d00446acb30b1523b73937cfbcbb3",
        "name": "general_license",
        "type": "html"
    });
},10610,[10420],"projects/com.dreame.devices/resources/web/license/TH/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/TH",
        "scales": [1],
        "hash": "5f3f2e302fa4a89c640c9018d77a3cbf",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10613,[10420],"projects/com.dreame.devices/resources/web/license/TH/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/VI",
        "scales": [1],
        "hash": "776ab0f972c3942410dc9471564f1b96",
        "name": "general_license",
        "type": "html"
    });
},10616,[10420],"projects/com.dreame.devices/resources/web/license/VI/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/VI",
        "scales": [1],
        "hash": "7331d6fb05a68b23a7f1fe02cd5a7a14",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10619,[10420],"projects/com.dreame.devices/resources/web/license/VI/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/MY",
        "scales": [1],
        "hash": "8e9966316749d2a8b92c3cfc0ccefcbd",
        "name": "general_license",
        "type": "html"
    });
},10622,[10420],"projects/com.dreame.devices/resources/web/license/MY/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/MY",
        "scales": [1],
        "hash": "c0d7c917daf0229595e9f9722698dcb9",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10625,[10420],"projects/com.dreame.devices/resources/web/license/MY/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ID",
        "scales": [1],
        "hash": "2408f096df24cf57ff95ca502a20b346",
        "name": "general_license",
        "type": "html"
    });
},10628,[10420],"projects/com.dreame.devices/resources/web/license/ID/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ID",
        "scales": [1],
        "hash": "ea51537764a569494a93678b717cf609",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10631,[10420],"projects/com.dreame.devices/resources/web/license/ID/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/JA",
        "scales": [1],
        "hash": "5a789b4c8c1584a1bccd53727c6297bf",
        "name": "general_license",
        "type": "html"
    });
},10634,[10420],"projects/com.dreame.devices/resources/web/license/JA/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/JA",
        "scales": [1],
        "hash": "913f1192d7fd4ca6d257d5515127142f",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10637,[10420],"projects/com.dreame.devices/resources/web/license/JA/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/AR",
        "scales": [1],
        "hash": "dc84a359d1bb37434d251bcdc28a06aa",
        "name": "general_license",
        "type": "html"
    });
},10640,[10420],"projects/com.dreame.devices/resources/web/license/AR/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/AR",
        "scales": [1],
        "hash": "e3c7c98427f47f879457a27dfdc1304d",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10643,[10420],"projects/com.dreame.devices/resources/web/license/AR/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/AR-EN",
        "scales": [1],
        "hash": "b654f4d699ff2e0c2c8130ac0e9aa571",
        "name": "general_license",
        "type": "html"
    });
},10646,[10420],"projects/com.dreame.devices/resources/web/license/AR-EN/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/AR-EN",
        "scales": [1],
        "hash": "ea071c4411c46f6e50393b7f4cec5806",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10649,[10420],"projects/com.dreame.devices/resources/web/license/AR-EN/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "63619ae1bc95d5e3cc35406ff2072e9d",
        "name": "general_license",
        "type": "html"
    });
},10652,[10420],"projects/com.dreame.devices/resources/web/license/EN/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "851dc3c33d2bf0c6cb73f3ca3450e243",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10655,[10420],"projects/com.dreame.devices/resources/web/license/EN/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ES",
        "scales": [1],
        "hash": "b0f99f4d623691691034930a69719fd4",
        "name": "gdpr_license",
        "type": "html"
    });
},10658,[10420],"projects/com.dreame.devices/resources/web/license/ES/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ES",
        "scales": [1],
        "hash": "81a400f405b925b596347dee9f0591ed",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10661,[10420],"projects/com.dreame.devices/resources/web/license/ES/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/DE",
        "scales": [1],
        "hash": "d206803feb1985ddc679b48f43eb0fa8",
        "name": "gdpr_license",
        "type": "html"
    });
},10664,[10420],"projects/com.dreame.devices/resources/web/license/DE/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/DE",
        "scales": [1],
        "hash": "3c2f879b0ee42b991231079b8882e6df",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10667,[10420],"projects/com.dreame.devices/resources/web/license/DE/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/FR",
        "scales": [1],
        "hash": "bc60163b9c6fe2369af7b195b0b0e80f",
        "name": "gdpr_license",
        "type": "html"
    });
},10670,[10420],"projects/com.dreame.devices/resources/web/license/FR/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/FR",
        "scales": [1],
        "hash": "f74a7af317c5ceb0f6e1688445dfbff4",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10673,[10420],"projects/com.dreame.devices/resources/web/license/FR/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "836305521a117370765b4d14c75bab3e",
        "name": "gdpr_license",
        "type": "html"
    });
},10676,[10420],"projects/com.dreame.devices/resources/web/license/EN/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "a96d2449f19616b9510118ac763d5866",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10679,[10420],"projects/com.dreame.devices/resources/web/license/EN/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/IT",
        "scales": [1],
        "hash": "d581e03dcd35448b67767ad97cf1d7df",
        "name": "gdpr_license",
        "type": "html"
    });
},10682,[10420],"projects/com.dreame.devices/resources/web/license/IT/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/IT",
        "scales": [1],
        "hash": "862e88f2fc1d61bdabdd2c6b2ec9f1ce",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10685,[10420],"projects/com.dreame.devices/resources/web/license/IT/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/PL",
        "scales": [1],
        "hash": "d5360a838acd51a3978fb9681bc6ba19",
        "name": "gdpr_license",
        "type": "html"
    });
},10688,[10420],"projects/com.dreame.devices/resources/web/license/PL/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/PL",
        "scales": [1],
        "hash": "0161a2b49bfdf97eb92d70d2ba93f676",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10691,[10420],"projects/com.dreame.devices/resources/web/license/PL/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/CS",
        "scales": [1],
        "hash": "c0ea280385ffd46a0952e4c2353d9254",
        "name": "gdpr_license",
        "type": "html"
    });
},10694,[10420],"projects/com.dreame.devices/resources/web/license/CS/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/CS",
        "scales": [1],
        "hash": "cfe9d637cb5b3718860efd558a2044c7",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10697,[10420],"projects/com.dreame.devices/resources/web/license/CS/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/C-CH",
        "scales": [1],
        "hash": "4f98299d1e1c4bc588ecc4fee3fc26b5",
        "name": "gdpr_license",
        "type": "html"
    });
},10700,[10420],"projects/com.dreame.devices/resources/web/license/C-CH/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/C-CH",
        "scales": [1],
        "hash": "f945985ca0395cac58799e5237c009eb",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10703,[10420],"projects/com.dreame.devices/resources/web/license/C-CH/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/UK",
        "scales": [1],
        "hash": "e74f0dc6ea29f1078f48e5b707703caf",
        "name": "general_license",
        "type": "html"
    });
},10706,[10420],"projects/com.dreame.devices/resources/web/license/UK/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/UK",
        "scales": [1],
        "hash": "d4698552b2d8c628c161fc098b0f058b",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10709,[10420],"projects/com.dreame.devices/resources/web/license/UK/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/PT",
        "scales": [1],
        "hash": "68e3928048b79c5b72b30dd99260ba17",
        "name": "gdpr_license",
        "type": "html"
    });
},10712,[10420],"projects/com.dreame.devices/resources/web/license/PT/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/PT",
        "scales": [1],
        "hash": "25134d6506211e2cddfbfb0776ae5aa9",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10715,[10420],"projects/com.dreame.devices/resources/web/license/PT/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/RO",
        "scales": [1],
        "hash": "1855ba02bcc19654f3d533211adbc08c",
        "name": "gdpr_license",
        "type": "html"
    });
},10718,[10420],"projects/com.dreame.devices/resources/web/license/RO/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/RO",
        "scales": [1],
        "hash": "bfe93f680b2d6cf122290f690cd758e5",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10721,[10420],"projects/com.dreame.devices/resources/web/license/RO/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/SK",
        "scales": [1],
        "hash": "8281a31fa25f156f0c79c4e65888f0b9",
        "name": "gdpr_license",
        "type": "html"
    });
},10724,[10420],"projects/com.dreame.devices/resources/web/license/SK/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/SK",
        "scales": [1],
        "hash": "5d28c6e1c0017cc05cb970997983b476",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10727,[10420],"projects/com.dreame.devices/resources/web/license/SK/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EL-EN",
        "scales": [1],
        "hash": "5b8129ca497882e430a5b76221496961",
        "name": "gdpr_license",
        "type": "html"
    });
},10730,[10420],"projects/com.dreame.devices/resources/web/license/EL-EN/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EL-EN",
        "scales": [1],
        "hash": "5935461b377a8a5d306246c386a0094d",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10733,[10420],"projects/com.dreame.devices/resources/web/license/EL-EN/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/BG",
        "scales": [1],
        "hash": "fdd0043425eb486c33503c6f8f2a5e6b",
        "name": "gdpr_license",
        "type": "html"
    });
},10736,[10420],"projects/com.dreame.devices/resources/web/license/BG/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/BG",
        "scales": [1],
        "hash": "3deecc0a9f9e7ed932e0fb829b13d70f",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10739,[10420],"projects/com.dreame.devices/resources/web/license/BG/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/SL",
        "scales": [1],
        "hash": "94aed6097271b18ebe19e2c54dbebf32",
        "name": "gdpr_license",
        "type": "html"
    });
},10742,[10420],"projects/com.dreame.devices/resources/web/license/SL/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/SL",
        "scales": [1],
        "hash": "22584ff4609236c7f6a203eddddb0fc9",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10745,[10420],"projects/com.dreame.devices/resources/web/license/SL/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/HU",
        "scales": [1],
        "hash": "c97a0ad1c47a588c6dab5a6c66f5ce0b",
        "name": "gdpr_license",
        "type": "html"
    });
},10748,[10420],"projects/com.dreame.devices/resources/web/license/HU/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/HU",
        "scales": [1],
        "hash": "b65f4260d12ff83fc34fe8885a8dd60d",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10751,[10420],"projects/com.dreame.devices/resources/web/license/HU/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/LT",
        "scales": [1],
        "hash": "9dcca1838bba9d33786c9a9e46e695e7",
        "name": "gdpr_license",
        "type": "html"
    });
},10754,[10420],"projects/com.dreame.devices/resources/web/license/LT/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/LT",
        "scales": [1],
        "hash": "810d82c5581f669b059d78204554e717",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10757,[10420],"projects/com.dreame.devices/resources/web/license/LT/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ET",
        "scales": [1],
        "hash": "ecc3e23c8ea57337582782b162c0a4c8",
        "name": "gdpr_license",
        "type": "html"
    });
},10760,[10420],"projects/com.dreame.devices/resources/web/license/ET/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ET",
        "scales": [1],
        "hash": "35901c4ceb9efc42308c9e4976163f5e",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10763,[10420],"projects/com.dreame.devices/resources/web/license/ET/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/LV",
        "scales": [1],
        "hash": "0fce23b614112e707a2bfac1d69b1ef1",
        "name": "gdpr_license",
        "type": "html"
    });
},10766,[10420],"projects/com.dreame.devices/resources/web/license/LV/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/LV",
        "scales": [1],
        "hash": "5b2e6bf86b37fb944d747fb9a04f30bb",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10769,[10420],"projects/com.dreame.devices/resources/web/license/LV/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/FI",
        "scales": [1],
        "hash": "615d9c0cf5c2b048ebdc26f6d31693b3",
        "name": "gdpr_license",
        "type": "html"
    });
},10772,[10420],"projects/com.dreame.devices/resources/web/license/FI/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/FI",
        "scales": [1],
        "hash": "bd6effa3262483727bdb474e4c1e7a52",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10775,[10420],"projects/com.dreame.devices/resources/web/license/FI/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/DA",
        "scales": [1],
        "hash": "b6f5182afabd6424a445ecb2b616f063",
        "name": "gdpr_license",
        "type": "html"
    });
},10778,[10420],"projects/com.dreame.devices/resources/web/license/DA/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/DA",
        "scales": [1],
        "hash": "9b8a30688f0bcae0b426d70463454fb3",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10781,[10420],"projects/com.dreame.devices/resources/web/license/DA/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/SV",
        "scales": [1],
        "hash": "83c42d37f6459ff3f216a04c606326ee",
        "name": "gdpr_license",
        "type": "html"
    });
},10784,[10420],"projects/com.dreame.devices/resources/web/license/SV/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/SV",
        "scales": [1],
        "hash": "bd35605a635de86595146ad0197ca711",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10787,[10420],"projects/com.dreame.devices/resources/web/license/SV/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/NO",
        "scales": [1],
        "hash": "019d54508c82aedb979b93c9e07cb6e3",
        "name": "gdpr_license",
        "type": "html"
    });
},10790,[10420],"projects/com.dreame.devices/resources/web/license/NO/gdpr_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/NO",
        "scales": [1],
        "hash": "ce0aaa54c18421870b8af41c74d3cfa1",
        "name": "gdpr_privacyPolicy",
        "type": "html"
    });
},10793,[10420],"projects/com.dreame.devices/resources/web/license/NO/gdpr_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/BE",
        "scales": [1],
        "hash": "c66a002abc1bb4ef5396c32e6d50e8f7",
        "name": "general_license",
        "type": "html"
    });
},10796,[10420],"projects/com.dreame.devices/resources/web/license/BE/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/BE",
        "scales": [1],
        "hash": "d367b368bb17652547d2851f4800c437",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10799,[10420],"projects/com.dreame.devices/resources/web/license/BE/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/RU",
        "scales": [1],
        "hash": "378eb6a6c1b222b9bc77022adb57ea3b",
        "name": "general_license",
        "type": "html"
    });
},10802,[10420],"projects/com.dreame.devices/resources/web/license/RU/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/RU",
        "scales": [1],
        "hash": "d75b3b6f404cc7935f445f3edf0e7d26",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10805,[10420],"projects/com.dreame.devices/resources/web/license/RU/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/PT-BR",
        "scales": [1],
        "hash": "63e819243a3ad3d89a95c3fe819436a4",
        "name": "general_license",
        "type": "html"
    });
},10808,[10420],"projects/com.dreame.devices/resources/web/license/PT-BR/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/PT-BR",
        "scales": [1],
        "hash": "a4711e32660b4944495f0decc5ebba3b",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10811,[10420],"projects/com.dreame.devices/resources/web/license/PT-BR/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ES-LA-EN",
        "scales": [1],
        "hash": "8aa8996d83a015eed73afb8ad0618c48",
        "name": "general_license",
        "type": "html"
    });
},10814,[10420],"projects/com.dreame.devices/resources/web/license/ES-LA-EN/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ES-LA-EN",
        "scales": [1],
        "hash": "28698178d3c3aaf5c886f50237790ec9",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10817,[10420],"projects/com.dreame.devices/resources/web/license/ES-LA-EN/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/MS",
        "scales": [1],
        "hash": "501eabe35e9ce364422eafc9cf79a6e9",
        "name": "general_license",
        "type": "html"
    });
},10820,[10420],"projects/com.dreame.devices/resources/web/license/MS/general_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/MS",
        "scales": [1],
        "hash": "b0da7502fc63e4a88c7c65ad96cde7e6",
        "name": "general_privacyPolicy",
        "type": "html"
    });
},10823,[10420],"projects/com.dreame.devices/resources/web/license/MS/general_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ZH",
        "scales": [1],
        "hash": "8ceeb29170c7d2e072baa0951604c03e",
        "name": "license",
        "type": "html"
    });
},10826,[10420],"projects/com.dreame.devices/resources/web/license/ZH/license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/ZH",
		"scales": [1],
		"hash": "9e260a15b16d210a63c11b7d44262661",
		"name": "privacyPolicy",
		"type": "html"
	});
},10829,[10420],"projects/com.dreame.devices/resources/web/license/ZH/privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/KO",
        "scales": [1],
        "hash": "1fcb4ade47653b4ffdf7838416b0c264",
        "name": "korea_license",
        "type": "html"
    });
},10832,[10420],"projects/com.dreame.devices/resources/web/license/KO/korea_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/KO",
        "scales": [1],
        "hash": "2ebe1fac07a8d9f40247cc89d1af6c27",
        "name": "korea_privacyPolicy",
        "type": "html"
    });
},10835,[10420],"projects/com.dreame.devices/resources/web/license/KO/korea_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "b394e75c0d46a9e7a3908721ce78b3a4",
        "name": "korea_license",
        "type": "html"
    });
},10838,[10420],"projects/com.dreame.devices/resources/web/license/EN/korea_license.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "0c2ad4d8ecbf54e10fd8709dfdb868ba",
        "name": "korea_privacyPolicy",
        "type": "html"
    });
},10841,[10420],"projects/com.dreame.devices/resources/web/license/EN/korea_privacyPolicy.html");
__d(function (global, _require, module, exports, _dependencyMap) {
    module.exports = _require(_dependencyMap[0]).registerAsset({
        "__packager_asset": true,
        "httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
        "scales": [1],
        "hash": "20e7f48f68c3d9a7c875e301a0c64ee5",
        "name": "license_en",
        "type": "html"
    });
},10844,[10420],"projects/com.dreame.devices/resources/web/license/EN/license_en.html");
__d(function (global, _require, module, exports, _dependencyMap) {
	module.exports = _require(_dependencyMap[0]).registerAsset({
		"__packager_asset": true,
		"httpServerLocation": "/assets/projects/com.dreame.devices/resources/web/license/EN",
		"scales": [1],
		"hash": "ae753aba704e897a3c01c0a9652895b7",
		"name": "privacyPolicy_en",
		"type": "html"
	});
},10847,[10420],"projects/com.dreame.devices/resources/web/license/EN/privacyPolicy_en.html");
require(10120);
require(10001);